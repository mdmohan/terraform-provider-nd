// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_fabric_vxlan

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func FabricVxlanResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"aaa": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Include AAA configs from Manageability tab during device bootup",
				MarkdownDescription: "Include AAA configs from Manageability tab during device bootup",
				Default:             booldefault.StaticBool(false),
			},
			"advanced_ssh_option": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable AAA IP Authorization.  Enable only, when IP Authorization is enabled in the AAA Server",
				MarkdownDescription: "Enable AAA IP Authorization.  Enable only, when IP Authorization is enabled in the AAA Server",
				Default:             booldefault.StaticBool(false),
			},
			"advertise_physical_ip": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "For Primary VTEP IP Advertisement As Next-Hop Of Prefix Routes",
				MarkdownDescription: "For Primary VTEP IP Advertisement As Next-Hop Of Prefix Routes",
				Default:             booldefault.StaticBool(false),
			},
			"advertise_physical_ip_on_border": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable advertise-pip on vPC borders and border gateways only. Applicable only when vPC advertise-pip is not enabled",
				MarkdownDescription: "Enable advertise-pip on vPC borders and border gateways only. Applicable only when vPC advertise-pip is not enabled",
				Default:             booldefault.StaticBool(true),
			},
			"aiml_qos": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Configures QoS and Queuing Policies specific to N9K Cloud Scale switch fabric for AI/ML network loads",
				MarkdownDescription: "Configures QoS and Queuing Policies specific to N9K Cloud Scale switch fabric for AI/ML network loads",
				Default:             booldefault.StaticBool(false),
			},
			"aiml_qos_policy": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Queuing Policy based on predominant fabric link speed 800G / 400G / 100G / 25G",
				MarkdownDescription: "Queuing Policy based on predominant fabric link speed 800G / 400G / 100G / 25G",
				Default:             stringdefault.StaticString("400G"),
			},
			"alert_suspend": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Alert Suspend state configured on the fabric",
				MarkdownDescription: "Alert Suspend state configured on the fabric",
				Default:             stringdefault.StaticString("disabled"),
			},
			"allow_vlan_on_leaf_tor_pairing": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Set trunk allowed vlan to 'none' or 'all' for leaf-tor pairing port-channels",
				MarkdownDescription: "Set trunk allowed vlan to 'none' or 'all' for leaf-tor pairing port-channels",
				Default:             stringdefault.StaticString("none"),
			},
			"allowed_actions": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "Actions allowed on the listed fabrics",
				MarkdownDescription: "Actions allowed on the listed fabrics",
			},
			"analysis_settings_is_enabled": schema.BoolAttribute{
				Optional:            true,
				Description:         "Enable or disable Assurance analysis on the fabric. When enabled, the system will perform analysis of network data for assurance purposes.",
				MarkdownDescription: "Enable or disable Assurance analysis on the fabric. When enabled, the system will perform analysis of network data for assurance purposes.",
			},
			"anycast_border_gateway_advertise_physical_ip": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "To advertise Anycast Border Gateway PIP as VTEP. Effective on MSD fabric 'Recalculate Config'",
				MarkdownDescription: "To advertise Anycast Border Gateway PIP as VTEP. Effective on MSD fabric 'Recalculate Config'",
				Default:             booldefault.StaticBool(false),
			},
			"anycast_gateway_mac": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Shared anycast gateway MAC address for all VTEPs (xxxx.xxxx.xxxx)",
				MarkdownDescription: "Shared anycast gateway MAC address for all VTEPs (xxxx.xxxx.xxxx)",
			},
			"anycast_loopback_id": schema.Int64Attribute{
				Optional:            true,
				Description:         "Underlay Anycast Loopback Id.  Used for vPC Peering in VXLANv6 Fabrics",
				MarkdownDescription: "Underlay Anycast Loopback Id.  Used for vPC Peering in VXLANv6 Fabrics",
			},
			"anycast_rendezvous_point_ip_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Anycast or Phantom RP IP Address Range",
				MarkdownDescription: "Anycast or Phantom RP IP Address Range",
			},
			"auto_bgp_neighbor_description": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Generate BGP EVPN Neighbor Description",
				MarkdownDescription: "Generate BGP EVPN Neighbor Description",
				Default:             booldefault.StaticBool(true),
			},
			"auto_symmetric_default_vrf": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether to auto generate Default VRF interface and BGP peering configuration on managed neighbor devices. If set, auto created VRF Lite IFC links will have 'Auto Deploy Default VRF for Peer' enabled.",
				MarkdownDescription: "Whether to auto generate Default VRF interface and BGP peering configuration on managed neighbor devices. If set, auto created VRF Lite IFC links will have 'Auto Deploy Default VRF for Peer' enabled.",
				Default:             booldefault.StaticBool(false),
			},
			"auto_symmetric_vrf_lite": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether to auto generate VRF LITE sub-interface and BGP peering configuration on managed neighbor devices. If set, auto created VRF Lite IFC links will have 'Auto Deploy for Peer' enabled.",
				MarkdownDescription: "Whether to auto generate VRF LITE sub-interface and BGP peering configuration on managed neighbor devices. If set, auto created VRF Lite IFC links will have 'Auto Deploy for Peer' enabled.",
				Default:             booldefault.StaticBool(false),
			},
			"auto_unique_vrf_lite_ip_prefix": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "When enabled, IP prefix allocated to the VRF LITE IFC is not reused on VRF extension over VRF LITE IFC. Instead, unique IP Subnet is allocated for each VRF extension over VRF LITE IFC.",
				MarkdownDescription: "When enabled, IP prefix allocated to the VRF LITE IFC is not reused on VRF extension over VRF LITE IFC. Instead, unique IP Subnet is allocated for each VRF extension over VRF LITE IFC.",
				Default:             booldefault.StaticBool(false),
			},
			"auto_vrf_lite_default_vrf": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "For ipv4 underlay, whether to auto generate BGP peering in Default VRF for VRF Lite IFC auto deployment option. If set, will auto create VRF Lite Inter-Fabric links with 'Auto Deploy Default VRF' knob enabled",
				MarkdownDescription: "For ipv4 underlay, whether to auto generate BGP peering in Default VRF for VRF Lite IFC auto deployment option. If set, will auto create VRF Lite Inter-Fabric links with 'Auto Deploy Default VRF' knob enabled",
				Default:             booldefault.StaticBool(false),
			},
			"banner": schema.StringAttribute{
				Optional:            true,
				Description:         "Message of the Day (motd) banner. Delimiter char (very first char is delimiter char) followed by message ending with delimiter",
				MarkdownDescription: "Message of the Day (motd) banner. Delimiter char (very first char is delimiter char) followed by message ending with delimiter",
			},
			"bfd": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable BFD.  Valid for IPv4 Underlay only",
				MarkdownDescription: "Enable BFD.  Valid for IPv4 Underlay only",
				Default:             booldefault.StaticBool(false),
			},
			"bfd_authentication": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable BFD Authentication.  Valid for P2P Interfaces only",
				MarkdownDescription: "Enable BFD Authentication.  Valid for P2P Interfaces only",
				Default:             booldefault.StaticBool(false),
			},
			"bfd_authentication_key": schema.StringAttribute{
				Optional:            true,
				Description:         "Encrypted SHA1 secret value",
				MarkdownDescription: "Encrypted SHA1 secret value",
			},
			"bfd_authentication_key_id": schema.Int64Attribute{
				Optional:            true,
				Description:         "BFD Authentication Key ID",
				MarkdownDescription: "BFD Authentication Key ID",
			},
			"bfd_ibgp": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable BFD For iBGP",
				MarkdownDescription: "Enable BFD For iBGP",
				Default:             booldefault.StaticBool(false),
			},
			"bfd_isis": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable BFD For ISIS",
				MarkdownDescription: "Enable BFD For ISIS",
				Default:             booldefault.StaticBool(false),
			},
			"bfd_ospf": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable BFD For OSPF",
				MarkdownDescription: "Enable BFD For OSPF",
				Default:             booldefault.StaticBool(false),
			},
			"bfd_pim": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable BFD For PIM",
				MarkdownDescription: "Enable BFD For PIM",
				Default:             booldefault.StaticBool(false),
			},
			"bgp_asn": schema.StringAttribute{
				Required:            true,
				Description:         "Autonomous system number 1-4294967295 | 1-65535[.0-65535]",
				MarkdownDescription: "Autonomous system number 1-4294967295 | 1-65535[.0-65535]",
			},
			"bgp_authentication": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enables or disables the BGP Authentication",
				MarkdownDescription: "Enables or disables the BGP Authentication",
				Default:             booldefault.StaticBool(false),
			},
			"bgp_authentication_key": schema.StringAttribute{
				Optional:            true,
				Description:         "Encrypted BGP Authentication Key based on type",
				MarkdownDescription: "Encrypted BGP Authentication Key based on type",
			},
			"bgp_authentication_key_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("3des"),
			},
			"bgp_loopback_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Underlay Routing Loopback Id",
				MarkdownDescription: "Underlay Routing Loopback Id",
				Default:             int64default.StaticInt64(0),
			},
			"bgp_loopback_ip_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Typically Loopback0 IP Address Range",
				MarkdownDescription: "Typically Loopback0 IP Address Range",
				Default:             stringdefault.StaticString("10.2.0.0/22"),
			},
			"bgp_loopback_ipv6_range": schema.StringAttribute{
				Optional:            true,
				Description:         "Typically Loopback0 IPv6 Address Range",
				MarkdownDescription: "Typically Loopback0 IPv6 Address Range",
			},
			"bootstrap_multi_subnet": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "lines with # prefix are ignored here",
				MarkdownDescription: "lines with # prefix are ignored here",
			},
			"brownfield_network_name_format": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Generated network name should be less than 64 characters",
				MarkdownDescription: "Generated network name should be less than 64 characters",
				Default:             stringdefault.StaticString("Auto_Net_VNI$$VNI$$_VLAN$$VLAN_ID$$"),
			},
			"brownfield_skip_overlay_network_attachments": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Skip Overlay Network Interface Attachments for Brownfield and Host Port Resync cases",
				MarkdownDescription: "Skip Overlay Network Interface Attachments for Brownfield and Host Port Resync cases",
				Default:             booldefault.StaticBool(false),
			},
			"category": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Category name",
				MarkdownDescription: "Category name",
				Default:             stringdefault.StaticString("fabric"),
			},
			"cdp": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable CDP on the interface",
				MarkdownDescription: "Enable CDP on the interface",
				Default:             booldefault.StaticBool(false),
			},
			"controller_status": schema.StringAttribute{
				Optional:            true,
				Description:         "The controller status of the fabric_vxlan_evpn resource",
				MarkdownDescription: "The controller status of the fabric_vxlan_evpn resource",
			},
			"copp_policy": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Fabric Wide CoPP Policy. Customized CoPP policy should be provided when 'manual' is selected.",
				MarkdownDescription: "Fabric Wide CoPP Policy. Customized CoPP policy should be provided when 'manual' is selected.",
				Default:             stringdefault.StaticString("strict"),
			},
			"cost": schema.Float64Attribute{
				Optional:            true,
				Description:         "Energy cost in USD/kWh. Used for energy management calculations and reporting.",
				MarkdownDescription: "Energy cost in USD/kWh. Used for energy management calculations and reporting.",
			},
			"day0_bootstrap": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Automatic IP Assignment For POAP",
				MarkdownDescription: "Automatic IP Assignment For POAP",
				Default:             booldefault.StaticBool(false),
			},
			"default_private_vlan_secondary_network_template": schema.StringAttribute{
				Optional:            true,
				Description:         "Default PVLAN Secondary Network Template",
				MarkdownDescription: "Default PVLAN Secondary Network Template",
			},
			"default_queuing_policy": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable Default Queuing Policies",
				MarkdownDescription: "Enable Default Queuing Policies",
				Default:             booldefault.StaticBool(false),
			},
			"default_queuing_policy_cloudscale": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Queuing Policy for all 92xx, -EX, -FX, -FX2, -FX3, -GX series switches in the fabric",
				MarkdownDescription: "Queuing Policy for all 92xx, -EX, -FX, -FX2, -FX3, -GX series switches in the fabric",
				Default:             stringdefault.StaticString("queuing_policy_default_8q_cloudscale"),
			},
			"default_queuing_policy_other": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Queuing Policy for all other switches in the fabric",
				MarkdownDescription: "Queuing Policy for all other switches in the fabric",
				Default:             stringdefault.StaticString("queuing_policy_default_other"),
			},
			"default_queuing_policy_r_series": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Queueing policy for all Nexus R-series switches",
				MarkdownDescription: "Queueing policy for all Nexus R-series switches",
				Default:             stringdefault.StaticString("queuing_policy_default_r_series"),
			},
			"default_vrf_redistribution_bgp_route_map": schema.StringAttribute{
				Optional:            true,
				Description:         "Route Map used to redistribute BGP routes to IGP in default vrf in auto created VRF Lite IFC links",
				MarkdownDescription: "Route Map used to redistribute BGP routes to IGP in default vrf in auto created VRF Lite IFC links",
			},
			"dhcp_end_address": schema.StringAttribute{
				Optional:            true,
				Description:         "End Address For Switch POAP",
				MarkdownDescription: "End Address For Switch POAP",
			},
			"dhcp_protocol_version": schema.StringAttribute{
				Optional:            true,
				Description:         "IP protocol version for Local DHCP Server",
				MarkdownDescription: "IP protocol version for Local DHCP Server",
			},
			"dhcp_start_address": schema.StringAttribute{
				Optional:            true,
				Description:         "Start Address For Switch POAP",
				MarkdownDescription: "Start Address For Switch POAP",
			},
			"dns_collection": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "List of IPv4 and IPv6 DNS addresses",
				MarkdownDescription: "List of IPv4 and IPv6 DNS addresses",
			},
			"dns_vrf_collection": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "DNS Server VRFs. One VRF for all DNS servers or a list of VRFs, one per DNS server",
				MarkdownDescription: "DNS Server VRFs. One VRF for all DNS servers or a list of VRFs, one per DNS server",
			},
			"email": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"advisories": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"anomalies": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"collection_frequency_in_days": schema.Int64Attribute{
							Optional:            true,
							Description:         "Frequency of email alerts in days. Determines how often email alerts will be sent.",
							MarkdownDescription: "Frequency of email alerts in days. Determines how often email alerts will be sent.",
						},
						"collection_type": schema.StringAttribute{
							Optional:            true,
							Description:         "Type of email collection settings. Can be 'basic' or 'advanced' to specify the level of detail in email alerts.",
							MarkdownDescription: "Type of email collection settings. Can be 'basic' or 'advanced' to specify the level of detail in email alerts.",
						},
						"format": schema.StringAttribute{
							Optional:            true,
							Description:         "Email format. Can be 'html' or 'text' to specify the format of email alerts.",
							MarkdownDescription: "Email format. Can be 'html' or 'text' to specify the format of email alerts.",
						},
						"name": schema.StringAttribute{
							Optional:            true,
							Description:         "Name of the email configuration. Identifies this specific email notification configuration.",
							MarkdownDescription: "Name of the email configuration. Identifies this specific email notification configuration.",
						},
						"only_include_active_alerts": schema.BoolAttribute{
							Optional:            true,
							Description:         "When true, the email output will only include alerts that are currently active. Setting to false will include all alerts regardless of status.",
							MarkdownDescription: "When true, the email output will only include alerts that are currently active. Setting to false will include all alerts regardless of status.",
						},
						"receiver_email": schema.StringAttribute{
							Optional:            true,
							Description:         "Email address to receive alerts. Must be a valid email format.",
							MarkdownDescription: "Email address to receive alerts. Must be a valid email format.",
						},
						"risk_and_conformance_reports": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"start_date": schema.StringAttribute{
							Optional:            true,
							Description:         "Start date for email alerts in ISO 8601 format (YYYY-MM-DDThh:mm:ssZ). Defines when the email alerts should begin.",
							MarkdownDescription: "Start date for email alerts in ISO 8601 format (YYYY-MM-DDThh:mm:ssZ). Defines when the email alerts should begin.",
						},
					},
					CustomType: EmailType{
						ObjectType: types.ObjectType{
							AttrTypes: EmailValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "List of email settings for external streaming. Used to configure email alerts and notifications from the fabric.",
				MarkdownDescription: "List of email settings for external streaming. Used to configure email alerts and notifications from the fabric.",
			},
			"export_format": schema.StringAttribute{
				Optional:            true,
				Description:         "NAS export format. Specifies the format for exported flow collection data. Currently supports 'json' format.",
				MarkdownDescription: "NAS export format. Specifies the format for exported flow collection data. Currently supports 'json' format.",
			},
			"export_type": schema.StringAttribute{
				Optional:            true,
				Description:         "NAS export type. Can be 'full' for complete export or 'base' for basic export of flow collection data.",
				MarkdownDescription: "NAS export type. Can be 'full' for complete export or 'base' for basic export of flow collection data.",
			},
			"extra_config_aaa": schema.StringAttribute{
				Optional:            true,
				Description:         "AAA Configurations",
				MarkdownDescription: "AAA Configurations",
			},
			"extra_config_intra_fabric_links": schema.StringAttribute{
				Optional:            true,
				Description:         "Additional CLIs for all Intra-Fabric links",
				MarkdownDescription: "Additional CLIs for all Intra-Fabric links",
			},
			"extra_config_leaf": schema.StringAttribute{
				Optional:            true,
				Description:         "Additional CLIs as captured from the show running configuration, added after interface configurations for all switches with a VTEP unless they have some spine role",
				MarkdownDescription: "Additional CLIs as captured from the show running configuration, added after interface configurations for all switches with a VTEP unless they have some spine role",
			},
			"extra_config_nxos_bootstrap": schema.StringAttribute{
				Optional:            true,
				Description:         "Additional CLIs required during device bootup/login e.g. AAA/Radius",
				MarkdownDescription: "Additional CLIs required during device bootup/login e.g. AAA/Radius",
			},
			"extra_config_spine": schema.StringAttribute{
				Optional:            true,
				Description:         "Additional CLIs as captured from the show running configuration, added after interface configurations for all switches with some spine role",
				MarkdownDescription: "Additional CLIs as captured from the show running configuration, added after interface configurations for all switches with some spine role",
			},
			"extra_config_tor": schema.StringAttribute{
				Optional:            true,
				Description:         "Additional CLIs as captured from the show running configuration, added after interface configurations for all ToRs",
				MarkdownDescription: "Additional CLIs as captured from the show running configuration, added after interface configurations for all ToRs",
			},
			"fabric_interface_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Numbered(Point-to-Point) or unNumbered",
				MarkdownDescription: "Numbered(Point-to-Point) or unNumbered",
				Default:             stringdefault.StaticString("p2p"),
			},
			"fabric_mtu": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Intra Fabric Interface MTU. Must be an even number",
				MarkdownDescription: "Intra Fabric Interface MTU. Must be an even number",
				Default:             int64default.StaticInt64(9216),
			},
			"fabric_name": schema.StringAttribute{
				Required:            true,
				Description:         "The name of the fabric_vxlan_evpn resource",
				MarkdownDescription: "The name of the fabric_vxlan_evpn resource",
			},
			"fabric_type": schema.StringAttribute{
				Optional:            true,
				Description:         "Type of Interface Group",
				MarkdownDescription: "Type of Interface Group",
			},
			"fabric_vpc_domain_id": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable the same vPC Domain Id for all vPC Pairs.  Not Recommended.",
				MarkdownDescription: "Enable the same vPC Domain Id for all vPC Pairs.  Not Recommended.",
				Default:             booldefault.StaticBool(false),
			},
			"fabric_vpc_qos": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Qos on spines for guaranteed delivery of vPC Fabric Peering communication",
				MarkdownDescription: "Qos on spines for guaranteed delivery of vPC Fabric Peering communication",
				Default:             booldefault.StaticBool(false),
			},
			"fabric_vpc_qos_policy_name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Qos Policy name should be same on all spines",
				MarkdownDescription: "Qos Policy name should be same on all spines",
				Default:             stringdefault.StaticString("spine_qos_for_fabric_vpc_peering"),
			},
			"flow_telemetry": schema.BoolAttribute{
				Optional:            true,
				Description:         "Enable Flow Telemetry",
				MarkdownDescription: "Enable Flow Telemetry",
			},
			"greenfield_debug_flag": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Allow switch configuration to be cleared without a reload when preserveConfig is set to false",
				MarkdownDescription: "Allow switch configuration to be cleared without a reload when preserveConfig is set to false",
				Default:             stringdefault.StaticString("disable"),
			},
			"host_interface_admin_state": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Unshut Host Interfaces by Default",
				MarkdownDescription: "Unshut Host Interfaces by Default",
				Default:             booldefault.StaticBool(true),
			},
			"ibgp_peer_template": schema.StringAttribute{
				Optional:            true,
				Description:         "Specifies the iBGP Peer-Template config used for Route Reflectors and spines with border or border gateway role. This field should begin with '  template peer' or '  template peer-session'. This must have 2 leading spaces. Note ! All configs should strictly match show run output, with respect to case and newlines. Any mismatches will yield unexpected diffs during deploy.",
				MarkdownDescription: "Specifies the iBGP Peer-Template config used for Route Reflectors and spines with border or border gateway role. This field should begin with '  template peer' or '  template peer-session'. This must have 2 leading spaces. Note ! All configs should strictly match show run output, with respect to case and newlines. Any mismatches will yield unexpected diffs during deploy.",
			},
			"inband_dhcp_servers": schema.StringAttribute{
				Optional:            true,
				Description:         "External DHCP Server IP Addresses. Comma separated list of ipv4 Addresses (Max 3)",
				MarkdownDescription: "External DHCP Server IP Addresses. Comma separated list of ipv4 Addresses (Max 3)",
			},
			"inband_management": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Manage switches with only Inband connectivity",
				MarkdownDescription: "Manage switches with only Inband connectivity",
				Default:             booldefault.StaticBool(false),
			},
			"interface_flow_rules": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"interface_flow_rule_attributes": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"interface_flow_rule_attribute_id": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_flow_rule_bidirectional": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "",
										MarkdownDescription: "",
										Default:             booldefault.StaticBool(false),
									},
									"interface_flow_rule_dst_ip": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_flow_rule_dst_port": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_flow_rule_protocol": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_flow_rule_src_ip": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_flow_rule_src_port": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
								},
								CustomType: InterfaceFlowRuleAttributesType{
									ObjectType: types.ObjectType{
										AttrTypes: InterfaceFlowRuleAttributesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"interface_flow_rule_interface_collection": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"interface_flow_rule_interfaces": schema.SetAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_flow_rule_switch_id": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_flow_rule_switch_name": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
								},
								CustomType: InterfaceFlowRuleInterfaceCollectionType{
									ObjectType: types.ObjectType{
										AttrTypes: InterfaceFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"interface_flow_rule_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"interface_flow_rule_subnets": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"interface_flow_rule_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             stringdefault.StaticString("physical"),
						},
						"interface_flow_rule_uuid": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
					},
					CustomType: InterfaceFlowRulesType{
						ObjectType: types.ObjectType{
							AttrTypes: InterfaceFlowRulesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Interface flow rules",
				MarkdownDescription: "Interface flow rules",
			},
			"interface_rules": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"interface_rule_enable_fabric_interconnect": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             booldefault.StaticBool(true),
						},
						"interface_rule_enable_l3_out": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             booldefault.StaticBool(true),
						},
						"interface_rule_enabled": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             booldefault.StaticBool(true),
						},
						"interface_rule_interface_collection": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"interface_rule_interfaces": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"interface_rule_interface_encap": schema.StringAttribute{
													Optional:            true,
													Description:         "",
													MarkdownDescription: "",
												},
												"interface_rule_interface_name": schema.StringAttribute{
													Optional:            true,
													Description:         "",
													MarkdownDescription: "",
												},
												"interface_rule_interface_type": schema.StringAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "",
													MarkdownDescription: "",
													Default:             stringdefault.StaticString("routed"),
												},
												"interface_rule_interface_vrf_name": schema.StringAttribute{
													Optional:            true,
													Description:         "",
													MarkdownDescription: "",
												},
											},
											CustomType: InterfaceRuleInterfacesType{
												ObjectType: types.ObjectType{
													AttrTypes: InterfaceRuleInterfacesValue{}.AttributeTypes(ctx),
												},
											},
										},
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_rule_l3_out": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_rule_switch_id": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_rule_switch_name": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_rule_tenant": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_rule_vrf_name": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
								},
								CustomType: InterfaceRuleInterfaceCollectionType{
									ObjectType: types.ObjectType{
										AttrTypes: InterfaceRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"interface_rule_name": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             stringdefault.StaticString("TAInterfaceRule1"),
						},
						"interface_rule_subnets": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"interface_rule_uuid": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
					},
					CustomType: InterfaceRulesType{
						ObjectType: types.ObjectType{
							AttrTypes: InterfaceRulesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Traffic Analytics interface rules",
				MarkdownDescription: "Traffic Analytics interface rules",
			},
			"interface_statistics_load_interval": schema.Int64Attribute{
				Optional:            true,
				Description:         "Interface Statistics Load Interval. Time in seconds",
				MarkdownDescription: "Interface Statistics Load Interval. Time in seconds",
			},
			"intra_fabric_subnet_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Address range to assign numbered and peer link SVI IPs",
				MarkdownDescription: "Address range to assign numbered and peer link SVI IPs",
			},
			"ip_service_level_agreement_id_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Service Level Agreement (SLA) ID Range (minimum: 1, maximum: 655214748364735). Per switch SLA ID Range",
				MarkdownDescription: "Service Level Agreement (SLA) ID Range (minimum: 1, maximum: 655214748364735). Per switch SLA ID Range",
				Default:             stringdefault.StaticString("10000-19999"),
			},
			"ipv6_anycast_rendezvous_point_ip_range": schema.StringAttribute{
				Computed:            true,
				Description:         "Anycast RP IPv6 Address Range",
				MarkdownDescription: "Anycast RP IPv6 Address Range",
			},
			"ipv6_link_local": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If not enabled, Spine-Leaf interfaces will use global IPv6 addresses",
				MarkdownDescription: "If not enabled, Spine-Leaf interfaces will use global IPv6 addresses",
				Default:             booldefault.StaticBool(true),
			},
			"ipv6_multicast_group_subnet": schema.StringAttribute{
				Optional:            true,
				Description:         "IPv6 Multicast address with prefix 112 to 128",
				MarkdownDescription: "IPv6 Multicast address with prefix 112 to 128",
			},
			"ipv6_subnet_range": schema.StringAttribute{
				Optional:            true,
				Description:         "Underlay Subnet ipv6 range to assign Numbered and Peer Link SVI IPs",
				MarkdownDescription: "Underlay Subnet ipv6 range to assign Numbered and Peer Link SVI IPs",
			},
			"ipv6_subnet_target_mask": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Mask for Underlay Subnet IPv6 Range",
				MarkdownDescription: "Mask for Underlay Subnet IPv6 Range",
				Default:             int64default.StaticInt64(126),
			},
			"isis_area_number": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "NET in form of XX.<4-hex-digit Custom Area Number>.XXXX.XXXX.XXXX.00, default Area Number is 0001. If area number in existing NETs matches the previous area number set in fabric settings and is different from the current area number, these NETs will be updated by Recalculate and Deploy.",
				MarkdownDescription: "NET in form of XX.<4-hex-digit Custom Area Number>.XXXX.XXXX.XXXX.00, default Area Number is 0001. If area number in existing NETs matches the previous area number set in fabric settings and is different from the current area number, these NETs will be updated by Recalculate and Deploy.",
				Default:             stringdefault.StaticString("0001"),
			},
			"isis_authentication": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable IS-IS Authentication",
				MarkdownDescription: "Enable IS-IS Authentication",
				Default:             booldefault.StaticBool(false),
			},
			"isis_authentication_key": schema.StringAttribute{
				Optional:            true,
				Description:         "IS-IS Authentication Key.  Cisco Type 7 Encrypted",
				MarkdownDescription: "IS-IS Authentication Key.  Cisco Type 7 Encrypted",
			},
			"isis_authentication_keychain_key_id": schema.Int64Attribute{
				Optional:            true,
				Description:         "IS-IS Authentication Key ID",
				MarkdownDescription: "IS-IS Authentication Key ID",
			},
			"isis_authentication_keychain_name": schema.StringAttribute{
				Optional:            true,
				Description:         "IS-IS Authentication Keychain Name",
				MarkdownDescription: "IS-IS Authentication Keychain Name",
			},
			"isis_level": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "IS-IS Level",
				MarkdownDescription: "IS-IS Level",
				Default:             stringdefault.StaticString("level-2"),
			},
			"isis_overload": schema.BoolAttribute{
				Optional:            true,
				Description:         "Set IS-IS Overload Bit.  When enabled, set the overload bit for an elapsed time after a reload",
				MarkdownDescription: "Set IS-IS Overload Bit.  When enabled, set the overload bit for an elapsed time after a reload",
			},
			"isis_overload_elapse_time": schema.Int64Attribute{
				Optional:            true,
				Description:         "IS-IS Overload Bit Elapsed Time. Clear the overload bit after an elapsed time in seconds",
				MarkdownDescription: "IS-IS Overload Bit Elapsed Time. Clear the overload bit after an elapsed time in seconds",
			},
			"isis_point_to_point": schema.BoolAttribute{
				Optional:            true,
				Description:         "This will enable network point-to-point on fabric interfaces which are numbered",
				MarkdownDescription: "This will enable network point-to-point on fabric interfaces which are numbered",
			},
			"key_management_entity_server_ip": schema.StringAttribute{
				Optional:            true,
				Description:         "Key Management Entity server ipv4 address",
				MarkdownDescription: "Key Management Entity server ipv4 address",
			},
			"key_management_entity_server_port": schema.Int64Attribute{
				Optional:            true,
				Description:         "Key Management Entity server port number",
				MarkdownDescription: "Key Management Entity server port number",
			},
			"l2_host_interface_mtu": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Layer 2 host interface MTU. Must be an even number",
				MarkdownDescription: "Layer 2 host interface MTU. Must be an even number",
				Default:             int64default.StaticInt64(9216),
			},
			"l2_vni_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Overlay Network Identifier Range (minimum: 1, maximum: 16777214)",
				MarkdownDescription: "Overlay Network Identifier Range (minimum: 1, maximum: 16777214)",
				Default:             stringdefault.StaticString("30000-49000"),
			},
			"l3_out_flow_rules": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"l3_out_flow_rule_interface_collection": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"l3_out_flow_rule_encap": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"l3_out_flow_rule_interfaces": schema.SetAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"l3_out_flow_rule_l3_out": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"l3_out_flow_rule_switch_id": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"l3_out_flow_rule_switch_name": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"l3_out_flow_rule_tenant": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
								},
								CustomType: L3OutFlowRuleInterfaceCollectionType{
									ObjectType: types.ObjectType{
										AttrTypes: L3OutFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"l3_out_flow_rule_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"l3_out_flow_rule_subnets": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"l3_out_flow_rule_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             stringdefault.StaticString("subInterface"),
						},
						"l3_out_flow_rule_uuid": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
					},
					CustomType: L3OutFlowRulesType{
						ObjectType: types.ObjectType{
							AttrTypes: L3OutFlowRulesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "L3Out flow rules, applicable only for ACI fabrics",
				MarkdownDescription: "L3Out flow rules, applicable only for ACI fabrics",
			},
			"l3_vni_ipv6_multicast_group": schema.StringAttribute{
				Optional:            true,
				Description:         "Default Underlay Multicast group IP6 address assigned for every overlay VRF",
				MarkdownDescription: "Default Underlay Multicast group IP6 address assigned for every overlay VRF",
			},
			"l3_vni_no_vlan_default_option": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "L3 VNI configuration without VLAN configuration. This value is propagated on vrf creation as the default value of 'Enable L3VNI w/o VLAN' in vrf",
				MarkdownDescription: "L3 VNI configuration without VLAN configuration. This value is propagated on vrf creation as the default value of 'Enable L3VNI w/o VLAN' in vrf",
				Default:             booldefault.StaticBool(false),
			},
			"l3_vni_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Overlay VRF Identifier Range (minimum: 1, maximum: 16777214)",
				MarkdownDescription: "Overlay VRF Identifier Range (minimum: 1, maximum: 16777214)",
				Default:             stringdefault.StaticString("50000-59000"),
			},
			"l3vni_multicast_group": schema.StringAttribute{
				Optional:            true,
				Description:         "Default Underlay Multicast group IPv4 address assigned for every overlay VRF",
				MarkdownDescription: "Default Underlay Multicast group IPv4 address assigned for every overlay VRF",
			},
			"leaf_to_r_id_range": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Use specific vPC/Port-channel ID range for leaf-tor pairings",
				MarkdownDescription: "Use specific vPC/Port-channel ID range for leaf-tor pairings",
				Default:             booldefault.StaticBool(false),
			},
			"leaf_tor_vpc_port_channel_id_range": schema.StringAttribute{
				Optional:            true,
				Description:         "Specify vPC/Port-channel ID range (minimum: 1, maximum: 4096), this range is used for auto-allocating vPC/Port-Channel IDs for leaf-tor pairings",
				MarkdownDescription: "Specify vPC/Port-channel ID range (minimum: 1, maximum: 4096), this range is used for auto-allocating vPC/Port-Channel IDs for leaf-tor pairings",
			},
			"leafibgp_peer_template": schema.StringAttribute{
				Optional:            true,
				Description:         "Specifies the config used for leaf, border or border gateway.  If this field is empty, the peer template defined in iBGP Peer-Template Config is used on all BGP enabled devices (RRs, leafs, border or border gateway roles).  This field should begin with '  template peer' or '  template peer-session'. This must have 2 leading spaces. Note ! All configs should strictly match 'show run' output, with respect to case and newlines. Any mismatches will yield unexpected diffs during deploy.",
				MarkdownDescription: "Specifies the config used for leaf, border or border gateway.  If this field is empty, the peer template defined in iBGP Peer-Template Config is used on all BGP enabled devices (RRs, leafs, border or border gateway roles).  This field should begin with '  template peer' or '  template peer-session'. This must have 2 leading spaces. Note ! All configs should strictly match 'show run' output, with respect to case and newlines. Any mismatches will yield unexpected diffs during deploy.",
			},
			"license_tier": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The license tier of the fabric_vxlan_evpn resource",
				MarkdownDescription: "The license tier of the fabric_vxlan_evpn resource",
			},
			"link_state_routing_protocol": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Underlay Routing Protocol.  Used for Spine-Leaf Connectivity",
				MarkdownDescription: "Underlay Routing Protocol.  Used for Spine-Leaf Connectivity",
				Default:             stringdefault.StaticString("ospf"),
			},
			"link_state_routing_tag": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Underlay routing protocol process tag",
				MarkdownDescription: "Underlay routing protocol process tag",
				Default:             stringdefault.StaticString("UNDERLAY"),
			},
			"local_dhcp_server": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Automatic IP Assignment For POAP From Local DHCP Server",
				MarkdownDescription: "Automatic IP Assignment For POAP From Local DHCP Server",
				Default:             booldefault.StaticBool(false),
			},
			"location": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"latitude": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "",
						MarkdownDescription: "",
					},
					"longitude": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "",
						MarkdownDescription: "",
					},
				},
				CustomType: LocationType{
					ObjectType: types.ObjectType{
						AttrTypes: LocationValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Location to access the resource",
				MarkdownDescription: "Location to access the resource",
			},
			"macsec": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable MACsec in the fabric. MACsec fabric parameters are used for configuring MACsec on a fabric link if MACsec is enabled on the link.",
				MarkdownDescription: "Enable MACsec in the fabric. MACsec fabric parameters are used for configuring MACsec on a fabric link if MACsec is enabled on the link.",
			},
			"macsec_algorithm": schema.StringAttribute{
				Optional:            true,
				Description:         "MACsec Primary Cryptographic Algorithm.  AES_128_CMAC or AES_256_CMAC",
				MarkdownDescription: "MACsec Primary Cryptographic Algorithm.  AES_128_CMAC or AES_256_CMAC",
			},
			"macsec_cipher_suite": schema.StringAttribute{
				Optional:            true,
				Description:         "Configure Cipher Suite",
				MarkdownDescription: "Configure Cipher Suite",
			},
			"macsec_fallback_algorithm": schema.StringAttribute{
				Optional:            true,
				Description:         "MACsec Fallback Cryptographic Algorithm.  AES_128_CMAC or AES_256_CMAC",
				MarkdownDescription: "MACsec Fallback Cryptographic Algorithm.  AES_128_CMAC or AES_256_CMAC",
			},
			"macsec_fallback_key_string": schema.StringAttribute{
				Optional:            true,
				Description:         "MACsec Fallback Key String. Cisco Type 7 Encrypted Octet String",
				MarkdownDescription: "MACsec Fallback Key String. Cisco Type 7 Encrypted Octet String",
			},
			"macsec_key_string": schema.StringAttribute{
				Optional:            true,
				Description:         "MACsec Primary Key String.  Cisco Type 7 Encrypted Octet String",
				MarkdownDescription: "MACsec Primary Key String.  Cisco Type 7 Encrypted Octet String",
			},
			"macsec_report_timer": schema.Int64Attribute{
				Optional:            true,
				Description:         "MACsec Operational Status periodic report timer in minutes",
				MarkdownDescription: "MACsec Operational Status periodic report timer in minutes",
			},
			"management_gateway": schema.StringAttribute{
				Optional:            true,
				Description:         "Default Gateway For Management VRF On The Switch",
				MarkdownDescription: "Default Gateway For Management VRF On The Switch",
			},
			"management_ipv4_prefix": schema.Int64Attribute{
				Optional:            true,
				Description:         "Switch Mgmt IP Subnet Prefix if ipv4",
				MarkdownDescription: "Switch Mgmt IP Subnet Prefix if ipv4",
			},
			"management_ipv6_prefix": schema.Int64Attribute{
				Optional:            true,
				Description:         "Switch Management IP Subnet Prefix if ipv6",
				MarkdownDescription: "Switch Management IP Subnet Prefix if ipv6",
			},
			"message_bus": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"advisories": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"anomalies": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"audit_logs": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"collection_settings_collection_type": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"collection_type": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"faults": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"server": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"statistics": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
					},
					CustomType: MessageBusType{
						ObjectType: types.ObjectType{
							AttrTypes: MessageBusValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "List of message bus settings",
				MarkdownDescription: "List of message bus settings",
			},
			"microburst": schema.BoolAttribute{
				Optional:            true,
				Description:         "Enable microburst detection. When enabled, the system will detect microbursts in network traffic.",
				MarkdownDescription: "Enable microburst detection. When enabled, the system will detect microbursts in network traffic.",
			},
			"mpls_handoff": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable MPLS Handoff",
				MarkdownDescription: "Enable MPLS Handoff",
				Default:             booldefault.StaticBool(false),
			},
			"mpls_isis_area_number": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "NET in form of XX.<4-hex-digit Custom Area Number>.XXXX.XXXX.XXXX.00, default Area Number is 0001, used only if routing protocol on DCI MPLS link is is-is",
				MarkdownDescription: "NET in form of XX.<4-hex-digit Custom Area Number>.XXXX.XXXX.XXXX.00, default Area Number is 0001, used only if routing protocol on DCI MPLS link is is-is",
				Default:             stringdefault.StaticString("0001"),
			},
			"mpls_loopback_identifier": schema.Int64Attribute{
				Optional:            true,
				Description:         "Used for VXLAN to MPLS SR/LDP Handoff",
				MarkdownDescription: "Used for VXLAN to MPLS SR/LDP Handoff",
			},
			"mpls_loopback_ip_range": schema.StringAttribute{
				Optional:            true,
				Description:         "Used for VXLAN to MPLS SR/LDP Handoff",
				MarkdownDescription: "Used for VXLAN to MPLS SR/LDP Handoff",
			},
			"mst_instance_range": schema.StringAttribute{
				Optional:            true,
				Description:         "Minimum Spanning Tree instance range (minimum: 0, maximum: 4094)",
				MarkdownDescription: "Minimum Spanning Tree instance range (minimum: 0, maximum: 4094)",
			},
			"multicast_group_subnet": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Multicast pool prefix between 8 to 30. A multicast group ipv4 from this pool is used for BUM traffic for each overlay network.",
				MarkdownDescription: "Multicast pool prefix between 8 to 30. A multicast group ipv4 from this pool is used for BUM traffic for each overlay network.",
			},
			"mvpn_vrf_route_import_id": schema.BoolAttribute{
				Optional:            true,
				Description:         "Enable MVPN VRI ID Generation For Tenant Routed Multicast With IPv4 Underlay",
				MarkdownDescription: "Enable MVPN VRI ID Generation For Tenant Routed Multicast With IPv4 Underlay",
			},
			"mvpn_vrf_route_import_id_range": schema.StringAttribute{
				Optional:            true,
				Description:         "MVPN VRI ID (minimum: 1, maximum: 65535) for vPC, applicable when TRM enabled with IPv6 underlay, or mvpnVrfRouteImportId enabled with IPv4 underlay",
				MarkdownDescription: "MVPN VRI ID (minimum: 1, maximum: 65535) for vPC, applicable when TRM enabled with IPv6 underlay, or mvpnVrfRouteImportId enabled with IPv4 underlay",
			},
			"net_flow": schema.BoolAttribute{
				Optional:            true,
				Description:         "Enable NetFlow",
				MarkdownDescription: "Enable NetFlow",
			},
			"netflow": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable netflow on the interface",
				MarkdownDescription: "Enable netflow on the interface",
				Default:             booldefault.StaticBool(false),
			},
			"netflow_exporter_collection": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"exporter_ip": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"exporter_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"source_interface_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"udp_port": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             int64default.StaticInt64(1),
						},
						"vrf": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
					},
					CustomType: NetflowExporterCollectionType{
						ObjectType: types.ObjectType{
							AttrTypes: NetflowExporterCollectionValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "One or Multiple Netflow Exporters",
				MarkdownDescription: "One or Multiple Netflow Exporters",
			},
			"netflow_monitor_collection": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"exporter1_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"exporter2_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"monitor_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"monitor_record_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
					},
					CustomType: NetflowMonitorCollectionType{
						ObjectType: types.ObjectType{
							AttrTypes: NetflowMonitorCollectionValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "One or Multiple Netflow Monitors",
				MarkdownDescription: "One or Multiple Netflow Monitors",
			},
			"netflow_record_collection": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"layer2_record": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             booldefault.StaticBool(false),
						},
						"record_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"record_template": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             stringdefault.StaticString("netflowIpv4Record"),
						},
					},
					CustomType: NetflowRecordCollectionType{
						ObjectType: types.ObjectType{
							AttrTypes: NetflowRecordCollectionValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "One or Multiple Netflow Records",
				MarkdownDescription: "One or Multiple Netflow Records",
			},
			"netflow_sampler_collection": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"num_samples": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             int64default.StaticInt64(1),
						},
						"sampler_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"sampling_rate": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             int64default.StaticInt64(1),
						},
					},
					CustomType: NetflowSamplerCollectionType{
						ObjectType: types.ObjectType{
							AttrTypes: NetflowSamplerCollectionValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "One or multiple netflow samplers. Applicable to N7K only",
				MarkdownDescription: "One or multiple netflow samplers. Applicable to N7K only",
			},
			"network_extension_template": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Default Overlay Network Template For Borders",
				MarkdownDescription: "Default Overlay Network Template For Borders",
				Default:             stringdefault.StaticString("Default_Network_Extension_Universal"),
			},
			"network_template": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Default Overlay Network Template For Leafs",
				MarkdownDescription: "Default Overlay Network Template For Leafs",
				Default:             stringdefault.StaticString("Default_Network_Universal"),
			},
			"network_vlan_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Per Switch Overlay Network VLAN Range (minimum: 2, maximum: 4094)",
				MarkdownDescription: "Per Switch Overlay Network VLAN Range (minimum: 2, maximum: 4094)",
				Default:             stringdefault.StaticString("2300-2999"),
			},
			"next_generation_oam": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable the Next Generation (NG) OAM feature for all switches in the fabric to aid in trouble-shooting VXLAN EVPN fabrics",
				MarkdownDescription: "Enable the Next Generation (NG) OAM feature for all switches in the fabric to aid in trouble-shooting VXLAN EVPN fabrics",
				Default:             booldefault.StaticBool(true),
			},
			"ngoam_south_bound_loop_detect": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable the Next Generation (NG) OAM southbound loop detection",
				MarkdownDescription: "Enable the Next Generation (NG) OAM southbound loop detection",
				Default:             booldefault.StaticBool(false),
			},
			"ngoam_south_bound_loop_detect_probe_interval": schema.Int64Attribute{
				Optional:            true,
				Description:         "Set Next Generation (NG) OAM southbound loop detection probe interval in seconds.",
				MarkdownDescription: "Set Next Generation (NG) OAM southbound loop detection probe interval in seconds.",
			},
			"ngoam_south_bound_loop_detect_recovery_interval": schema.Int64Attribute{
				Optional:            true,
				Description:         "Set the Next Generation (NG) OAM southbound loop detection recovery interval in seconds",
				MarkdownDescription: "Set the Next Generation (NG) OAM southbound loop detection recovery interval in seconds",
			},
			"ntp_server_collection": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "List of NTP server IPv4/IPv6 addresses and/or hostnames",
				MarkdownDescription: "List of NTP server IPv4/IPv6 addresses and/or hostnames",
			},
			"ntp_server_vrf_collection": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "NTP Server VRFs. One VRF for all NTP servers or a list of VRFs, one per NTP server",
				MarkdownDescription: "NTP Server VRFs. One VRF for all NTP servers or a list of VRFs, one per NTP server",
			},
			"nve_hold_down_timer": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "NVE Source Inteface HoldDown Time in seconds",
				MarkdownDescription: "NVE Source Inteface HoldDown Time in seconds",
				Default:             int64default.StaticInt64(180),
			},
			"nve_loopback_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Underlay VTEP loopback Id associated with the Network Virtualization Edge (nve) interface",
				MarkdownDescription: "Underlay VTEP loopback Id associated with the Network Virtualization Edge (nve) interface",
				Default:             int64default.StaticInt64(1),
			},
			"nve_loopback_ip_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Typically Loopback1 IP Address Range",
				MarkdownDescription: "Typically Loopback1 IP Address Range",
				Default:             stringdefault.StaticString("10.3.0.0/22"),
			},
			"nve_loopback_ipv6_range": schema.StringAttribute{
				Optional:            true,
				Description:         "Typically Loopback1 and Anycast Loopback IPv6 Address Range",
				MarkdownDescription: "Typically Loopback1 and Anycast Loopback IPv6 Address Range",
			},
			"nxapi": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable NX-API over HTTPS",
				MarkdownDescription: "Enable NX-API over HTTPS",
				Default:             booldefault.StaticBool(false),
			},
			"nxapi_http": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable NX-API over HTTP",
				MarkdownDescription: "Enable NX-API over HTTP",
				Default:             booldefault.StaticBool(true),
			},
			"nxapi_http_port": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "HTTP port for NX-API",
				MarkdownDescription: "HTTP port for NX-API",
				Default:             int64default.StaticInt64(80),
			},
			"nxapi_https_port": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "HTTPS port for NX-API",
				MarkdownDescription: "HTTPS port for NX-API",
				Default:             int64default.StaticInt64(443),
			},
			"object_tracking_number_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Tracked Object ID Range (minimum: 1, maximum: 512) Per switch tracked object ID Range",
				MarkdownDescription: "Tracked Object ID Range (minimum: 1, maximum: 512) Per switch tracked object ID Range",
				Default:             stringdefault.StaticString("100-299"),
			},
			"operating_mode": schema.StringAttribute{
				Optional:            true,
				Description:         "Flow collection mode as set on the fabric's telemetry cluster",
				MarkdownDescription: "Flow collection mode as set on the fabric's telemetry cluster",
			},
			"orchestration_status": schema.StringAttribute{
				Optional:            true,
				Description:         "The orchestration status of the fabric_vxlan_evpn resource",
				MarkdownDescription: "The orchestration status of the fabric_vxlan_evpn resource",
			},
			"ospf_area_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "OSPF Area Id in IP address format",
				MarkdownDescription: "OSPF Area Id in IP address format",
				Default:             stringdefault.StaticString("0.0.0.0"),
			},
			"ospf_authentication": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable OSPF Authentication",
				MarkdownDescription: "Enable OSPF Authentication",
				Default:             booldefault.StaticBool(false),
			},
			"ospf_authentication_key": schema.StringAttribute{
				Optional:            true,
				Description:         "OSPF Authentication Key.  3DES Encrypted",
				MarkdownDescription: "OSPF Authentication Key.  3DES Encrypted",
			},
			"ospf_authentication_key_id": schema.Int64Attribute{
				Optional:            true,
				Description:         "(Min:0, Max:255)",
				MarkdownDescription: "(Min:0, Max:255)",
			},
			"overlay_mode": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Overlay Mode. VRF/Network configuration using config-profile or CLI",
				MarkdownDescription: "Overlay Mode. VRF/Network configuration using config-profile or CLI",
				Default:             stringdefault.StaticString("cli"),
			},
			"per_vrf_loopback_auto_provision": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Auto provision an IPv4 loopback on a VTEP on VRF attachment. Note: Enabling this option auto-provisions loopback on existing VRF attachments and also when Edit, QuickAttach, or Multiattach actions are performed. Provisioned loopbacks cannot be deleted until VRFs are unattached.",
				MarkdownDescription: "Auto provision an IPv4 loopback on a VTEP on VRF attachment. Note: Enabling this option auto-provisions loopback on existing VRF attachments and also when Edit, QuickAttach, or Multiattach actions are performed. Provisioned loopbacks cannot be deleted until VRFs are unattached.",
				Default:             booldefault.StaticBool(false),
			},
			"per_vrf_loopback_auto_provision_ipv6": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Auto provision an IPv6 loopback on a VTEP on VRF attachment.",
				MarkdownDescription: "Auto provision an IPv6 loopback on a VTEP on VRF attachment.",
				Default:             booldefault.StaticBool(false),
			},
			"per_vrf_loopback_ip_range": schema.StringAttribute{
				Optional:            true,
				Description:         "Prefix pool to assign IPv4 addresses to loopbacks on VTEPs on a per VRF basis",
				MarkdownDescription: "Prefix pool to assign IPv4 addresses to loopbacks on VTEPs on a per VRF basis",
			},
			"per_vrf_loopback_ipv6_range": schema.StringAttribute{
				Optional:            true,
				Description:         "Prefix pool to assign IPv6 addresses to loopbacks on VTEPs on a per VRF basis",
				MarkdownDescription: "Prefix pool to assign IPv6 addresses to loopbacks on VTEPs on a per VRF basis",
			},
			"performance_monitoring": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable performance monitoring for this fabric",
				MarkdownDescription: "Enable performance monitoring for this fabric",
				Default:             booldefault.StaticBool(false),
			},
			"phantom_rendezvous_point_loopback_id1": schema.Int64Attribute{
				Optional:            true,
				Description:         "Underlay phantom rendezvous point loopback primary Id for PIM Bi-dir deployments",
				MarkdownDescription: "Underlay phantom rendezvous point loopback primary Id for PIM Bi-dir deployments",
			},
			"phantom_rendezvous_point_loopback_id2": schema.Int64Attribute{
				Optional:            true,
				Description:         "Underlay phantom rendezvous point loopback secondary Id for PIM Bi-dir deployments",
				MarkdownDescription: "Underlay phantom rendezvous point loopback secondary Id for PIM Bi-dir deployments",
			},
			"phantom_rendezvous_point_loopback_id3": schema.Int64Attribute{
				Optional:            true,
				Description:         "Underlay phantom rendezvous point loopback tertiary Id for PIM Bi-dir deployments",
				MarkdownDescription: "Underlay phantom rendezvous point loopback tertiary Id for PIM Bi-dir deployments",
			},
			"phantom_rendezvous_point_loopback_id4": schema.Int64Attribute{
				Optional:            true,
				Description:         "Underlay phantom rendezvous point loopback quaternary Id for PIM Bi-dir deployments",
				MarkdownDescription: "Underlay phantom rendezvous point loopback quaternary Id for PIM Bi-dir deployments",
			},
			"pim_hello_authentication": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Valid for IPv4 Underlay only",
				MarkdownDescription: "Valid for IPv4 Underlay only",
				Default:             booldefault.StaticBool(false),
			},
			"pim_hello_authentication_key": schema.StringAttribute{
				Optional:            true,
				Description:         "3DES Encrypted",
				MarkdownDescription: "3DES Encrypted",
			},
			"policy_based_routing": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable feature pbr, sla sender, epbr, or enable feature pbr, based on the L4-L7 Services use case",
				MarkdownDescription: "Enable feature pbr, sla sender, epbr, or enable feature pbr, based on the L4-L7 Services use case",
				Default:             booldefault.StaticBool(false),
			},
			"power_redundancy_mode": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Default Power Supply Mode for NX-OS Switches",
				MarkdownDescription: "Default Power Supply Mode for NX-OS Switches",
				Default:             stringdefault.StaticString("redundant"),
			},
			"pre_interface_config_leaf": schema.StringAttribute{
				Optional:            true,
				Description:         "Additional CLIs as captured from the show running configuration, added before interface configurations for all switches with a VTEP unless they have some spine role",
				MarkdownDescription: "Additional CLIs as captured from the show running configuration, added before interface configurations for all switches with a VTEP unless they have some spine role",
			},
			"pre_interface_config_spine": schema.StringAttribute{
				Optional:            true,
				Description:         "Additional CLIs as captured from the show running configuration, added before interface configurations for all switches with some spine role",
				MarkdownDescription: "Additional CLIs as captured from the show running configuration, added before interface configurations for all switches with some spine role",
			},
			"pre_interface_config_tor": schema.StringAttribute{
				Optional:            true,
				Description:         "Additional CLIs as captured from the show running configuration, added before interface configurations for all ToRs",
				MarkdownDescription: "Additional CLIs as captured from the show running configuration, added before interface configurations for all ToRs",
			},
			"priority_flow_control_watch_interval": schema.Int64Attribute{
				Optional:            true,
				Description:         "Acceptable values from 101 to 1000 (milliseconds).  Leave blank for system default (100ms).",
				MarkdownDescription: "Acceptable values from 101 to 1000 (milliseconds).  Leave blank for system default (100ms).",
			},
			"private_vlan": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable PVLAN on switches except spines and super spines",
				MarkdownDescription: "Enable PVLAN on switches except spines and super spines",
				Default:             booldefault.StaticBool(false),
			},
			"ptp": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable Precision Time Protocol",
				MarkdownDescription: "Enable Precision Time Protocol",
				Default:             booldefault.StaticBool(false),
			},
			"ptp_domain_id": schema.Int64Attribute{
				Optional:            true,
				Description:         "Multiple Independent PTP Clocking Subdomains on a Single Network",
				MarkdownDescription: "Multiple Independent PTP Clocking Subdomains on a Single Network",
			},
			"ptp_loopback_id": schema.Int64Attribute{
				Optional:            true,
				Description:         "Precision Time Protocol Source Loopback Id",
				MarkdownDescription: "Precision Time Protocol Source Loopback Id",
			},
			"ptp_vlan_id": schema.Int64Attribute{
				Optional:            true,
				Description:         "Precision Time Protocol (PTP) Source VLAN ID.  SVI used for ptp source on ToRs",
				MarkdownDescription: "Precision Time Protocol (PTP) Source VLAN ID.  SVI used for ptp source on ToRs",
			},
			"quantum_key_distribution": schema.BoolAttribute{
				Optional:            true,
				Description:         "Enable Data Center Interconnect Media Access Control Security with Quantum Key Distribution config",
				MarkdownDescription: "Enable Data Center Interconnect Media Access Control Security with Quantum Key Distribution config",
			},
			"quantum_key_distribution_profile_name": schema.StringAttribute{
				Optional:            true,
				Description:         "Name of crypto profile (Max Size 63)",
				MarkdownDescription: "Name of crypto profile (Max Size 63)",
			},
			"real_time_backup": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Backup hourly only if there is any config deployment since last backup",
				MarkdownDescription: "Backup hourly only if there is any config deployment since last backup",
				Default:             booldefault.StaticBool(true),
			},
			"real_time_interface_statistics_collection": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable Real Time Interface Statistics Collection. Valid for NX-OS only",
				MarkdownDescription: "Enable Real Time Interface Statistics Collection. Valid for NX-OS only",
				Default:             booldefault.StaticBool(false),
			},
			"rendezvous_point_count": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Number of spines acting as Rendezvous-Points (RPs)",
				MarkdownDescription: "Number of spines acting as Rendezvous-Points (RPs)",
			},
			"rendezvous_point_loopback_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Rendezvous point loopback Id",
				MarkdownDescription: "Rendezvous point loopback Id",
				Default:             int64default.StaticInt64(254),
			},
			"rendezvous_point_mode": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Multicast rendezvous point Mode. For ipv6 underlay, please use asm only",
				MarkdownDescription: "Multicast rendezvous point Mode. For ipv6 underlay, please use asm only",
				Default:             stringdefault.StaticString("asm"),
			},
			"replication_mode": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Replication Mode for BUM Traffic",
				MarkdownDescription: "Replication Mode for BUM Traffic",
			},
			"route_map_sequence_number_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Route Map Sequence Number Range (minimum: 1, maximum: 65534)",
				MarkdownDescription: "Route Map Sequence Number Range (minimum: 1, maximum: 65534)",
				Default:             stringdefault.StaticString("1-65534"),
			},
			"route_reflector_count": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Number of spines acting as Route-Reflectors",
				MarkdownDescription: "Number of spines acting as Route-Reflectors",
				Default:             int64default.StaticInt64(2),
			},
			"router_id_range": schema.StringAttribute{
				Optional:            true,
				Description:         "BGP Router ID Range in IPv4 subnet format used for IPv6 Underlay.",
				MarkdownDescription: "BGP Router ID Range in IPv4 subnet format used for IPv6 Underlay.",
			},
			"s_flow": schema.BoolAttribute{
				Optional:            true,
				Description:         "Enable sFlow",
				MarkdownDescription: "Enable sFlow",
			},
			"scheduled_backup": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable to Backup at the specified time daily",
				MarkdownDescription: "Enable to Backup at the specified time daily",
				Default:             booldefault.StaticBool(false),
			},
			"scheduled_backup_time": schema.StringAttribute{
				Optional:            true,
				Description:         "Time (UTC) in 24hr format (00:00 to 23:59) to take daily Backup if enabled.",
				MarkdownDescription: "Time (UTC) in 24hr format (00:00 to 23:59) to take daily Backup if enabled.",
			},
			"security_domain": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Security Domain associated with the fabric",
				MarkdownDescription: "Security Domain associated with the fabric",
				Default:             stringdefault.StaticString("all"),
			},
			"security_group_status": schema.StringAttribute{
				Optional:            true,
				Description:         "Security group status",
				MarkdownDescription: "Security group status",
			},
			"security_group_tag": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Security group can be enabled only with cli overlay mode",
				MarkdownDescription: "Security group can be enabled only with cli overlay mode",
				Default:             booldefault.StaticBool(false),
			},
			"security_group_tag_id_range": schema.StringAttribute{
				Optional:            true,
				Description:         "Security Group Tag (SGT) ID Range (minimum: 16, maximum: 65535)",
				MarkdownDescription: "Security Group Tag (SGT) ID Range (minimum: 16, maximum: 65535)",
			},
			"security_group_tag_prefix": schema.StringAttribute{
				Optional:            true,
				Description:         "Prefix to be used when a new Security Group is created",
				MarkdownDescription: "Prefix to be used when a new Security Group is created",
			},
			"security_group_tag_preprovision": schema.BoolAttribute{
				Optional:            true,
				Description:         "Generate security groups configuration for non-enforced VRFs",
				MarkdownDescription: "Generate security groups configuration for non-enforced VRFs",
			},
			"seed_switch_core_interfaces": schema.StringAttribute{
				Optional:            true,
				Description:         "Seed Switch Fabric Interfaces. Core-facing Interface list on Seed Switch (e.g. e1/1-30,e1/32)",
				MarkdownDescription: "Seed Switch Fabric Interfaces. Core-facing Interface list on Seed Switch (e.g. e1/1-30,e1/32)",
			},
			"sensitivity": schema.StringAttribute{
				Optional:            true,
				Description:         "Microburst sensitivity level. Can be set to low, medium, or high to determine the threshold for detecting microbursts.",
				MarkdownDescription: "Microburst sensitivity level. Can be set to low, medium, or high to determine the threshold for detecting microbursts.",
			},
			"server": schema.StringAttribute{
				Optional:            true,
				Description:         "Name of the Network attached storage server configured for flow collection. This specifies the server where flow collection data will be exported.",
				MarkdownDescription: "Name of the Network attached storage server configured for flow collection. This specifies the server where flow collection data will be exported.",
			},
			"service_network_vlan_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Service Network VLAN Range (minimum: 2, maximum: 4094). Per Switch Overlay Service Network VLAN Range",
				MarkdownDescription: "Service Network VLAN Range (minimum: 2, maximum: 4094). Per Switch Overlay Service Network VLAN Range",
				Default:             stringdefault.StaticString("3000-3199"),
			},
			"shared_vpc_domain_id": schema.Int64Attribute{
				Optional:            true,
				Description:         "vPC Domain Id to be used on all vPC pairs",
				MarkdownDescription: "vPC Domain Id to be used on all vPC pairs",
			},
			"site_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "For EVPN Multi-Site Support. Defaults to Fabric ASN",
				MarkdownDescription: "For EVPN Multi-Site Support. Defaults to Fabric ASN",
			},
			"skip_certificate_verification": schema.BoolAttribute{
				Optional:            true,
				Description:         "Skip verification of incoming certificate",
				MarkdownDescription: "Skip verification of incoming certificate",
			},
			"snmp_trap": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Configure ND as a receiver for SNMP traps",
				MarkdownDescription: "Configure ND as a receiver for SNMP traps",
				Default:             booldefault.StaticBool(true),
			},
			"spine_switch_core_interfaces": schema.StringAttribute{
				Optional:            true,
				Description:         "Spine Switch Fabric Interfaces. Core-facing Interface list on all Spines (e.g. e1/1-30,e1/32)",
				MarkdownDescription: "Spine Switch Fabric Interfaces. Core-facing Interface list on all Spines (e.g. e1/1-30,e1/32)",
			},
			"static_underlay_ip_allocation": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Checking this will disable Dynamic Underlay IP Address Allocations",
				MarkdownDescription: "Checking this will disable Dynamic Underlay IP Address Allocations",
				Default:             booldefault.StaticBool(false),
			},
			"stp_bridge_priority": schema.Int64Attribute{
				Optional:            true,
				Description:         "Bridge priority for the spanning tree in increments of 4096",
				MarkdownDescription: "Bridge priority for the spanning tree in increments of 4096",
			},
			"stp_root_option": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Which protocol to use for configuring root bridge? rpvst+: Rapid Per-VLAN Spanning Tree, mst: Multiple Spanning Tree, unmanaged (default): STP Root not managed by ND",
				MarkdownDescription: "Which protocol to use for configuring root bridge? rpvst+: Rapid Per-VLAN Spanning Tree, mst: Multiple Spanning Tree, unmanaged (default): STP Root not managed by ND",
				Default:             stringdefault.StaticString("unmanaged"),
			},
			"stp_vlan_range": schema.StringAttribute{
				Optional:            true,
				Description:         "Spanning tree Vlan range (minimum: 0, maximum: 4094)",
				MarkdownDescription: "Spanning tree Vlan range (minimum: 0, maximum: 4094)",
			},
			"strict_config_compliance_mode": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable bi-directional compliance checks to flag additional configs in the running config that are not in the intent/expected config",
				MarkdownDescription: "Enable bi-directional compliance checks to flag additional configs in the running config that are not in the intent/expected config",
				Default:             booldefault.StaticBool(false),
			},
			"sub_interface_dot1q_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Per aggregation dot1q range (minimum: 2, maximum: 4093) for VRF-Lite connectivity",
				MarkdownDescription: "Per aggregation dot1q range (minimum: 2, maximum: 4093) for VRF-Lite connectivity",
				Default:             stringdefault.StaticString("2-511"),
			},
			"syslog_anomalies": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "vPC pair anomalies response",
				MarkdownDescription: "vPC pair anomalies response",
			},
			"syslog_facility": schema.StringAttribute{
				Optional:            true,
				Description:         "The facility value to be used in syslog messages. This helps categorize and filter syslog messages on the receiving server.",
				MarkdownDescription: "The facility value to be used in syslog messages. This helps categorize and filter syslog messages on the receiving server.",
			},
			"syslog_server_collection": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "List of Syslog server IPv4/IPv6 addresses and/or hostnames",
				MarkdownDescription: "List of Syslog server IPv4/IPv6 addresses and/or hostnames",
			},
			"syslog_server_vrf_collection": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "Syslog Server VRFs. One VRF for all Syslog servers or a list of VRFs, one per Syslog server",
				MarkdownDescription: "Syslog Server VRFs. One VRF for all Syslog servers or a list of VRFs, one per Syslog server",
			},
			"syslog_servers": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "List of Syslog servers to which alerts are sent. Each item should be the name or address of a Syslog server.",
				MarkdownDescription: "List of Syslog servers to which alerts are sent. Each item should be the name or address of a Syslog server.",
			},
			"syslog_severity_collection": schema.SetAttribute{
				ElementType:         types.Int64Type,
				Optional:            true,
				Description:         "List of Syslog severity values, one per Syslog server",
				MarkdownDescription: "List of Syslog severity values, one per Syslog server",
			},
			"target_subnet_mask": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Mask for underlay subnet IP range",
				MarkdownDescription: "Mask for underlay subnet IP range",
			},
			"tcam_allocation": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "TCAM commands are automatically generated for VxLAN and vPC Fabric Peering when Enabled",
				MarkdownDescription: "TCAM commands are automatically generated for VxLAN and vPC Fabric Peering when Enabled",
				Default:             booldefault.StaticBool(true),
			},
			"telemetry_collection": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable telemetry collection",
				MarkdownDescription: "Enable telemetry collection",
			},
			"telemetry_collection_type": schema.StringAttribute{
				Optional:            true,
				Description:         "Telemetry collection method.",
				MarkdownDescription: "Telemetry collection method.",
			},
			"telemetry_source_interface": schema.StringAttribute{
				Optional:            true,
				Description:         "Telemetry Source Interface (VLAN id or Loopback id) only valid if Telemetry Collection is set to inBand",
				MarkdownDescription: "Telemetry Source Interface (VLAN id or Loopback id) only valid if Telemetry Collection is set to inBand",
			},
			"telemetry_source_vrf": schema.StringAttribute{
				Optional:            true,
				Description:         "VRF over which telemetry is streamed, valid only if telemetry collection is set to inband",
				MarkdownDescription: "VRF over which telemetry is streamed, valid only if telemetry collection is set to inband",
			},
			"telemetry_status": schema.StringAttribute{
				Optional:            true,
				Description:         "The telemetry status of the fabric_vxlan_evpn resource",
				MarkdownDescription: "The telemetry status of the fabric_vxlan_evpn resource",
			},
			"telemetry_streaming_protocol": schema.StringAttribute{
				Optional:            true,
				Description:         "Telemetry Streaming Protocol.",
				MarkdownDescription: "Telemetry Streaming Protocol.",
			},
			"tenant_dhcp": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable Tenant DHCP",
				MarkdownDescription: "Enable Tenant DHCP",
				Default:             booldefault.StaticBool(true),
			},
			"tenant_routed_multicast": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "For Overlay ipv4 Multicast Support In VXLAN Fabrics",
				MarkdownDescription: "For Overlay ipv4 Multicast Support In VXLAN Fabrics",
				Default:             booldefault.StaticBool(false),
			},
			"tenant_routed_multicast_ipv6": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "For Overlay IPv6 Multicast Support In VXLAN Fabrics",
				MarkdownDescription: "For Overlay IPv6 Multicast Support In VXLAN Fabrics",
				Default:             booldefault.StaticBool(false),
			},
			"traffic_analytics": schema.StringAttribute{
				Optional:            true,
				Description:         "Configuration status of a feature in a fabric.",
				MarkdownDescription: "Configuration status of a feature in a fabric.",
			},
			"traffic_analytics_filter_rules": schema.StringAttribute{
				Optional:            true,
				Description:         "Indicates whether the fabric supports traffic analytics filter rules, which can be applied to restrict external traffic visibility on Nexus Dashboard. It is not applicable when the Nexus Dashboard cluster flow collection mode is set to Flow Telemetry.",
				MarkdownDescription: "Indicates whether the fabric supports traffic analytics filter rules, which can be applied to restrict external traffic visibility on Nexus Dashboard. It is not applicable when the Nexus Dashboard cluster flow collection mode is set to Flow Telemetry.",
			},
			"traffic_analytics_mode": schema.StringAttribute{
				Optional:            true,
				Description:         "Indicates whether the fabric supports full or compatibility mode for traffic analytics. It is not applicable when the Nexus Dashboard cluster flow collection mode is set to Flow Telemetry.",
				MarkdownDescription: "Indicates whether the fabric supports full or compatibility mode for traffic analytics. It is not applicable when the Nexus Dashboard cluster flow collection mode is set to Flow Telemetry.",
			},
			"traffic_analytics_rules_enabled": schema.BoolAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"trap_forwarder_status": schema.StringAttribute{
				Optional:            true,
				Description:         "The trap forwarder status of the fabric_vxlan_evpn resource",
				MarkdownDescription: "The trap forwarder status of the fabric_vxlan_evpn resource",
			},
			"trustpoint_label": schema.StringAttribute{
				Optional:            true,
				Description:         "Tls authentication type trustpoint label",
				MarkdownDescription: "Tls authentication type trustpoint label",
			},
			"udp_categorization": schema.StringAttribute{
				Optional:            true,
				Description:         "Configuration status of Traffic Analytics UDP Categorization in a fabric.",
				MarkdownDescription: "Configuration status of Traffic Analytics UDP Categorization in a fabric.",
			},
			"udp_categorization_support": schema.StringAttribute{
				Optional:            true,
				Description:         "Configuration status of Traffic Analytics UDP Categorization in a fabric.",
				MarkdownDescription: "Configuration status of Traffic Analytics UDP Categorization in a fabric.",
			},
			"un_numbered_bootstrap_lb_id": schema.Int64Attribute{
				Optional:            true,
				Description:         "Bootstrap Seed Switch Loopback Interface ID",
				MarkdownDescription: "Bootstrap Seed Switch Loopback Interface ID",
			},
			"un_numbered_dhcp_end_address": schema.StringAttribute{
				Optional:            true,
				Description:         "Switch Loopback DHCP Scope End Address. Must be a subset of IGP/BGP Loopback Prefix Pool",
				MarkdownDescription: "Switch Loopback DHCP Scope End Address. Must be a subset of IGP/BGP Loopback Prefix Pool",
			},
			"un_numbered_dhcp_start_address": schema.StringAttribute{
				Optional:            true,
				Description:         "Switch Loopback DHCP Scope Start Address.  Must be a subset of IGP/BGP Loopback Prefix Pool",
				MarkdownDescription: "Switch Loopback DHCP Scope Start Address.  Must be a subset of IGP/BGP Loopback Prefix Pool",
			},
			"underlay_ipv6": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If not enabled, IPv4 underlay is used",
				MarkdownDescription: "If not enabled, IPv4 underlay is used",
				Default:             booldefault.StaticBool(false),
			},
			"vpc_auto_recovery_timer": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "vPC auto recovery timer (in seconds)",
				MarkdownDescription: "vPC auto recovery timer (in seconds)",
				Default:             int64default.StaticInt64(360),
			},
			"vpc_delay_restore_timer": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "vPC delay restore timer (in seconds)",
				MarkdownDescription: "vPC delay restore timer (in seconds)",
				Default:             int64default.StaticInt64(150),
			},
			"vpc_domain_id_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "vPC Domain id range (minimum: 1, maximum: 1000) to use for new pairings",
				MarkdownDescription: "vPC Domain id range (minimum: 1, maximum: 1000) to use for new pairings",
				Default:             stringdefault.StaticString("1-1000"),
			},
			"vpc_ipv6_neighbor_discovery_sync": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable IPv6 ND synchronization between vPC peers",
				MarkdownDescription: "Enable IPv6 ND synchronization between vPC peers",
				Default:             booldefault.StaticBool(true),
			},
			"vpc_layer3_peer_router": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable Layer-3 Peer-Router on all Leaf switches",
				MarkdownDescription: "Enable Layer-3 Peer-Router on all Leaf switches",
				Default:             booldefault.StaticBool(true),
			},
			"vpc_peer_keep_alive_option": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Use vPC Peer Keep Alive with Loopback or Management",
				MarkdownDescription: "Use vPC Peer Keep Alive with Loopback or Management",
				Default:             stringdefault.StaticString("management"),
			},
			"vpc_peer_link_enable_native_vlan": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable VpcPeer Link for Native Vlan",
				MarkdownDescription: "Enable VpcPeer Link for Native Vlan",
				Default:             booldefault.StaticBool(false),
			},
			"vpc_peer_link_port_channel_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "vPC Peer Link Port Channel ID (minimum: 1, maximum: 4096)",
				MarkdownDescription: "vPC Peer Link Port Channel ID (minimum: 1, maximum: 4096)",
				Default:             stringdefault.StaticString("500"),
			},
			"vpc_peer_link_vlan": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "VLAN range (minimum: 2, maximum: 4094) for vPC Peer Link SVI",
				MarkdownDescription: "VLAN range (minimum: 2, maximum: 4094) for vPC Peer Link SVI",
				Default:             stringdefault.StaticString("3600"),
			},
			"vpc_tor_delay_restore_timer": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "vPC delay restore timer for ToR switches (in seconds)",
				MarkdownDescription: "vPC delay restore timer for ToR switches (in seconds)",
				Default:             int64default.StaticInt64(30),
			},
			"vrf_extension_template": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Default Overlay VRF Template For Borders",
				MarkdownDescription: "Default Overlay VRF Template For Borders",
				Default:             stringdefault.StaticString("Default_VRF_Extension_Universal"),
			},
			"vrf_flow_rules": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"vrf_flow_rule_attributes": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"vrf_flow_rule_attribute_id": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"vrf_flow_rule_bidirectional": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "",
										MarkdownDescription: "",
										Default:             booldefault.StaticBool(false),
									},
									"vrf_flow_rule_dst_ip": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"vrf_flow_rule_dst_port": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"vrf_flow_rule_protocol": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"vrf_flow_rule_src_ip": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"vrf_flow_rule_src_port": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
								},
								CustomType: VrfFlowRuleAttributesType{
									ObjectType: types.ObjectType{
										AttrTypes: VrfFlowRuleAttributesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"vrf_flow_rule_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"vrf_flow_rule_subnets": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"vrf_flow_rule_tenant": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"vrf_flow_rule_uuid": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"vrf_flow_rule_vrf": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
					},
					CustomType: VrfFlowRulesType{
						ObjectType: types.ObjectType{
							AttrTypes: VrfFlowRulesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "VRF flow rules",
				MarkdownDescription: "VRF flow rules",
			},
			"vrf_lite_auto_config": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "VRF Lite Inter-Fabric Connection Deployment Options. If 'back2Back&ToExternal' is selected, VRF Lite IFCs are auto created between border devices of two Easy Fabrics, and between border devices in Easy Fabric and edge routers in External Fabric. The IP address is taken from the 'VRF Lite Subnet IP Range' pool.",
				MarkdownDescription: "VRF Lite Inter-Fabric Connection Deployment Options. If 'back2Back&ToExternal' is selected, VRF Lite IFCs are auto created between border devices of two Easy Fabrics, and between border devices in Easy Fabric and edge routers in External Fabric. The IP address is taken from the 'VRF Lite Subnet IP Range' pool.",
				Default:             stringdefault.StaticString("manual"),
			},
			"vrf_lite_macsec": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable MACsec on DCI links. DCI MACsec fabric parameters are used for configuring MACsec on a DCI link if 'Use Link MACsec Setting' is disabled on the link.",
				MarkdownDescription: "Enable MACsec on DCI links. DCI MACsec fabric parameters are used for configuring MACsec on a DCI link if 'Use Link MACsec Setting' is disabled on the link.",
				Default:             booldefault.StaticBool(false),
			},
			"vrf_lite_macsec_algorithm": schema.StringAttribute{
				Optional:            true,
				Description:         "DCI MACsec Primary Cryptographic Algorithm",
				MarkdownDescription: "DCI MACsec Primary Cryptographic Algorithm",
			},
			"vrf_lite_macsec_cipher_suite": schema.StringAttribute{
				Optional:            true,
				Description:         "DCI MACsec Cipher Suite",
				MarkdownDescription: "DCI MACsec Cipher Suite",
			},
			"vrf_lite_macsec_fallback_algorithm": schema.StringAttribute{
				Optional:            true,
				Description:         "AES_128_CMAC or AES_256_CMAC. This parameter is used when DCI link has QKD disabled.",
				MarkdownDescription: "AES_128_CMAC or AES_256_CMAC. This parameter is used when DCI link has QKD disabled.",
			},
			"vrf_lite_macsec_fallback_key_string": schema.StringAttribute{
				Optional:            true,
				Description:         "DCI MACsec Fallback Key String.  Cisco Type 7 Encrypted Octet String. This parameter is used when DCI link has QKD disabled.",
				MarkdownDescription: "DCI MACsec Fallback Key String.  Cisco Type 7 Encrypted Octet String. This parameter is used when DCI link has QKD disabled.",
			},
			"vrf_lite_macsec_key_string": schema.StringAttribute{
				Optional:            true,
				Description:         "DCI MACsec Primary Key String.  Cisco Type 7 Encrypted Octet String",
				MarkdownDescription: "DCI MACsec Primary Key String.  Cisco Type 7 Encrypted Octet String",
			},
			"vrf_lite_subnet_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Address range to assign P2P Interfabric Connections",
				MarkdownDescription: "Address range to assign P2P Interfabric Connections",
				Default:             stringdefault.StaticString("10.33.0.0/16"),
			},
			"vrf_lite_subnet_target_mask": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "VRF Lite Subnet Mask",
				MarkdownDescription: "VRF Lite Subnet Mask",
				Default:             int64default.StaticInt64(30),
			},
			"vrf_route_import_id_reallocation": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "One time VRI ID re-allocation based on 'MVPN VRI ID Range'",
				MarkdownDescription: "One time VRI ID re-allocation based on 'MVPN VRI ID Range'",
				Default:             booldefault.StaticBool(false),
			},
			"vrf_template": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Default Overlay VRF Template For Leafs",
				MarkdownDescription: "Default Overlay VRF Template For Leafs",
				Default:             stringdefault.StaticString("Default_VRF_Universal"),
			},
			"vrf_vlan_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Per Switch Overlay VRF VLAN Range (minimum: 2, maximum: 4094)",
				MarkdownDescription: "Per Switch Overlay VRF VLAN Range (minimum: 2, maximum: 4094)",
				Default:             stringdefault.StaticString("2000-2299"),
			},
		},
	}
}

type FabricVxlanModel struct {
	Aaa                                        types.Bool    `tfsdk:"aaa"`
	AdvancedSshOption                          types.Bool    `tfsdk:"advanced_ssh_option"`
	AdvertisePhysicalIp                        types.Bool    `tfsdk:"advertise_physical_ip"`
	AdvertisePhysicalIpOnBorder                types.Bool    `tfsdk:"advertise_physical_ip_on_border"`
	AimlQos                                    types.Bool    `tfsdk:"aiml_qos"`
	AimlQosPolicy                              types.String  `tfsdk:"aiml_qos_policy"`
	AlertSuspend                               types.String  `tfsdk:"alert_suspend"`
	AllowVlanOnLeafTorPairing                  types.String  `tfsdk:"allow_vlan_on_leaf_tor_pairing"`
	AllowedActions                             types.Set     `tfsdk:"allowed_actions"`
	AnalysisSettingsIsEnabled                  types.Bool    `tfsdk:"analysis_settings_is_enabled"`
	AnycastBorderGatewayAdvertisePhysicalIp    types.Bool    `tfsdk:"anycast_border_gateway_advertise_physical_ip"`
	AnycastGatewayMac                          types.String  `tfsdk:"anycast_gateway_mac"`
	AnycastLoopbackId                          types.Int64   `tfsdk:"anycast_loopback_id"`
	AnycastRendezvousPointIpRange              types.String  `tfsdk:"anycast_rendezvous_point_ip_range"`
	AutoBgpNeighborDescription                 types.Bool    `tfsdk:"auto_bgp_neighbor_description"`
	AutoSymmetricDefaultVrf                    types.Bool    `tfsdk:"auto_symmetric_default_vrf"`
	AutoSymmetricVrfLite                       types.Bool    `tfsdk:"auto_symmetric_vrf_lite"`
	AutoUniqueVrfLiteIpPrefix                  types.Bool    `tfsdk:"auto_unique_vrf_lite_ip_prefix"`
	AutoVrfLiteDefaultVrf                      types.Bool    `tfsdk:"auto_vrf_lite_default_vrf"`
	Banner                                     types.String  `tfsdk:"banner"`
	Bfd                                        types.Bool    `tfsdk:"bfd"`
	BfdAuthentication                          types.Bool    `tfsdk:"bfd_authentication"`
	BfdAuthenticationKey                       types.String  `tfsdk:"bfd_authentication_key"`
	BfdAuthenticationKeyId                     types.Int64   `tfsdk:"bfd_authentication_key_id"`
	BfdIbgp                                    types.Bool    `tfsdk:"bfd_ibgp"`
	BfdIsis                                    types.Bool    `tfsdk:"bfd_isis"`
	BfdOspf                                    types.Bool    `tfsdk:"bfd_ospf"`
	BfdPim                                     types.Bool    `tfsdk:"bfd_pim"`
	BgpAsn                                     types.String  `tfsdk:"bgp_asn"`
	BgpAuthentication                          types.Bool    `tfsdk:"bgp_authentication"`
	BgpAuthenticationKey                       types.String  `tfsdk:"bgp_authentication_key"`
	BgpAuthenticationKeyType                   types.String  `tfsdk:"bgp_authentication_key_type"`
	BgpLoopbackId                              types.Int64   `tfsdk:"bgp_loopback_id"`
	BgpLoopbackIpRange                         types.String  `tfsdk:"bgp_loopback_ip_range"`
	BgpLoopbackIpv6Range                       types.String  `tfsdk:"bgp_loopback_ipv6_range"`
	BootstrapMultiSubnet                       types.String  `tfsdk:"bootstrap_multi_subnet"`
	BrownfieldNetworkNameFormat                types.String  `tfsdk:"brownfield_network_name_format"`
	BrownfieldSkipOverlayNetworkAttachments    types.Bool    `tfsdk:"brownfield_skip_overlay_network_attachments"`
	Category                                   types.String  `tfsdk:"category"`
	Cdp                                        types.Bool    `tfsdk:"cdp"`
	ControllerStatus                           types.String  `tfsdk:"controller_status"`
	CoppPolicy                                 types.String  `tfsdk:"copp_policy"`
	Cost                                       types.Float64 `tfsdk:"cost"`
	Day0Bootstrap                              types.Bool    `tfsdk:"day0_bootstrap"`
	DefaultPrivateVlanSecondaryNetworkTemplate types.String  `tfsdk:"default_private_vlan_secondary_network_template"`
	DefaultQueuingPolicy                       types.Bool    `tfsdk:"default_queuing_policy"`
	DefaultQueuingPolicyCloudscale             types.String  `tfsdk:"default_queuing_policy_cloudscale"`
	DefaultQueuingPolicyOther                  types.String  `tfsdk:"default_queuing_policy_other"`
	DefaultQueuingPolicyRSeries                types.String  `tfsdk:"default_queuing_policy_r_series"`
	DefaultVrfRedistributionBgpRouteMap        types.String  `tfsdk:"default_vrf_redistribution_bgp_route_map"`
	DhcpEndAddress                             types.String  `tfsdk:"dhcp_end_address"`
	DhcpProtocolVersion                        types.String  `tfsdk:"dhcp_protocol_version"`
	DhcpStartAddress                           types.String  `tfsdk:"dhcp_start_address"`
	DnsCollection                              types.Set     `tfsdk:"dns_collection"`
	DnsVrfCollection                           types.Set     `tfsdk:"dns_vrf_collection"`
	Email                                      types.List    `tfsdk:"email"`
	ExportFormat                               types.String  `tfsdk:"export_format"`
	ExportType                                 types.String  `tfsdk:"export_type"`
	ExtraConfigAaa                             types.String  `tfsdk:"extra_config_aaa"`
	ExtraConfigIntraFabricLinks                types.String  `tfsdk:"extra_config_intra_fabric_links"`
	ExtraConfigLeaf                            types.String  `tfsdk:"extra_config_leaf"`
	ExtraConfigNxosBootstrap                   types.String  `tfsdk:"extra_config_nxos_bootstrap"`
	ExtraConfigSpine                           types.String  `tfsdk:"extra_config_spine"`
	ExtraConfigTor                             types.String  `tfsdk:"extra_config_tor"`
	FabricInterfaceType                        types.String  `tfsdk:"fabric_interface_type"`
	FabricMtu                                  types.Int64   `tfsdk:"fabric_mtu"`
	FabricName                                 types.String  `tfsdk:"fabric_name"`
	FabricType                                 types.String  `tfsdk:"fabric_type"`
	FabricVpcDomainId                          types.Bool    `tfsdk:"fabric_vpc_domain_id"`
	FabricVpcQos                               types.Bool    `tfsdk:"fabric_vpc_qos"`
	FabricVpcQosPolicyName                     types.String  `tfsdk:"fabric_vpc_qos_policy_name"`
	FlowTelemetry                              types.Bool    `tfsdk:"flow_telemetry"`
	GreenfieldDebugFlag                        types.String  `tfsdk:"greenfield_debug_flag"`
	HostInterfaceAdminState                    types.Bool    `tfsdk:"host_interface_admin_state"`
	IbgpPeerTemplate                           types.String  `tfsdk:"ibgp_peer_template"`
	InbandDhcpServers                          types.String  `tfsdk:"inband_dhcp_servers"`
	InbandManagement                           types.Bool    `tfsdk:"inband_management"`
	InterfaceFlowRules                         types.List    `tfsdk:"interface_flow_rules"`
	InterfaceRules                             types.List    `tfsdk:"interface_rules"`
	InterfaceStatisticsLoadInterval            types.Int64   `tfsdk:"interface_statistics_load_interval"`
	IntraFabricSubnetRange                     types.String  `tfsdk:"intra_fabric_subnet_range"`
	IpServiceLevelAgreementIdRange             types.String  `tfsdk:"ip_service_level_agreement_id_range"`
	Ipv6AnycastRendezvousPointIpRange          types.String  `tfsdk:"ipv6_anycast_rendezvous_point_ip_range"`
	Ipv6LinkLocal                              types.Bool    `tfsdk:"ipv6_link_local"`
	Ipv6MulticastGroupSubnet                   types.String  `tfsdk:"ipv6_multicast_group_subnet"`
	Ipv6SubnetRange                            types.String  `tfsdk:"ipv6_subnet_range"`
	Ipv6SubnetTargetMask                       types.Int64   `tfsdk:"ipv6_subnet_target_mask"`
	IsisAreaNumber                             types.String  `tfsdk:"isis_area_number"`
	IsisAuthentication                         types.Bool    `tfsdk:"isis_authentication"`
	IsisAuthenticationKey                      types.String  `tfsdk:"isis_authentication_key"`
	IsisAuthenticationKeychainKeyId            types.Int64   `tfsdk:"isis_authentication_keychain_key_id"`
	IsisAuthenticationKeychainName             types.String  `tfsdk:"isis_authentication_keychain_name"`
	IsisLevel                                  types.String  `tfsdk:"isis_level"`
	IsisOverload                               types.Bool    `tfsdk:"isis_overload"`
	IsisOverloadElapseTime                     types.Int64   `tfsdk:"isis_overload_elapse_time"`
	IsisPointToPoint                           types.Bool    `tfsdk:"isis_point_to_point"`
	KeyManagementEntityServerIp                types.String  `tfsdk:"key_management_entity_server_ip"`
	KeyManagementEntityServerPort              types.Int64   `tfsdk:"key_management_entity_server_port"`
	L2HostInterfaceMtu                         types.Int64   `tfsdk:"l2_host_interface_mtu"`
	L2VniRange                                 types.String  `tfsdk:"l2_vni_range"`
	L3OutFlowRules                             types.List    `tfsdk:"l3_out_flow_rules"`
	L3VniIpv6MulticastGroup                    types.String  `tfsdk:"l3_vni_ipv6_multicast_group"`
	L3VniNoVlanDefaultOption                   types.Bool    `tfsdk:"l3_vni_no_vlan_default_option"`
	L3VniRange                                 types.String  `tfsdk:"l3_vni_range"`
	L3vniMulticastGroup                        types.String  `tfsdk:"l3vni_multicast_group"`
	LeafToRIdRange                             types.Bool    `tfsdk:"leaf_to_r_id_range"`
	LeafTorVpcPortChannelIdRange               types.String  `tfsdk:"leaf_tor_vpc_port_channel_id_range"`
	LeafibgpPeerTemplate                       types.String  `tfsdk:"leafibgp_peer_template"`
	LicenseTier                                types.String  `tfsdk:"license_tier"`
	LinkStateRoutingProtocol                   types.String  `tfsdk:"link_state_routing_protocol"`
	LinkStateRoutingTag                        types.String  `tfsdk:"link_state_routing_tag"`
	LocalDhcpServer                            types.Bool    `tfsdk:"local_dhcp_server"`
	Location                                   LocationValue `tfsdk:"location"`
	Macsec                                     types.Bool    `tfsdk:"macsec"`
	MacsecAlgorithm                            types.String  `tfsdk:"macsec_algorithm"`
	MacsecCipherSuite                          types.String  `tfsdk:"macsec_cipher_suite"`
	MacsecFallbackAlgorithm                    types.String  `tfsdk:"macsec_fallback_algorithm"`
	MacsecFallbackKeyString                    types.String  `tfsdk:"macsec_fallback_key_string"`
	MacsecKeyString                            types.String  `tfsdk:"macsec_key_string"`
	MacsecReportTimer                          types.Int64   `tfsdk:"macsec_report_timer"`
	ManagementGateway                          types.String  `tfsdk:"management_gateway"`
	ManagementIpv4Prefix                       types.Int64   `tfsdk:"management_ipv4_prefix"`
	ManagementIpv6Prefix                       types.Int64   `tfsdk:"management_ipv6_prefix"`
	MessageBus                                 types.List    `tfsdk:"message_bus"`
	Microburst                                 types.Bool    `tfsdk:"microburst"`
	MplsHandoff                                types.Bool    `tfsdk:"mpls_handoff"`
	MplsIsisAreaNumber                         types.String  `tfsdk:"mpls_isis_area_number"`
	MplsLoopbackIdentifier                     types.Int64   `tfsdk:"mpls_loopback_identifier"`
	MplsLoopbackIpRange                        types.String  `tfsdk:"mpls_loopback_ip_range"`
	MstInstanceRange                           types.String  `tfsdk:"mst_instance_range"`
	MulticastGroupSubnet                       types.String  `tfsdk:"multicast_group_subnet"`
	MvpnVrfRouteImportId                       types.Bool    `tfsdk:"mvpn_vrf_route_import_id"`
	MvpnVrfRouteImportIdRange                  types.String  `tfsdk:"mvpn_vrf_route_import_id_range"`
	NetFlow                                    types.Bool    `tfsdk:"net_flow"`
	Netflow                                    types.Bool    `tfsdk:"netflow"`
	NetflowExporterCollection                  types.List    `tfsdk:"netflow_exporter_collection"`
	NetflowMonitorCollection                   types.List    `tfsdk:"netflow_monitor_collection"`
	NetflowRecordCollection                    types.List    `tfsdk:"netflow_record_collection"`
	NetflowSamplerCollection                   types.List    `tfsdk:"netflow_sampler_collection"`
	NetworkExtensionTemplate                   types.String  `tfsdk:"network_extension_template"`
	NetworkTemplate                            types.String  `tfsdk:"network_template"`
	NetworkVlanRange                           types.String  `tfsdk:"network_vlan_range"`
	NextGenerationOam                          types.Bool    `tfsdk:"next_generation_oam"`
	NgoamSouthBoundLoopDetect                  types.Bool    `tfsdk:"ngoam_south_bound_loop_detect"`
	NgoamSouthBoundLoopDetectProbeInterval     types.Int64   `tfsdk:"ngoam_south_bound_loop_detect_probe_interval"`
	NgoamSouthBoundLoopDetectRecoveryInterval  types.Int64   `tfsdk:"ngoam_south_bound_loop_detect_recovery_interval"`
	NtpServerCollection                        types.Set     `tfsdk:"ntp_server_collection"`
	NtpServerVrfCollection                     types.Set     `tfsdk:"ntp_server_vrf_collection"`
	NveHoldDownTimer                           types.Int64   `tfsdk:"nve_hold_down_timer"`
	NveLoopbackId                              types.Int64   `tfsdk:"nve_loopback_id"`
	NveLoopbackIpRange                         types.String  `tfsdk:"nve_loopback_ip_range"`
	NveLoopbackIpv6Range                       types.String  `tfsdk:"nve_loopback_ipv6_range"`
	Nxapi                                      types.Bool    `tfsdk:"nxapi"`
	NxapiHttp                                  types.Bool    `tfsdk:"nxapi_http"`
	NxapiHttpPort                              types.Int64   `tfsdk:"nxapi_http_port"`
	NxapiHttpsPort                             types.Int64   `tfsdk:"nxapi_https_port"`
	ObjectTrackingNumberRange                  types.String  `tfsdk:"object_tracking_number_range"`
	OperatingMode                              types.String  `tfsdk:"operating_mode"`
	OrchestrationStatus                        types.String  `tfsdk:"orchestration_status"`
	OspfAreaId                                 types.String  `tfsdk:"ospf_area_id"`
	OspfAuthentication                         types.Bool    `tfsdk:"ospf_authentication"`
	OspfAuthenticationKey                      types.String  `tfsdk:"ospf_authentication_key"`
	OspfAuthenticationKeyId                    types.Int64   `tfsdk:"ospf_authentication_key_id"`
	OverlayMode                                types.String  `tfsdk:"overlay_mode"`
	PerVrfLoopbackAutoProvision                types.Bool    `tfsdk:"per_vrf_loopback_auto_provision"`
	PerVrfLoopbackAutoProvisionIpv6            types.Bool    `tfsdk:"per_vrf_loopback_auto_provision_ipv6"`
	PerVrfLoopbackIpRange                      types.String  `tfsdk:"per_vrf_loopback_ip_range"`
	PerVrfLoopbackIpv6Range                    types.String  `tfsdk:"per_vrf_loopback_ipv6_range"`
	PerformanceMonitoring                      types.Bool    `tfsdk:"performance_monitoring"`
	PhantomRendezvousPointLoopbackId1          types.Int64   `tfsdk:"phantom_rendezvous_point_loopback_id1"`
	PhantomRendezvousPointLoopbackId2          types.Int64   `tfsdk:"phantom_rendezvous_point_loopback_id2"`
	PhantomRendezvousPointLoopbackId3          types.Int64   `tfsdk:"phantom_rendezvous_point_loopback_id3"`
	PhantomRendezvousPointLoopbackId4          types.Int64   `tfsdk:"phantom_rendezvous_point_loopback_id4"`
	PimHelloAuthentication                     types.Bool    `tfsdk:"pim_hello_authentication"`
	PimHelloAuthenticationKey                  types.String  `tfsdk:"pim_hello_authentication_key"`
	PolicyBasedRouting                         types.Bool    `tfsdk:"policy_based_routing"`
	PowerRedundancyMode                        types.String  `tfsdk:"power_redundancy_mode"`
	PreInterfaceConfigLeaf                     types.String  `tfsdk:"pre_interface_config_leaf"`
	PreInterfaceConfigSpine                    types.String  `tfsdk:"pre_interface_config_spine"`
	PreInterfaceConfigTor                      types.String  `tfsdk:"pre_interface_config_tor"`
	PriorityFlowControlWatchInterval           types.Int64   `tfsdk:"priority_flow_control_watch_interval"`
	PrivateVlan                                types.Bool    `tfsdk:"private_vlan"`
	Ptp                                        types.Bool    `tfsdk:"ptp"`
	PtpDomainId                                types.Int64   `tfsdk:"ptp_domain_id"`
	PtpLoopbackId                              types.Int64   `tfsdk:"ptp_loopback_id"`
	PtpVlanId                                  types.Int64   `tfsdk:"ptp_vlan_id"`
	QuantumKeyDistribution                     types.Bool    `tfsdk:"quantum_key_distribution"`
	QuantumKeyDistributionProfileName          types.String  `tfsdk:"quantum_key_distribution_profile_name"`
	RealTimeBackup                             types.Bool    `tfsdk:"real_time_backup"`
	RealTimeInterfaceStatisticsCollection      types.Bool    `tfsdk:"real_time_interface_statistics_collection"`
	RendezvousPointCount                       types.Int64   `tfsdk:"rendezvous_point_count"`
	RendezvousPointLoopbackId                  types.Int64   `tfsdk:"rendezvous_point_loopback_id"`
	RendezvousPointMode                        types.String  `tfsdk:"rendezvous_point_mode"`
	ReplicationMode                            types.String  `tfsdk:"replication_mode"`
	RouteMapSequenceNumberRange                types.String  `tfsdk:"route_map_sequence_number_range"`
	RouteReflectorCount                        types.Int64   `tfsdk:"route_reflector_count"`
	RouterIdRange                              types.String  `tfsdk:"router_id_range"`
	SFlow                                      types.Bool    `tfsdk:"s_flow"`
	ScheduledBackup                            types.Bool    `tfsdk:"scheduled_backup"`
	ScheduledBackupTime                        types.String  `tfsdk:"scheduled_backup_time"`
	SecurityDomain                             types.String  `tfsdk:"security_domain"`
	SecurityGroupStatus                        types.String  `tfsdk:"security_group_status"`
	SecurityGroupTag                           types.Bool    `tfsdk:"security_group_tag"`
	SecurityGroupTagIdRange                    types.String  `tfsdk:"security_group_tag_id_range"`
	SecurityGroupTagPrefix                     types.String  `tfsdk:"security_group_tag_prefix"`
	SecurityGroupTagPreprovision               types.Bool    `tfsdk:"security_group_tag_preprovision"`
	SeedSwitchCoreInterfaces                   types.String  `tfsdk:"seed_switch_core_interfaces"`
	Sensitivity                                types.String  `tfsdk:"sensitivity"`
	Server                                     types.String  `tfsdk:"server"`
	ServiceNetworkVlanRange                    types.String  `tfsdk:"service_network_vlan_range"`
	SharedVpcDomainId                          types.Int64   `tfsdk:"shared_vpc_domain_id"`
	SiteId                                     types.String  `tfsdk:"site_id"`
	SkipCertificateVerification                types.Bool    `tfsdk:"skip_certificate_verification"`
	SnmpTrap                                   types.Bool    `tfsdk:"snmp_trap"`
	SpineSwitchCoreInterfaces                  types.String  `tfsdk:"spine_switch_core_interfaces"`
	StaticUnderlayIpAllocation                 types.Bool    `tfsdk:"static_underlay_ip_allocation"`
	StpBridgePriority                          types.Int64   `tfsdk:"stp_bridge_priority"`
	StpRootOption                              types.String  `tfsdk:"stp_root_option"`
	StpVlanRange                               types.String  `tfsdk:"stp_vlan_range"`
	StrictConfigComplianceMode                 types.Bool    `tfsdk:"strict_config_compliance_mode"`
	SubInterfaceDot1qRange                     types.String  `tfsdk:"sub_interface_dot1q_range"`
	SyslogAnomalies                            types.Set     `tfsdk:"syslog_anomalies"`
	SyslogFacility                             types.String  `tfsdk:"syslog_facility"`
	SyslogServerCollection                     types.Set     `tfsdk:"syslog_server_collection"`
	SyslogServerVrfCollection                  types.Set     `tfsdk:"syslog_server_vrf_collection"`
	SyslogServers                              types.Set     `tfsdk:"syslog_servers"`
	SyslogSeverityCollection                   types.Set     `tfsdk:"syslog_severity_collection"`
	TargetSubnetMask                           types.Int64   `tfsdk:"target_subnet_mask"`
	TcamAllocation                             types.Bool    `tfsdk:"tcam_allocation"`
	TelemetryCollection                        types.Bool    `tfsdk:"telemetry_collection"`
	TelemetryCollectionType                    types.String  `tfsdk:"telemetry_collection_type"`
	TelemetrySourceInterface                   types.String  `tfsdk:"telemetry_source_interface"`
	TelemetrySourceVrf                         types.String  `tfsdk:"telemetry_source_vrf"`
	TelemetryStatus                            types.String  `tfsdk:"telemetry_status"`
	TelemetryStreamingProtocol                 types.String  `tfsdk:"telemetry_streaming_protocol"`
	TenantDhcp                                 types.Bool    `tfsdk:"tenant_dhcp"`
	TenantRoutedMulticast                      types.Bool    `tfsdk:"tenant_routed_multicast"`
	TenantRoutedMulticastIpv6                  types.Bool    `tfsdk:"tenant_routed_multicast_ipv6"`
	TrafficAnalytics                           types.String  `tfsdk:"traffic_analytics"`
	TrafficAnalyticsFilterRules                types.String  `tfsdk:"traffic_analytics_filter_rules"`
	TrafficAnalyticsMode                       types.String  `tfsdk:"traffic_analytics_mode"`
	TrafficAnalyticsRulesEnabled               types.Bool    `tfsdk:"traffic_analytics_rules_enabled"`
	TrapForwarderStatus                        types.String  `tfsdk:"trap_forwarder_status"`
	TrustpointLabel                            types.String  `tfsdk:"trustpoint_label"`
	UdpCategorization                          types.String  `tfsdk:"udp_categorization"`
	UdpCategorizationSupport                   types.String  `tfsdk:"udp_categorization_support"`
	UnNumberedBootstrapLbId                    types.Int64   `tfsdk:"un_numbered_bootstrap_lb_id"`
	UnNumberedDhcpEndAddress                   types.String  `tfsdk:"un_numbered_dhcp_end_address"`
	UnNumberedDhcpStartAddress                 types.String  `tfsdk:"un_numbered_dhcp_start_address"`
	UnderlayIpv6                               types.Bool    `tfsdk:"underlay_ipv6"`
	VpcAutoRecoveryTimer                       types.Int64   `tfsdk:"vpc_auto_recovery_timer"`
	VpcDelayRestoreTimer                       types.Int64   `tfsdk:"vpc_delay_restore_timer"`
	VpcDomainIdRange                           types.String  `tfsdk:"vpc_domain_id_range"`
	VpcIpv6NeighborDiscoverySync               types.Bool    `tfsdk:"vpc_ipv6_neighbor_discovery_sync"`
	VpcLayer3PeerRouter                        types.Bool    `tfsdk:"vpc_layer3_peer_router"`
	VpcPeerKeepAliveOption                     types.String  `tfsdk:"vpc_peer_keep_alive_option"`
	VpcPeerLinkEnableNativeVlan                types.Bool    `tfsdk:"vpc_peer_link_enable_native_vlan"`
	VpcPeerLinkPortChannelId                   types.String  `tfsdk:"vpc_peer_link_port_channel_id"`
	VpcPeerLinkVlan                            types.String  `tfsdk:"vpc_peer_link_vlan"`
	VpcTorDelayRestoreTimer                    types.Int64   `tfsdk:"vpc_tor_delay_restore_timer"`
	VrfExtensionTemplate                       types.String  `tfsdk:"vrf_extension_template"`
	VrfFlowRules                               types.List    `tfsdk:"vrf_flow_rules"`
	VrfLiteAutoConfig                          types.String  `tfsdk:"vrf_lite_auto_config"`
	VrfLiteMacsec                              types.Bool    `tfsdk:"vrf_lite_macsec"`
	VrfLiteMacsecAlgorithm                     types.String  `tfsdk:"vrf_lite_macsec_algorithm"`
	VrfLiteMacsecCipherSuite                   types.String  `tfsdk:"vrf_lite_macsec_cipher_suite"`
	VrfLiteMacsecFallbackAlgorithm             types.String  `tfsdk:"vrf_lite_macsec_fallback_algorithm"`
	VrfLiteMacsecFallbackKeyString             types.String  `tfsdk:"vrf_lite_macsec_fallback_key_string"`
	VrfLiteMacsecKeyString                     types.String  `tfsdk:"vrf_lite_macsec_key_string"`
	VrfLiteSubnetRange                         types.String  `tfsdk:"vrf_lite_subnet_range"`
	VrfLiteSubnetTargetMask                    types.Int64   `tfsdk:"vrf_lite_subnet_target_mask"`
	VrfRouteImportIdReallocation               types.Bool    `tfsdk:"vrf_route_import_id_reallocation"`
	VrfTemplate                                types.String  `tfsdk:"vrf_template"`
	VrfVlanRange                               types.String  `tfsdk:"vrf_vlan_range"`
}

var _ basetypes.ObjectTypable = EmailType{}

type EmailType struct {
	basetypes.ObjectType
}

func (t EmailType) Equal(o attr.Type) bool {
	other, ok := o.(EmailType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EmailType) String() string {
	return "EmailType"
}

func (t EmailType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advisoriesAttribute, ok := attributes["advisories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advisories is missing from object`)

		return nil, diags
	}

	advisoriesVal, ok := advisoriesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advisories expected to be basetypes.SetValue, was: %T`, advisoriesAttribute))
	}

	anomaliesAttribute, ok := attributes["anomalies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anomalies is missing from object`)

		return nil, diags
	}

	anomaliesVal, ok := anomaliesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anomalies expected to be basetypes.SetValue, was: %T`, anomaliesAttribute))
	}

	collectionFrequencyInDaysAttribute, ok := attributes["collection_frequency_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_frequency_in_days is missing from object`)

		return nil, diags
	}

	collectionFrequencyInDaysVal, ok := collectionFrequencyInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_frequency_in_days expected to be basetypes.Int64Value, was: %T`, collectionFrequencyInDaysAttribute))
	}

	collectionTypeAttribute, ok := attributes["collection_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_type is missing from object`)

		return nil, diags
	}

	collectionTypeVal, ok := collectionTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_type expected to be basetypes.StringValue, was: %T`, collectionTypeAttribute))
	}

	formatAttribute, ok := attributes["format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`format is missing from object`)

		return nil, diags
	}

	formatVal, ok := formatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`format expected to be basetypes.StringValue, was: %T`, formatAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	onlyIncludeActiveAlertsAttribute, ok := attributes["only_include_active_alerts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`only_include_active_alerts is missing from object`)

		return nil, diags
	}

	onlyIncludeActiveAlertsVal, ok := onlyIncludeActiveAlertsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`only_include_active_alerts expected to be basetypes.BoolValue, was: %T`, onlyIncludeActiveAlertsAttribute))
	}

	receiverEmailAttribute, ok := attributes["receiver_email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`receiver_email is missing from object`)

		return nil, diags
	}

	receiverEmailVal, ok := receiverEmailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`receiver_email expected to be basetypes.StringValue, was: %T`, receiverEmailAttribute))
	}

	riskAndConformanceReportsAttribute, ok := attributes["risk_and_conformance_reports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`risk_and_conformance_reports is missing from object`)

		return nil, diags
	}

	riskAndConformanceReportsVal, ok := riskAndConformanceReportsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`risk_and_conformance_reports expected to be basetypes.SetValue, was: %T`, riskAndConformanceReportsAttribute))
	}

	startDateAttribute, ok := attributes["start_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_date is missing from object`)

		return nil, diags
	}

	startDateVal, ok := startDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_date expected to be basetypes.StringValue, was: %T`, startDateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EmailValue{
		Advisories:                advisoriesVal,
		Anomalies:                 anomaliesVal,
		CollectionFrequencyInDays: collectionFrequencyInDaysVal,
		CollectionType:            collectionTypeVal,
		Format:                    formatVal,
		Name:                      nameVal,
		OnlyIncludeActiveAlerts:   onlyIncludeActiveAlertsVal,
		ReceiverEmail:             receiverEmailVal,
		RiskAndConformanceReports: riskAndConformanceReportsVal,
		StartDate:                 startDateVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewEmailValueNull() EmailValue {
	return EmailValue{
		state: attr.ValueStateNull,
	}
}

func NewEmailValueUnknown() EmailValue {
	return EmailValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEmailValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EmailValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EmailValue Attribute Value",
				"While creating a EmailValue value, a missing attribute value was detected. "+
					"A EmailValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EmailValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EmailValue Attribute Type",
				"While creating a EmailValue value, an invalid attribute value was detected. "+
					"A EmailValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EmailValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EmailValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EmailValue Attribute Value",
				"While creating a EmailValue value, an extra attribute value was detected. "+
					"A EmailValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EmailValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEmailValueUnknown(), diags
	}

	advisoriesAttribute, ok := attributes["advisories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advisories is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	advisoriesVal, ok := advisoriesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advisories expected to be basetypes.SetValue, was: %T`, advisoriesAttribute))
	}

	anomaliesAttribute, ok := attributes["anomalies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anomalies is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	anomaliesVal, ok := anomaliesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anomalies expected to be basetypes.SetValue, was: %T`, anomaliesAttribute))
	}

	collectionFrequencyInDaysAttribute, ok := attributes["collection_frequency_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_frequency_in_days is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	collectionFrequencyInDaysVal, ok := collectionFrequencyInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_frequency_in_days expected to be basetypes.Int64Value, was: %T`, collectionFrequencyInDaysAttribute))
	}

	collectionTypeAttribute, ok := attributes["collection_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_type is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	collectionTypeVal, ok := collectionTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_type expected to be basetypes.StringValue, was: %T`, collectionTypeAttribute))
	}

	formatAttribute, ok := attributes["format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`format is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	formatVal, ok := formatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`format expected to be basetypes.StringValue, was: %T`, formatAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	onlyIncludeActiveAlertsAttribute, ok := attributes["only_include_active_alerts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`only_include_active_alerts is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	onlyIncludeActiveAlertsVal, ok := onlyIncludeActiveAlertsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`only_include_active_alerts expected to be basetypes.BoolValue, was: %T`, onlyIncludeActiveAlertsAttribute))
	}

	receiverEmailAttribute, ok := attributes["receiver_email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`receiver_email is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	receiverEmailVal, ok := receiverEmailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`receiver_email expected to be basetypes.StringValue, was: %T`, receiverEmailAttribute))
	}

	riskAndConformanceReportsAttribute, ok := attributes["risk_and_conformance_reports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`risk_and_conformance_reports is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	riskAndConformanceReportsVal, ok := riskAndConformanceReportsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`risk_and_conformance_reports expected to be basetypes.SetValue, was: %T`, riskAndConformanceReportsAttribute))
	}

	startDateAttribute, ok := attributes["start_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_date is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	startDateVal, ok := startDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_date expected to be basetypes.StringValue, was: %T`, startDateAttribute))
	}

	if diags.HasError() {
		return NewEmailValueUnknown(), diags
	}

	return EmailValue{
		Advisories:                advisoriesVal,
		Anomalies:                 anomaliesVal,
		CollectionFrequencyInDays: collectionFrequencyInDaysVal,
		CollectionType:            collectionTypeVal,
		Format:                    formatVal,
		Name:                      nameVal,
		OnlyIncludeActiveAlerts:   onlyIncludeActiveAlertsVal,
		ReceiverEmail:             receiverEmailVal,
		RiskAndConformanceReports: riskAndConformanceReportsVal,
		StartDate:                 startDateVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewEmailValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EmailValue {
	object, diags := NewEmailValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEmailValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EmailType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEmailValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEmailValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEmailValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEmailValueMust(EmailValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EmailType) ValueType(ctx context.Context) attr.Value {
	return EmailValue{}
}

var _ basetypes.ObjectValuable = EmailValue{}

type EmailValue struct {
	Advisories                basetypes.SetValue    `tfsdk:"advisories"`
	Anomalies                 basetypes.SetValue    `tfsdk:"anomalies"`
	CollectionFrequencyInDays basetypes.Int64Value  `tfsdk:"collection_frequency_in_days"`
	CollectionType            basetypes.StringValue `tfsdk:"collection_type"`
	Format                    basetypes.StringValue `tfsdk:"format"`
	Name                      basetypes.StringValue `tfsdk:"name"`
	OnlyIncludeActiveAlerts   basetypes.BoolValue   `tfsdk:"only_include_active_alerts"`
	ReceiverEmail             basetypes.StringValue `tfsdk:"receiver_email"`
	RiskAndConformanceReports basetypes.SetValue    `tfsdk:"risk_and_conformance_reports"`
	StartDate                 basetypes.StringValue `tfsdk:"start_date"`
	state                     attr.ValueState
}

func (v EmailValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["advisories"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["anomalies"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["collection_frequency_in_days"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["collection_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["only_include_active_alerts"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["receiver_email"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["risk_and_conformance_reports"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["start_date"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Advisories.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advisories"] = val

		val, err = v.Anomalies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["anomalies"] = val

		val, err = v.CollectionFrequencyInDays.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection_frequency_in_days"] = val

		val, err = v.CollectionType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection_type"] = val

		val, err = v.Format.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["format"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OnlyIncludeActiveAlerts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["only_include_active_alerts"] = val

		val, err = v.ReceiverEmail.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["receiver_email"] = val

		val, err = v.RiskAndConformanceReports.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["risk_and_conformance_reports"] = val

		val, err = v.StartDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start_date"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EmailValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EmailValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EmailValue) String() string {
	return "EmailValue"
}

func (v EmailValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var advisoriesVal basetypes.SetValue
	switch {
	case v.Advisories.IsUnknown():
		advisoriesVal = types.SetUnknown(types.StringType)
	case v.Advisories.IsNull():
		advisoriesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		advisoriesVal, d = types.SetValue(types.StringType, v.Advisories.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advisories": basetypes.SetType{
				ElemType: types.StringType,
			},
			"anomalies": basetypes.SetType{
				ElemType: types.StringType,
			},
			"collection_frequency_in_days": basetypes.Int64Type{},
			"collection_type":              basetypes.StringType{},
			"format":                       basetypes.StringType{},
			"name":                         basetypes.StringType{},
			"only_include_active_alerts":   basetypes.BoolType{},
			"receiver_email":               basetypes.StringType{},
			"risk_and_conformance_reports": basetypes.SetType{
				ElemType: types.StringType,
			},
			"start_date": basetypes.StringType{},
		}), diags
	}

	var anomaliesVal basetypes.SetValue
	switch {
	case v.Anomalies.IsUnknown():
		anomaliesVal = types.SetUnknown(types.StringType)
	case v.Anomalies.IsNull():
		anomaliesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		anomaliesVal, d = types.SetValue(types.StringType, v.Anomalies.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advisories": basetypes.SetType{
				ElemType: types.StringType,
			},
			"anomalies": basetypes.SetType{
				ElemType: types.StringType,
			},
			"collection_frequency_in_days": basetypes.Int64Type{},
			"collection_type":              basetypes.StringType{},
			"format":                       basetypes.StringType{},
			"name":                         basetypes.StringType{},
			"only_include_active_alerts":   basetypes.BoolType{},
			"receiver_email":               basetypes.StringType{},
			"risk_and_conformance_reports": basetypes.SetType{
				ElemType: types.StringType,
			},
			"start_date": basetypes.StringType{},
		}), diags
	}

	var riskAndConformanceReportsVal basetypes.SetValue
	switch {
	case v.RiskAndConformanceReports.IsUnknown():
		riskAndConformanceReportsVal = types.SetUnknown(types.StringType)
	case v.RiskAndConformanceReports.IsNull():
		riskAndConformanceReportsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		riskAndConformanceReportsVal, d = types.SetValue(types.StringType, v.RiskAndConformanceReports.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advisories": basetypes.SetType{
				ElemType: types.StringType,
			},
			"anomalies": basetypes.SetType{
				ElemType: types.StringType,
			},
			"collection_frequency_in_days": basetypes.Int64Type{},
			"collection_type":              basetypes.StringType{},
			"format":                       basetypes.StringType{},
			"name":                         basetypes.StringType{},
			"only_include_active_alerts":   basetypes.BoolType{},
			"receiver_email":               basetypes.StringType{},
			"risk_and_conformance_reports": basetypes.SetType{
				ElemType: types.StringType,
			},
			"start_date": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"advisories": basetypes.SetType{
			ElemType: types.StringType,
		},
		"anomalies": basetypes.SetType{
			ElemType: types.StringType,
		},
		"collection_frequency_in_days": basetypes.Int64Type{},
		"collection_type":              basetypes.StringType{},
		"format":                       basetypes.StringType{},
		"name":                         basetypes.StringType{},
		"only_include_active_alerts":   basetypes.BoolType{},
		"receiver_email":               basetypes.StringType{},
		"risk_and_conformance_reports": basetypes.SetType{
			ElemType: types.StringType,
		},
		"start_date": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advisories":                   advisoriesVal,
			"anomalies":                    anomaliesVal,
			"collection_frequency_in_days": v.CollectionFrequencyInDays,
			"collection_type":              v.CollectionType,
			"format":                       v.Format,
			"name":                         v.Name,
			"only_include_active_alerts":   v.OnlyIncludeActiveAlerts,
			"receiver_email":               v.ReceiverEmail,
			"risk_and_conformance_reports": riskAndConformanceReportsVal,
			"start_date":                   v.StartDate,
		})

	return objVal, diags
}

func (v EmailValue) Equal(o attr.Value) bool {
	other, ok := o.(EmailValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Advisories.Equal(other.Advisories) {
		return false
	}

	if !v.Anomalies.Equal(other.Anomalies) {
		return false
	}

	if !v.CollectionFrequencyInDays.Equal(other.CollectionFrequencyInDays) {
		return false
	}

	if !v.CollectionType.Equal(other.CollectionType) {
		return false
	}

	if !v.Format.Equal(other.Format) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OnlyIncludeActiveAlerts.Equal(other.OnlyIncludeActiveAlerts) {
		return false
	}

	if !v.ReceiverEmail.Equal(other.ReceiverEmail) {
		return false
	}

	if !v.RiskAndConformanceReports.Equal(other.RiskAndConformanceReports) {
		return false
	}

	if !v.StartDate.Equal(other.StartDate) {
		return false
	}

	return true
}

func (v EmailValue) Type(ctx context.Context) attr.Type {
	return EmailType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EmailValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advisories": basetypes.SetType{
			ElemType: types.StringType,
		},
		"anomalies": basetypes.SetType{
			ElemType: types.StringType,
		},
		"collection_frequency_in_days": basetypes.Int64Type{},
		"collection_type":              basetypes.StringType{},
		"format":                       basetypes.StringType{},
		"name":                         basetypes.StringType{},
		"only_include_active_alerts":   basetypes.BoolType{},
		"receiver_email":               basetypes.StringType{},
		"risk_and_conformance_reports": basetypes.SetType{
			ElemType: types.StringType,
		},
		"start_date": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InterfaceFlowRulesType{}

type InterfaceFlowRulesType struct {
	basetypes.ObjectType
}

func (t InterfaceFlowRulesType) Equal(o attr.Type) bool {
	other, ok := o.(InterfaceFlowRulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InterfaceFlowRulesType) String() string {
	return "InterfaceFlowRulesType"
}

func (t InterfaceFlowRulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceFlowRuleAttributesAttribute, ok := attributes["interface_flow_rule_attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_attributes is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleAttributesVal, ok := interfaceFlowRuleAttributesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_attributes expected to be basetypes.ListValue, was: %T`, interfaceFlowRuleAttributesAttribute))
	}

	interfaceFlowRuleInterfaceCollectionAttribute, ok := attributes["interface_flow_rule_interface_collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_interface_collection is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleInterfaceCollectionVal, ok := interfaceFlowRuleInterfaceCollectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_interface_collection expected to be basetypes.ListValue, was: %T`, interfaceFlowRuleInterfaceCollectionAttribute))
	}

	interfaceFlowRuleNameAttribute, ok := attributes["interface_flow_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_name is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleNameVal, ok := interfaceFlowRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_name expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleNameAttribute))
	}

	interfaceFlowRuleSubnetsAttribute, ok := attributes["interface_flow_rule_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_subnets is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleSubnetsVal, ok := interfaceFlowRuleSubnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_subnets expected to be basetypes.SetValue, was: %T`, interfaceFlowRuleSubnetsAttribute))
	}

	interfaceFlowRuleTypeAttribute, ok := attributes["interface_flow_rule_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_type is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleTypeVal, ok := interfaceFlowRuleTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_type expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleTypeAttribute))
	}

	interfaceFlowRuleUuidAttribute, ok := attributes["interface_flow_rule_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_uuid is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleUuidVal, ok := interfaceFlowRuleUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_uuid expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleUuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InterfaceFlowRulesValue{
		InterfaceFlowRuleAttributes:          interfaceFlowRuleAttributesVal,
		InterfaceFlowRuleInterfaceCollection: interfaceFlowRuleInterfaceCollectionVal,
		InterfaceFlowRuleName:                interfaceFlowRuleNameVal,
		InterfaceFlowRuleSubnets:             interfaceFlowRuleSubnetsVal,
		InterfaceFlowRuleType:                interfaceFlowRuleTypeVal,
		InterfaceFlowRuleUuid:                interfaceFlowRuleUuidVal,
		state:                                attr.ValueStateKnown,
	}, diags
}

func NewInterfaceFlowRulesValueNull() InterfaceFlowRulesValue {
	return InterfaceFlowRulesValue{
		state: attr.ValueStateNull,
	}
}

func NewInterfaceFlowRulesValueUnknown() InterfaceFlowRulesValue {
	return InterfaceFlowRulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInterfaceFlowRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InterfaceFlowRulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InterfaceFlowRulesValue Attribute Value",
				"While creating a InterfaceFlowRulesValue value, a missing attribute value was detected. "+
					"A InterfaceFlowRulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceFlowRulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InterfaceFlowRulesValue Attribute Type",
				"While creating a InterfaceFlowRulesValue value, an invalid attribute value was detected. "+
					"A InterfaceFlowRulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceFlowRulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InterfaceFlowRulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InterfaceFlowRulesValue Attribute Value",
				"While creating a InterfaceFlowRulesValue value, an extra attribute value was detected. "+
					"A InterfaceFlowRulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InterfaceFlowRulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInterfaceFlowRulesValueUnknown(), diags
	}

	interfaceFlowRuleAttributesAttribute, ok := attributes["interface_flow_rule_attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_attributes is missing from object`)

		return NewInterfaceFlowRulesValueUnknown(), diags
	}

	interfaceFlowRuleAttributesVal, ok := interfaceFlowRuleAttributesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_attributes expected to be basetypes.ListValue, was: %T`, interfaceFlowRuleAttributesAttribute))
	}

	interfaceFlowRuleInterfaceCollectionAttribute, ok := attributes["interface_flow_rule_interface_collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_interface_collection is missing from object`)

		return NewInterfaceFlowRulesValueUnknown(), diags
	}

	interfaceFlowRuleInterfaceCollectionVal, ok := interfaceFlowRuleInterfaceCollectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_interface_collection expected to be basetypes.ListValue, was: %T`, interfaceFlowRuleInterfaceCollectionAttribute))
	}

	interfaceFlowRuleNameAttribute, ok := attributes["interface_flow_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_name is missing from object`)

		return NewInterfaceFlowRulesValueUnknown(), diags
	}

	interfaceFlowRuleNameVal, ok := interfaceFlowRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_name expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleNameAttribute))
	}

	interfaceFlowRuleSubnetsAttribute, ok := attributes["interface_flow_rule_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_subnets is missing from object`)

		return NewInterfaceFlowRulesValueUnknown(), diags
	}

	interfaceFlowRuleSubnetsVal, ok := interfaceFlowRuleSubnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_subnets expected to be basetypes.SetValue, was: %T`, interfaceFlowRuleSubnetsAttribute))
	}

	interfaceFlowRuleTypeAttribute, ok := attributes["interface_flow_rule_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_type is missing from object`)

		return NewInterfaceFlowRulesValueUnknown(), diags
	}

	interfaceFlowRuleTypeVal, ok := interfaceFlowRuleTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_type expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleTypeAttribute))
	}

	interfaceFlowRuleUuidAttribute, ok := attributes["interface_flow_rule_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_uuid is missing from object`)

		return NewInterfaceFlowRulesValueUnknown(), diags
	}

	interfaceFlowRuleUuidVal, ok := interfaceFlowRuleUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_uuid expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleUuidAttribute))
	}

	if diags.HasError() {
		return NewInterfaceFlowRulesValueUnknown(), diags
	}

	return InterfaceFlowRulesValue{
		InterfaceFlowRuleAttributes:          interfaceFlowRuleAttributesVal,
		InterfaceFlowRuleInterfaceCollection: interfaceFlowRuleInterfaceCollectionVal,
		InterfaceFlowRuleName:                interfaceFlowRuleNameVal,
		InterfaceFlowRuleSubnets:             interfaceFlowRuleSubnetsVal,
		InterfaceFlowRuleType:                interfaceFlowRuleTypeVal,
		InterfaceFlowRuleUuid:                interfaceFlowRuleUuidVal,
		state:                                attr.ValueStateKnown,
	}, diags
}

func NewInterfaceFlowRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InterfaceFlowRulesValue {
	object, diags := NewInterfaceFlowRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInterfaceFlowRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InterfaceFlowRulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInterfaceFlowRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInterfaceFlowRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInterfaceFlowRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInterfaceFlowRulesValueMust(InterfaceFlowRulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InterfaceFlowRulesType) ValueType(ctx context.Context) attr.Value {
	return InterfaceFlowRulesValue{}
}

var _ basetypes.ObjectValuable = InterfaceFlowRulesValue{}

type InterfaceFlowRulesValue struct {
	InterfaceFlowRuleAttributes          basetypes.ListValue   `tfsdk:"interface_flow_rule_attributes"`
	InterfaceFlowRuleInterfaceCollection basetypes.ListValue   `tfsdk:"interface_flow_rule_interface_collection"`
	InterfaceFlowRuleName                basetypes.StringValue `tfsdk:"interface_flow_rule_name"`
	InterfaceFlowRuleSubnets             basetypes.SetValue    `tfsdk:"interface_flow_rule_subnets"`
	InterfaceFlowRuleType                basetypes.StringValue `tfsdk:"interface_flow_rule_type"`
	InterfaceFlowRuleUuid                basetypes.StringValue `tfsdk:"interface_flow_rule_uuid"`
	state                                attr.ValueState
}

func (v InterfaceFlowRulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["interface_flow_rule_attributes"] = basetypes.ListType{
		ElemType: InterfaceFlowRuleAttributesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["interface_flow_rule_interface_collection"] = basetypes.ListType{
		ElemType: InterfaceFlowRuleInterfaceCollectionValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["interface_flow_rule_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_subnets"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["interface_flow_rule_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.InterfaceFlowRuleAttributes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_attributes"] = val

		val, err = v.InterfaceFlowRuleInterfaceCollection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_interface_collection"] = val

		val, err = v.InterfaceFlowRuleName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_name"] = val

		val, err = v.InterfaceFlowRuleSubnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_subnets"] = val

		val, err = v.InterfaceFlowRuleType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_type"] = val

		val, err = v.InterfaceFlowRuleUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InterfaceFlowRulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InterfaceFlowRulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InterfaceFlowRulesValue) String() string {
	return "InterfaceFlowRulesValue"
}

func (v InterfaceFlowRulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	interfaceFlowRuleAttributes := types.ListValueMust(
		InterfaceFlowRuleAttributesType{
			basetypes.ObjectType{
				AttrTypes: InterfaceFlowRuleAttributesValue{}.AttributeTypes(ctx),
			},
		},
		v.InterfaceFlowRuleAttributes.Elements(),
	)

	if v.InterfaceFlowRuleAttributes.IsNull() {
		interfaceFlowRuleAttributes = types.ListNull(
			InterfaceFlowRuleAttributesType{
				basetypes.ObjectType{
					AttrTypes: InterfaceFlowRuleAttributesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.InterfaceFlowRuleAttributes.IsUnknown() {
		interfaceFlowRuleAttributes = types.ListUnknown(
			InterfaceFlowRuleAttributesType{
				basetypes.ObjectType{
					AttrTypes: InterfaceFlowRuleAttributesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	interfaceFlowRuleInterfaceCollection := types.ListValueMust(
		InterfaceFlowRuleInterfaceCollectionType{
			basetypes.ObjectType{
				AttrTypes: InterfaceFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
			},
		},
		v.InterfaceFlowRuleInterfaceCollection.Elements(),
	)

	if v.InterfaceFlowRuleInterfaceCollection.IsNull() {
		interfaceFlowRuleInterfaceCollection = types.ListNull(
			InterfaceFlowRuleInterfaceCollectionType{
				basetypes.ObjectType{
					AttrTypes: InterfaceFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.InterfaceFlowRuleInterfaceCollection.IsUnknown() {
		interfaceFlowRuleInterfaceCollection = types.ListUnknown(
			InterfaceFlowRuleInterfaceCollectionType{
				basetypes.ObjectType{
					AttrTypes: InterfaceFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var interfaceFlowRuleSubnetsVal basetypes.SetValue
	switch {
	case v.InterfaceFlowRuleSubnets.IsUnknown():
		interfaceFlowRuleSubnetsVal = types.SetUnknown(types.StringType)
	case v.InterfaceFlowRuleSubnets.IsNull():
		interfaceFlowRuleSubnetsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		interfaceFlowRuleSubnetsVal, d = types.SetValue(types.StringType, v.InterfaceFlowRuleSubnets.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"interface_flow_rule_attributes": basetypes.ListType{
				ElemType: InterfaceFlowRuleAttributesValue{}.Type(ctx),
			},
			"interface_flow_rule_interface_collection": basetypes.ListType{
				ElemType: InterfaceFlowRuleInterfaceCollectionValue{}.Type(ctx),
			},
			"interface_flow_rule_name": basetypes.StringType{},
			"interface_flow_rule_subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"interface_flow_rule_type": basetypes.StringType{},
			"interface_flow_rule_uuid": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"interface_flow_rule_attributes": basetypes.ListType{
			ElemType: InterfaceFlowRuleAttributesValue{}.Type(ctx),
		},
		"interface_flow_rule_interface_collection": basetypes.ListType{
			ElemType: InterfaceFlowRuleInterfaceCollectionValue{}.Type(ctx),
		},
		"interface_flow_rule_name": basetypes.StringType{},
		"interface_flow_rule_subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"interface_flow_rule_type": basetypes.StringType{},
		"interface_flow_rule_uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface_flow_rule_attributes":           interfaceFlowRuleAttributes,
			"interface_flow_rule_interface_collection": interfaceFlowRuleInterfaceCollection,
			"interface_flow_rule_name":                 v.InterfaceFlowRuleName,
			"interface_flow_rule_subnets":              interfaceFlowRuleSubnetsVal,
			"interface_flow_rule_type":                 v.InterfaceFlowRuleType,
			"interface_flow_rule_uuid":                 v.InterfaceFlowRuleUuid,
		})

	return objVal, diags
}

func (v InterfaceFlowRulesValue) Equal(o attr.Value) bool {
	other, ok := o.(InterfaceFlowRulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InterfaceFlowRuleAttributes.Equal(other.InterfaceFlowRuleAttributes) {
		return false
	}

	if !v.InterfaceFlowRuleInterfaceCollection.Equal(other.InterfaceFlowRuleInterfaceCollection) {
		return false
	}

	if !v.InterfaceFlowRuleName.Equal(other.InterfaceFlowRuleName) {
		return false
	}

	if !v.InterfaceFlowRuleSubnets.Equal(other.InterfaceFlowRuleSubnets) {
		return false
	}

	if !v.InterfaceFlowRuleType.Equal(other.InterfaceFlowRuleType) {
		return false
	}

	if !v.InterfaceFlowRuleUuid.Equal(other.InterfaceFlowRuleUuid) {
		return false
	}

	return true
}

func (v InterfaceFlowRulesValue) Type(ctx context.Context) attr.Type {
	return InterfaceFlowRulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InterfaceFlowRulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface_flow_rule_attributes": basetypes.ListType{
			ElemType: InterfaceFlowRuleAttributesValue{}.Type(ctx),
		},
		"interface_flow_rule_interface_collection": basetypes.ListType{
			ElemType: InterfaceFlowRuleInterfaceCollectionValue{}.Type(ctx),
		},
		"interface_flow_rule_name": basetypes.StringType{},
		"interface_flow_rule_subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"interface_flow_rule_type": basetypes.StringType{},
		"interface_flow_rule_uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InterfaceFlowRuleAttributesType{}

type InterfaceFlowRuleAttributesType struct {
	basetypes.ObjectType
}

func (t InterfaceFlowRuleAttributesType) Equal(o attr.Type) bool {
	other, ok := o.(InterfaceFlowRuleAttributesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InterfaceFlowRuleAttributesType) String() string {
	return "InterfaceFlowRuleAttributesType"
}

func (t InterfaceFlowRuleAttributesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceFlowRuleAttributeIdAttribute, ok := attributes["interface_flow_rule_attribute_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_attribute_id is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleAttributeIdVal, ok := interfaceFlowRuleAttributeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_attribute_id expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleAttributeIdAttribute))
	}

	interfaceFlowRuleBidirectionalAttribute, ok := attributes["interface_flow_rule_bidirectional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_bidirectional is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleBidirectionalVal, ok := interfaceFlowRuleBidirectionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_bidirectional expected to be basetypes.BoolValue, was: %T`, interfaceFlowRuleBidirectionalAttribute))
	}

	interfaceFlowRuleDstIpAttribute, ok := attributes["interface_flow_rule_dst_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_dst_ip is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleDstIpVal, ok := interfaceFlowRuleDstIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_dst_ip expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleDstIpAttribute))
	}

	interfaceFlowRuleDstPortAttribute, ok := attributes["interface_flow_rule_dst_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_dst_port is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleDstPortVal, ok := interfaceFlowRuleDstPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_dst_port expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleDstPortAttribute))
	}

	interfaceFlowRuleProtocolAttribute, ok := attributes["interface_flow_rule_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_protocol is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleProtocolVal, ok := interfaceFlowRuleProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_protocol expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleProtocolAttribute))
	}

	interfaceFlowRuleSrcIpAttribute, ok := attributes["interface_flow_rule_src_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_src_ip is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleSrcIpVal, ok := interfaceFlowRuleSrcIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_src_ip expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleSrcIpAttribute))
	}

	interfaceFlowRuleSrcPortAttribute, ok := attributes["interface_flow_rule_src_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_src_port is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleSrcPortVal, ok := interfaceFlowRuleSrcPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_src_port expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleSrcPortAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InterfaceFlowRuleAttributesValue{
		InterfaceFlowRuleAttributeId:   interfaceFlowRuleAttributeIdVal,
		InterfaceFlowRuleBidirectional: interfaceFlowRuleBidirectionalVal,
		InterfaceFlowRuleDstIp:         interfaceFlowRuleDstIpVal,
		InterfaceFlowRuleDstPort:       interfaceFlowRuleDstPortVal,
		InterfaceFlowRuleProtocol:      interfaceFlowRuleProtocolVal,
		InterfaceFlowRuleSrcIp:         interfaceFlowRuleSrcIpVal,
		InterfaceFlowRuleSrcPort:       interfaceFlowRuleSrcPortVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewInterfaceFlowRuleAttributesValueNull() InterfaceFlowRuleAttributesValue {
	return InterfaceFlowRuleAttributesValue{
		state: attr.ValueStateNull,
	}
}

func NewInterfaceFlowRuleAttributesValueUnknown() InterfaceFlowRuleAttributesValue {
	return InterfaceFlowRuleAttributesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInterfaceFlowRuleAttributesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InterfaceFlowRuleAttributesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InterfaceFlowRuleAttributesValue Attribute Value",
				"While creating a InterfaceFlowRuleAttributesValue value, a missing attribute value was detected. "+
					"A InterfaceFlowRuleAttributesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceFlowRuleAttributesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InterfaceFlowRuleAttributesValue Attribute Type",
				"While creating a InterfaceFlowRuleAttributesValue value, an invalid attribute value was detected. "+
					"A InterfaceFlowRuleAttributesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceFlowRuleAttributesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InterfaceFlowRuleAttributesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InterfaceFlowRuleAttributesValue Attribute Value",
				"While creating a InterfaceFlowRuleAttributesValue value, an extra attribute value was detected. "+
					"A InterfaceFlowRuleAttributesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InterfaceFlowRuleAttributesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	interfaceFlowRuleAttributeIdAttribute, ok := attributes["interface_flow_rule_attribute_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_attribute_id is missing from object`)

		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	interfaceFlowRuleAttributeIdVal, ok := interfaceFlowRuleAttributeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_attribute_id expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleAttributeIdAttribute))
	}

	interfaceFlowRuleBidirectionalAttribute, ok := attributes["interface_flow_rule_bidirectional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_bidirectional is missing from object`)

		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	interfaceFlowRuleBidirectionalVal, ok := interfaceFlowRuleBidirectionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_bidirectional expected to be basetypes.BoolValue, was: %T`, interfaceFlowRuleBidirectionalAttribute))
	}

	interfaceFlowRuleDstIpAttribute, ok := attributes["interface_flow_rule_dst_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_dst_ip is missing from object`)

		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	interfaceFlowRuleDstIpVal, ok := interfaceFlowRuleDstIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_dst_ip expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleDstIpAttribute))
	}

	interfaceFlowRuleDstPortAttribute, ok := attributes["interface_flow_rule_dst_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_dst_port is missing from object`)

		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	interfaceFlowRuleDstPortVal, ok := interfaceFlowRuleDstPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_dst_port expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleDstPortAttribute))
	}

	interfaceFlowRuleProtocolAttribute, ok := attributes["interface_flow_rule_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_protocol is missing from object`)

		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	interfaceFlowRuleProtocolVal, ok := interfaceFlowRuleProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_protocol expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleProtocolAttribute))
	}

	interfaceFlowRuleSrcIpAttribute, ok := attributes["interface_flow_rule_src_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_src_ip is missing from object`)

		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	interfaceFlowRuleSrcIpVal, ok := interfaceFlowRuleSrcIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_src_ip expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleSrcIpAttribute))
	}

	interfaceFlowRuleSrcPortAttribute, ok := attributes["interface_flow_rule_src_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_src_port is missing from object`)

		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	interfaceFlowRuleSrcPortVal, ok := interfaceFlowRuleSrcPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_src_port expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleSrcPortAttribute))
	}

	if diags.HasError() {
		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	return InterfaceFlowRuleAttributesValue{
		InterfaceFlowRuleAttributeId:   interfaceFlowRuleAttributeIdVal,
		InterfaceFlowRuleBidirectional: interfaceFlowRuleBidirectionalVal,
		InterfaceFlowRuleDstIp:         interfaceFlowRuleDstIpVal,
		InterfaceFlowRuleDstPort:       interfaceFlowRuleDstPortVal,
		InterfaceFlowRuleProtocol:      interfaceFlowRuleProtocolVal,
		InterfaceFlowRuleSrcIp:         interfaceFlowRuleSrcIpVal,
		InterfaceFlowRuleSrcPort:       interfaceFlowRuleSrcPortVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewInterfaceFlowRuleAttributesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InterfaceFlowRuleAttributesValue {
	object, diags := NewInterfaceFlowRuleAttributesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInterfaceFlowRuleAttributesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InterfaceFlowRuleAttributesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInterfaceFlowRuleAttributesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInterfaceFlowRuleAttributesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInterfaceFlowRuleAttributesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInterfaceFlowRuleAttributesValueMust(InterfaceFlowRuleAttributesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InterfaceFlowRuleAttributesType) ValueType(ctx context.Context) attr.Value {
	return InterfaceFlowRuleAttributesValue{}
}

var _ basetypes.ObjectValuable = InterfaceFlowRuleAttributesValue{}

type InterfaceFlowRuleAttributesValue struct {
	InterfaceFlowRuleAttributeId   basetypes.StringValue `tfsdk:"interface_flow_rule_attribute_id"`
	InterfaceFlowRuleBidirectional basetypes.BoolValue   `tfsdk:"interface_flow_rule_bidirectional"`
	InterfaceFlowRuleDstIp         basetypes.StringValue `tfsdk:"interface_flow_rule_dst_ip"`
	InterfaceFlowRuleDstPort       basetypes.StringValue `tfsdk:"interface_flow_rule_dst_port"`
	InterfaceFlowRuleProtocol      basetypes.StringValue `tfsdk:"interface_flow_rule_protocol"`
	InterfaceFlowRuleSrcIp         basetypes.StringValue `tfsdk:"interface_flow_rule_src_ip"`
	InterfaceFlowRuleSrcPort       basetypes.StringValue `tfsdk:"interface_flow_rule_src_port"`
	state                          attr.ValueState
}

func (v InterfaceFlowRuleAttributesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["interface_flow_rule_attribute_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_bidirectional"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_dst_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_dst_port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_src_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_src_port"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.InterfaceFlowRuleAttributeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_attribute_id"] = val

		val, err = v.InterfaceFlowRuleBidirectional.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_bidirectional"] = val

		val, err = v.InterfaceFlowRuleDstIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_dst_ip"] = val

		val, err = v.InterfaceFlowRuleDstPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_dst_port"] = val

		val, err = v.InterfaceFlowRuleProtocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_protocol"] = val

		val, err = v.InterfaceFlowRuleSrcIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_src_ip"] = val

		val, err = v.InterfaceFlowRuleSrcPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_src_port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InterfaceFlowRuleAttributesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InterfaceFlowRuleAttributesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InterfaceFlowRuleAttributesValue) String() string {
	return "InterfaceFlowRuleAttributesValue"
}

func (v InterfaceFlowRuleAttributesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"interface_flow_rule_attribute_id":  basetypes.StringType{},
		"interface_flow_rule_bidirectional": basetypes.BoolType{},
		"interface_flow_rule_dst_ip":        basetypes.StringType{},
		"interface_flow_rule_dst_port":      basetypes.StringType{},
		"interface_flow_rule_protocol":      basetypes.StringType{},
		"interface_flow_rule_src_ip":        basetypes.StringType{},
		"interface_flow_rule_src_port":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface_flow_rule_attribute_id":  v.InterfaceFlowRuleAttributeId,
			"interface_flow_rule_bidirectional": v.InterfaceFlowRuleBidirectional,
			"interface_flow_rule_dst_ip":        v.InterfaceFlowRuleDstIp,
			"interface_flow_rule_dst_port":      v.InterfaceFlowRuleDstPort,
			"interface_flow_rule_protocol":      v.InterfaceFlowRuleProtocol,
			"interface_flow_rule_src_ip":        v.InterfaceFlowRuleSrcIp,
			"interface_flow_rule_src_port":      v.InterfaceFlowRuleSrcPort,
		})

	return objVal, diags
}

func (v InterfaceFlowRuleAttributesValue) Equal(o attr.Value) bool {
	other, ok := o.(InterfaceFlowRuleAttributesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InterfaceFlowRuleAttributeId.Equal(other.InterfaceFlowRuleAttributeId) {
		return false
	}

	if !v.InterfaceFlowRuleBidirectional.Equal(other.InterfaceFlowRuleBidirectional) {
		return false
	}

	if !v.InterfaceFlowRuleDstIp.Equal(other.InterfaceFlowRuleDstIp) {
		return false
	}

	if !v.InterfaceFlowRuleDstPort.Equal(other.InterfaceFlowRuleDstPort) {
		return false
	}

	if !v.InterfaceFlowRuleProtocol.Equal(other.InterfaceFlowRuleProtocol) {
		return false
	}

	if !v.InterfaceFlowRuleSrcIp.Equal(other.InterfaceFlowRuleSrcIp) {
		return false
	}

	if !v.InterfaceFlowRuleSrcPort.Equal(other.InterfaceFlowRuleSrcPort) {
		return false
	}

	return true
}

func (v InterfaceFlowRuleAttributesValue) Type(ctx context.Context) attr.Type {
	return InterfaceFlowRuleAttributesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InterfaceFlowRuleAttributesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface_flow_rule_attribute_id":  basetypes.StringType{},
		"interface_flow_rule_bidirectional": basetypes.BoolType{},
		"interface_flow_rule_dst_ip":        basetypes.StringType{},
		"interface_flow_rule_dst_port":      basetypes.StringType{},
		"interface_flow_rule_protocol":      basetypes.StringType{},
		"interface_flow_rule_src_ip":        basetypes.StringType{},
		"interface_flow_rule_src_port":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InterfaceFlowRuleInterfaceCollectionType{}

type InterfaceFlowRuleInterfaceCollectionType struct {
	basetypes.ObjectType
}

func (t InterfaceFlowRuleInterfaceCollectionType) Equal(o attr.Type) bool {
	other, ok := o.(InterfaceFlowRuleInterfaceCollectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InterfaceFlowRuleInterfaceCollectionType) String() string {
	return "InterfaceFlowRuleInterfaceCollectionType"
}

func (t InterfaceFlowRuleInterfaceCollectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceFlowRuleInterfacesAttribute, ok := attributes["interface_flow_rule_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_interfaces is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleInterfacesVal, ok := interfaceFlowRuleInterfacesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_interfaces expected to be basetypes.SetValue, was: %T`, interfaceFlowRuleInterfacesAttribute))
	}

	interfaceFlowRuleSwitchIdAttribute, ok := attributes["interface_flow_rule_switch_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_switch_id is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleSwitchIdVal, ok := interfaceFlowRuleSwitchIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_switch_id expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleSwitchIdAttribute))
	}

	interfaceFlowRuleSwitchNameAttribute, ok := attributes["interface_flow_rule_switch_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_switch_name is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleSwitchNameVal, ok := interfaceFlowRuleSwitchNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_switch_name expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleSwitchNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InterfaceFlowRuleInterfaceCollectionValue{
		InterfaceFlowRuleInterfaces: interfaceFlowRuleInterfacesVal,
		InterfaceFlowRuleSwitchId:   interfaceFlowRuleSwitchIdVal,
		InterfaceFlowRuleSwitchName: interfaceFlowRuleSwitchNameVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewInterfaceFlowRuleInterfaceCollectionValueNull() InterfaceFlowRuleInterfaceCollectionValue {
	return InterfaceFlowRuleInterfaceCollectionValue{
		state: attr.ValueStateNull,
	}
}

func NewInterfaceFlowRuleInterfaceCollectionValueUnknown() InterfaceFlowRuleInterfaceCollectionValue {
	return InterfaceFlowRuleInterfaceCollectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInterfaceFlowRuleInterfaceCollectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InterfaceFlowRuleInterfaceCollectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InterfaceFlowRuleInterfaceCollectionValue Attribute Value",
				"While creating a InterfaceFlowRuleInterfaceCollectionValue value, a missing attribute value was detected. "+
					"A InterfaceFlowRuleInterfaceCollectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceFlowRuleInterfaceCollectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InterfaceFlowRuleInterfaceCollectionValue Attribute Type",
				"While creating a InterfaceFlowRuleInterfaceCollectionValue value, an invalid attribute value was detected. "+
					"A InterfaceFlowRuleInterfaceCollectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceFlowRuleInterfaceCollectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InterfaceFlowRuleInterfaceCollectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InterfaceFlowRuleInterfaceCollectionValue Attribute Value",
				"While creating a InterfaceFlowRuleInterfaceCollectionValue value, an extra attribute value was detected. "+
					"A InterfaceFlowRuleInterfaceCollectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InterfaceFlowRuleInterfaceCollectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInterfaceFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceFlowRuleInterfacesAttribute, ok := attributes["interface_flow_rule_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_interfaces is missing from object`)

		return NewInterfaceFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceFlowRuleInterfacesVal, ok := interfaceFlowRuleInterfacesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_interfaces expected to be basetypes.SetValue, was: %T`, interfaceFlowRuleInterfacesAttribute))
	}

	interfaceFlowRuleSwitchIdAttribute, ok := attributes["interface_flow_rule_switch_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_switch_id is missing from object`)

		return NewInterfaceFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceFlowRuleSwitchIdVal, ok := interfaceFlowRuleSwitchIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_switch_id expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleSwitchIdAttribute))
	}

	interfaceFlowRuleSwitchNameAttribute, ok := attributes["interface_flow_rule_switch_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_switch_name is missing from object`)

		return NewInterfaceFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceFlowRuleSwitchNameVal, ok := interfaceFlowRuleSwitchNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_switch_name expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleSwitchNameAttribute))
	}

	if diags.HasError() {
		return NewInterfaceFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	return InterfaceFlowRuleInterfaceCollectionValue{
		InterfaceFlowRuleInterfaces: interfaceFlowRuleInterfacesVal,
		InterfaceFlowRuleSwitchId:   interfaceFlowRuleSwitchIdVal,
		InterfaceFlowRuleSwitchName: interfaceFlowRuleSwitchNameVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewInterfaceFlowRuleInterfaceCollectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InterfaceFlowRuleInterfaceCollectionValue {
	object, diags := NewInterfaceFlowRuleInterfaceCollectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInterfaceFlowRuleInterfaceCollectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InterfaceFlowRuleInterfaceCollectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInterfaceFlowRuleInterfaceCollectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInterfaceFlowRuleInterfaceCollectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInterfaceFlowRuleInterfaceCollectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInterfaceFlowRuleInterfaceCollectionValueMust(InterfaceFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InterfaceFlowRuleInterfaceCollectionType) ValueType(ctx context.Context) attr.Value {
	return InterfaceFlowRuleInterfaceCollectionValue{}
}

var _ basetypes.ObjectValuable = InterfaceFlowRuleInterfaceCollectionValue{}

type InterfaceFlowRuleInterfaceCollectionValue struct {
	InterfaceFlowRuleInterfaces basetypes.SetValue    `tfsdk:"interface_flow_rule_interfaces"`
	InterfaceFlowRuleSwitchId   basetypes.StringValue `tfsdk:"interface_flow_rule_switch_id"`
	InterfaceFlowRuleSwitchName basetypes.StringValue `tfsdk:"interface_flow_rule_switch_name"`
	state                       attr.ValueState
}

func (v InterfaceFlowRuleInterfaceCollectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["interface_flow_rule_interfaces"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["interface_flow_rule_switch_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_switch_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.InterfaceFlowRuleInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_interfaces"] = val

		val, err = v.InterfaceFlowRuleSwitchId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_switch_id"] = val

		val, err = v.InterfaceFlowRuleSwitchName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_switch_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InterfaceFlowRuleInterfaceCollectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InterfaceFlowRuleInterfaceCollectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InterfaceFlowRuleInterfaceCollectionValue) String() string {
	return "InterfaceFlowRuleInterfaceCollectionValue"
}

func (v InterfaceFlowRuleInterfaceCollectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var interfaceFlowRuleInterfacesVal basetypes.SetValue
	switch {
	case v.InterfaceFlowRuleInterfaces.IsUnknown():
		interfaceFlowRuleInterfacesVal = types.SetUnknown(types.StringType)
	case v.InterfaceFlowRuleInterfaces.IsNull():
		interfaceFlowRuleInterfacesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		interfaceFlowRuleInterfacesVal, d = types.SetValue(types.StringType, v.InterfaceFlowRuleInterfaces.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"interface_flow_rule_interfaces": basetypes.SetType{
				ElemType: types.StringType,
			},
			"interface_flow_rule_switch_id":   basetypes.StringType{},
			"interface_flow_rule_switch_name": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"interface_flow_rule_interfaces": basetypes.SetType{
			ElemType: types.StringType,
		},
		"interface_flow_rule_switch_id":   basetypes.StringType{},
		"interface_flow_rule_switch_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface_flow_rule_interfaces":  interfaceFlowRuleInterfacesVal,
			"interface_flow_rule_switch_id":   v.InterfaceFlowRuleSwitchId,
			"interface_flow_rule_switch_name": v.InterfaceFlowRuleSwitchName,
		})

	return objVal, diags
}

func (v InterfaceFlowRuleInterfaceCollectionValue) Equal(o attr.Value) bool {
	other, ok := o.(InterfaceFlowRuleInterfaceCollectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InterfaceFlowRuleInterfaces.Equal(other.InterfaceFlowRuleInterfaces) {
		return false
	}

	if !v.InterfaceFlowRuleSwitchId.Equal(other.InterfaceFlowRuleSwitchId) {
		return false
	}

	if !v.InterfaceFlowRuleSwitchName.Equal(other.InterfaceFlowRuleSwitchName) {
		return false
	}

	return true
}

func (v InterfaceFlowRuleInterfaceCollectionValue) Type(ctx context.Context) attr.Type {
	return InterfaceFlowRuleInterfaceCollectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InterfaceFlowRuleInterfaceCollectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface_flow_rule_interfaces": basetypes.SetType{
			ElemType: types.StringType,
		},
		"interface_flow_rule_switch_id":   basetypes.StringType{},
		"interface_flow_rule_switch_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InterfaceRulesType{}

type InterfaceRulesType struct {
	basetypes.ObjectType
}

func (t InterfaceRulesType) Equal(o attr.Type) bool {
	other, ok := o.(InterfaceRulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InterfaceRulesType) String() string {
	return "InterfaceRulesType"
}

func (t InterfaceRulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceRuleEnableFabricInterconnectAttribute, ok := attributes["interface_rule_enable_fabric_interconnect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_enable_fabric_interconnect is missing from object`)

		return nil, diags
	}

	interfaceRuleEnableFabricInterconnectVal, ok := interfaceRuleEnableFabricInterconnectAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_enable_fabric_interconnect expected to be basetypes.BoolValue, was: %T`, interfaceRuleEnableFabricInterconnectAttribute))
	}

	interfaceRuleEnableL3OutAttribute, ok := attributes["interface_rule_enable_l3_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_enable_l3_out is missing from object`)

		return nil, diags
	}

	interfaceRuleEnableL3OutVal, ok := interfaceRuleEnableL3OutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_enable_l3_out expected to be basetypes.BoolValue, was: %T`, interfaceRuleEnableL3OutAttribute))
	}

	interfaceRuleEnabledAttribute, ok := attributes["interface_rule_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_enabled is missing from object`)

		return nil, diags
	}

	interfaceRuleEnabledVal, ok := interfaceRuleEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_enabled expected to be basetypes.BoolValue, was: %T`, interfaceRuleEnabledAttribute))
	}

	interfaceRuleInterfaceCollectionAttribute, ok := attributes["interface_rule_interface_collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_collection is missing from object`)

		return nil, diags
	}

	interfaceRuleInterfaceCollectionVal, ok := interfaceRuleInterfaceCollectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_collection expected to be basetypes.ListValue, was: %T`, interfaceRuleInterfaceCollectionAttribute))
	}

	interfaceRuleNameAttribute, ok := attributes["interface_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_name is missing from object`)

		return nil, diags
	}

	interfaceRuleNameVal, ok := interfaceRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_name expected to be basetypes.StringValue, was: %T`, interfaceRuleNameAttribute))
	}

	interfaceRuleSubnetsAttribute, ok := attributes["interface_rule_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_subnets is missing from object`)

		return nil, diags
	}

	interfaceRuleSubnetsVal, ok := interfaceRuleSubnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_subnets expected to be basetypes.SetValue, was: %T`, interfaceRuleSubnetsAttribute))
	}

	interfaceRuleUuidAttribute, ok := attributes["interface_rule_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_uuid is missing from object`)

		return nil, diags
	}

	interfaceRuleUuidVal, ok := interfaceRuleUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_uuid expected to be basetypes.StringValue, was: %T`, interfaceRuleUuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InterfaceRulesValue{
		InterfaceRuleEnableFabricInterconnect: interfaceRuleEnableFabricInterconnectVal,
		InterfaceRuleEnableL3Out:              interfaceRuleEnableL3OutVal,
		InterfaceRuleEnabled:                  interfaceRuleEnabledVal,
		InterfaceRuleInterfaceCollection:      interfaceRuleInterfaceCollectionVal,
		InterfaceRuleName:                     interfaceRuleNameVal,
		InterfaceRuleSubnets:                  interfaceRuleSubnetsVal,
		InterfaceRuleUuid:                     interfaceRuleUuidVal,
		state:                                 attr.ValueStateKnown,
	}, diags
}

func NewInterfaceRulesValueNull() InterfaceRulesValue {
	return InterfaceRulesValue{
		state: attr.ValueStateNull,
	}
}

func NewInterfaceRulesValueUnknown() InterfaceRulesValue {
	return InterfaceRulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInterfaceRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InterfaceRulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InterfaceRulesValue Attribute Value",
				"While creating a InterfaceRulesValue value, a missing attribute value was detected. "+
					"A InterfaceRulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceRulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InterfaceRulesValue Attribute Type",
				"While creating a InterfaceRulesValue value, an invalid attribute value was detected. "+
					"A InterfaceRulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceRulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InterfaceRulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InterfaceRulesValue Attribute Value",
				"While creating a InterfaceRulesValue value, an extra attribute value was detected. "+
					"A InterfaceRulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InterfaceRulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInterfaceRulesValueUnknown(), diags
	}

	interfaceRuleEnableFabricInterconnectAttribute, ok := attributes["interface_rule_enable_fabric_interconnect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_enable_fabric_interconnect is missing from object`)

		return NewInterfaceRulesValueUnknown(), diags
	}

	interfaceRuleEnableFabricInterconnectVal, ok := interfaceRuleEnableFabricInterconnectAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_enable_fabric_interconnect expected to be basetypes.BoolValue, was: %T`, interfaceRuleEnableFabricInterconnectAttribute))
	}

	interfaceRuleEnableL3OutAttribute, ok := attributes["interface_rule_enable_l3_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_enable_l3_out is missing from object`)

		return NewInterfaceRulesValueUnknown(), diags
	}

	interfaceRuleEnableL3OutVal, ok := interfaceRuleEnableL3OutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_enable_l3_out expected to be basetypes.BoolValue, was: %T`, interfaceRuleEnableL3OutAttribute))
	}

	interfaceRuleEnabledAttribute, ok := attributes["interface_rule_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_enabled is missing from object`)

		return NewInterfaceRulesValueUnknown(), diags
	}

	interfaceRuleEnabledVal, ok := interfaceRuleEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_enabled expected to be basetypes.BoolValue, was: %T`, interfaceRuleEnabledAttribute))
	}

	interfaceRuleInterfaceCollectionAttribute, ok := attributes["interface_rule_interface_collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_collection is missing from object`)

		return NewInterfaceRulesValueUnknown(), diags
	}

	interfaceRuleInterfaceCollectionVal, ok := interfaceRuleInterfaceCollectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_collection expected to be basetypes.ListValue, was: %T`, interfaceRuleInterfaceCollectionAttribute))
	}

	interfaceRuleNameAttribute, ok := attributes["interface_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_name is missing from object`)

		return NewInterfaceRulesValueUnknown(), diags
	}

	interfaceRuleNameVal, ok := interfaceRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_name expected to be basetypes.StringValue, was: %T`, interfaceRuleNameAttribute))
	}

	interfaceRuleSubnetsAttribute, ok := attributes["interface_rule_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_subnets is missing from object`)

		return NewInterfaceRulesValueUnknown(), diags
	}

	interfaceRuleSubnetsVal, ok := interfaceRuleSubnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_subnets expected to be basetypes.SetValue, was: %T`, interfaceRuleSubnetsAttribute))
	}

	interfaceRuleUuidAttribute, ok := attributes["interface_rule_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_uuid is missing from object`)

		return NewInterfaceRulesValueUnknown(), diags
	}

	interfaceRuleUuidVal, ok := interfaceRuleUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_uuid expected to be basetypes.StringValue, was: %T`, interfaceRuleUuidAttribute))
	}

	if diags.HasError() {
		return NewInterfaceRulesValueUnknown(), diags
	}

	return InterfaceRulesValue{
		InterfaceRuleEnableFabricInterconnect: interfaceRuleEnableFabricInterconnectVal,
		InterfaceRuleEnableL3Out:              interfaceRuleEnableL3OutVal,
		InterfaceRuleEnabled:                  interfaceRuleEnabledVal,
		InterfaceRuleInterfaceCollection:      interfaceRuleInterfaceCollectionVal,
		InterfaceRuleName:                     interfaceRuleNameVal,
		InterfaceRuleSubnets:                  interfaceRuleSubnetsVal,
		InterfaceRuleUuid:                     interfaceRuleUuidVal,
		state:                                 attr.ValueStateKnown,
	}, diags
}

func NewInterfaceRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InterfaceRulesValue {
	object, diags := NewInterfaceRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInterfaceRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InterfaceRulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInterfaceRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInterfaceRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInterfaceRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInterfaceRulesValueMust(InterfaceRulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InterfaceRulesType) ValueType(ctx context.Context) attr.Value {
	return InterfaceRulesValue{}
}

var _ basetypes.ObjectValuable = InterfaceRulesValue{}

type InterfaceRulesValue struct {
	InterfaceRuleEnableFabricInterconnect basetypes.BoolValue   `tfsdk:"interface_rule_enable_fabric_interconnect"`
	InterfaceRuleEnableL3Out              basetypes.BoolValue   `tfsdk:"interface_rule_enable_l3_out"`
	InterfaceRuleEnabled                  basetypes.BoolValue   `tfsdk:"interface_rule_enabled"`
	InterfaceRuleInterfaceCollection      basetypes.ListValue   `tfsdk:"interface_rule_interface_collection"`
	InterfaceRuleName                     basetypes.StringValue `tfsdk:"interface_rule_name"`
	InterfaceRuleSubnets                  basetypes.SetValue    `tfsdk:"interface_rule_subnets"`
	InterfaceRuleUuid                     basetypes.StringValue `tfsdk:"interface_rule_uuid"`
	state                                 attr.ValueState
}

func (v InterfaceRulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["interface_rule_enable_fabric_interconnect"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["interface_rule_enable_l3_out"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["interface_rule_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["interface_rule_interface_collection"] = basetypes.ListType{
		ElemType: InterfaceRuleInterfaceCollectionValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["interface_rule_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_rule_subnets"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["interface_rule_uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.InterfaceRuleEnableFabricInterconnect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_enable_fabric_interconnect"] = val

		val, err = v.InterfaceRuleEnableL3Out.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_enable_l3_out"] = val

		val, err = v.InterfaceRuleEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_enabled"] = val

		val, err = v.InterfaceRuleInterfaceCollection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_interface_collection"] = val

		val, err = v.InterfaceRuleName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_name"] = val

		val, err = v.InterfaceRuleSubnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_subnets"] = val

		val, err = v.InterfaceRuleUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InterfaceRulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InterfaceRulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InterfaceRulesValue) String() string {
	return "InterfaceRulesValue"
}

func (v InterfaceRulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	interfaceRuleInterfaceCollection := types.ListValueMust(
		InterfaceRuleInterfaceCollectionType{
			basetypes.ObjectType{
				AttrTypes: InterfaceRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
			},
		},
		v.InterfaceRuleInterfaceCollection.Elements(),
	)

	if v.InterfaceRuleInterfaceCollection.IsNull() {
		interfaceRuleInterfaceCollection = types.ListNull(
			InterfaceRuleInterfaceCollectionType{
				basetypes.ObjectType{
					AttrTypes: InterfaceRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.InterfaceRuleInterfaceCollection.IsUnknown() {
		interfaceRuleInterfaceCollection = types.ListUnknown(
			InterfaceRuleInterfaceCollectionType{
				basetypes.ObjectType{
					AttrTypes: InterfaceRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var interfaceRuleSubnetsVal basetypes.SetValue
	switch {
	case v.InterfaceRuleSubnets.IsUnknown():
		interfaceRuleSubnetsVal = types.SetUnknown(types.StringType)
	case v.InterfaceRuleSubnets.IsNull():
		interfaceRuleSubnetsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		interfaceRuleSubnetsVal, d = types.SetValue(types.StringType, v.InterfaceRuleSubnets.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"interface_rule_enable_fabric_interconnect": basetypes.BoolType{},
			"interface_rule_enable_l3_out":              basetypes.BoolType{},
			"interface_rule_enabled":                    basetypes.BoolType{},
			"interface_rule_interface_collection": basetypes.ListType{
				ElemType: InterfaceRuleInterfaceCollectionValue{}.Type(ctx),
			},
			"interface_rule_name": basetypes.StringType{},
			"interface_rule_subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"interface_rule_uuid": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"interface_rule_enable_fabric_interconnect": basetypes.BoolType{},
		"interface_rule_enable_l3_out":              basetypes.BoolType{},
		"interface_rule_enabled":                    basetypes.BoolType{},
		"interface_rule_interface_collection": basetypes.ListType{
			ElemType: InterfaceRuleInterfaceCollectionValue{}.Type(ctx),
		},
		"interface_rule_name": basetypes.StringType{},
		"interface_rule_subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"interface_rule_uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface_rule_enable_fabric_interconnect": v.InterfaceRuleEnableFabricInterconnect,
			"interface_rule_enable_l3_out":              v.InterfaceRuleEnableL3Out,
			"interface_rule_enabled":                    v.InterfaceRuleEnabled,
			"interface_rule_interface_collection":       interfaceRuleInterfaceCollection,
			"interface_rule_name":                       v.InterfaceRuleName,
			"interface_rule_subnets":                    interfaceRuleSubnetsVal,
			"interface_rule_uuid":                       v.InterfaceRuleUuid,
		})

	return objVal, diags
}

func (v InterfaceRulesValue) Equal(o attr.Value) bool {
	other, ok := o.(InterfaceRulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InterfaceRuleEnableFabricInterconnect.Equal(other.InterfaceRuleEnableFabricInterconnect) {
		return false
	}

	if !v.InterfaceRuleEnableL3Out.Equal(other.InterfaceRuleEnableL3Out) {
		return false
	}

	if !v.InterfaceRuleEnabled.Equal(other.InterfaceRuleEnabled) {
		return false
	}

	if !v.InterfaceRuleInterfaceCollection.Equal(other.InterfaceRuleInterfaceCollection) {
		return false
	}

	if !v.InterfaceRuleName.Equal(other.InterfaceRuleName) {
		return false
	}

	if !v.InterfaceRuleSubnets.Equal(other.InterfaceRuleSubnets) {
		return false
	}

	if !v.InterfaceRuleUuid.Equal(other.InterfaceRuleUuid) {
		return false
	}

	return true
}

func (v InterfaceRulesValue) Type(ctx context.Context) attr.Type {
	return InterfaceRulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InterfaceRulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface_rule_enable_fabric_interconnect": basetypes.BoolType{},
		"interface_rule_enable_l3_out":              basetypes.BoolType{},
		"interface_rule_enabled":                    basetypes.BoolType{},
		"interface_rule_interface_collection": basetypes.ListType{
			ElemType: InterfaceRuleInterfaceCollectionValue{}.Type(ctx),
		},
		"interface_rule_name": basetypes.StringType{},
		"interface_rule_subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"interface_rule_uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InterfaceRuleInterfaceCollectionType{}

type InterfaceRuleInterfaceCollectionType struct {
	basetypes.ObjectType
}

func (t InterfaceRuleInterfaceCollectionType) Equal(o attr.Type) bool {
	other, ok := o.(InterfaceRuleInterfaceCollectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InterfaceRuleInterfaceCollectionType) String() string {
	return "InterfaceRuleInterfaceCollectionType"
}

func (t InterfaceRuleInterfaceCollectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceRuleInterfacesAttribute, ok := attributes["interface_rule_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interfaces is missing from object`)

		return nil, diags
	}

	interfaceRuleInterfacesVal, ok := interfaceRuleInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interfaces expected to be basetypes.ListValue, was: %T`, interfaceRuleInterfacesAttribute))
	}

	interfaceRuleL3OutAttribute, ok := attributes["interface_rule_l3_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_l3_out is missing from object`)

		return nil, diags
	}

	interfaceRuleL3OutVal, ok := interfaceRuleL3OutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_l3_out expected to be basetypes.StringValue, was: %T`, interfaceRuleL3OutAttribute))
	}

	interfaceRuleSwitchIdAttribute, ok := attributes["interface_rule_switch_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_switch_id is missing from object`)

		return nil, diags
	}

	interfaceRuleSwitchIdVal, ok := interfaceRuleSwitchIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_switch_id expected to be basetypes.StringValue, was: %T`, interfaceRuleSwitchIdAttribute))
	}

	interfaceRuleSwitchNameAttribute, ok := attributes["interface_rule_switch_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_switch_name is missing from object`)

		return nil, diags
	}

	interfaceRuleSwitchNameVal, ok := interfaceRuleSwitchNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_switch_name expected to be basetypes.StringValue, was: %T`, interfaceRuleSwitchNameAttribute))
	}

	interfaceRuleTenantAttribute, ok := attributes["interface_rule_tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_tenant is missing from object`)

		return nil, diags
	}

	interfaceRuleTenantVal, ok := interfaceRuleTenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_tenant expected to be basetypes.StringValue, was: %T`, interfaceRuleTenantAttribute))
	}

	interfaceRuleVrfNameAttribute, ok := attributes["interface_rule_vrf_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_vrf_name is missing from object`)

		return nil, diags
	}

	interfaceRuleVrfNameVal, ok := interfaceRuleVrfNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_vrf_name expected to be basetypes.StringValue, was: %T`, interfaceRuleVrfNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InterfaceRuleInterfaceCollectionValue{
		InterfaceRuleInterfaces: interfaceRuleInterfacesVal,
		InterfaceRuleL3Out:      interfaceRuleL3OutVal,
		InterfaceRuleSwitchId:   interfaceRuleSwitchIdVal,
		InterfaceRuleSwitchName: interfaceRuleSwitchNameVal,
		InterfaceRuleTenant:     interfaceRuleTenantVal,
		InterfaceRuleVrfName:    interfaceRuleVrfNameVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewInterfaceRuleInterfaceCollectionValueNull() InterfaceRuleInterfaceCollectionValue {
	return InterfaceRuleInterfaceCollectionValue{
		state: attr.ValueStateNull,
	}
}

func NewInterfaceRuleInterfaceCollectionValueUnknown() InterfaceRuleInterfaceCollectionValue {
	return InterfaceRuleInterfaceCollectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInterfaceRuleInterfaceCollectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InterfaceRuleInterfaceCollectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InterfaceRuleInterfaceCollectionValue Attribute Value",
				"While creating a InterfaceRuleInterfaceCollectionValue value, a missing attribute value was detected. "+
					"A InterfaceRuleInterfaceCollectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceRuleInterfaceCollectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InterfaceRuleInterfaceCollectionValue Attribute Type",
				"While creating a InterfaceRuleInterfaceCollectionValue value, an invalid attribute value was detected. "+
					"A InterfaceRuleInterfaceCollectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceRuleInterfaceCollectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InterfaceRuleInterfaceCollectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InterfaceRuleInterfaceCollectionValue Attribute Value",
				"While creating a InterfaceRuleInterfaceCollectionValue value, an extra attribute value was detected. "+
					"A InterfaceRuleInterfaceCollectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InterfaceRuleInterfaceCollectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInterfaceRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceRuleInterfacesAttribute, ok := attributes["interface_rule_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interfaces is missing from object`)

		return NewInterfaceRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceRuleInterfacesVal, ok := interfaceRuleInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interfaces expected to be basetypes.ListValue, was: %T`, interfaceRuleInterfacesAttribute))
	}

	interfaceRuleL3OutAttribute, ok := attributes["interface_rule_l3_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_l3_out is missing from object`)

		return NewInterfaceRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceRuleL3OutVal, ok := interfaceRuleL3OutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_l3_out expected to be basetypes.StringValue, was: %T`, interfaceRuleL3OutAttribute))
	}

	interfaceRuleSwitchIdAttribute, ok := attributes["interface_rule_switch_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_switch_id is missing from object`)

		return NewInterfaceRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceRuleSwitchIdVal, ok := interfaceRuleSwitchIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_switch_id expected to be basetypes.StringValue, was: %T`, interfaceRuleSwitchIdAttribute))
	}

	interfaceRuleSwitchNameAttribute, ok := attributes["interface_rule_switch_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_switch_name is missing from object`)

		return NewInterfaceRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceRuleSwitchNameVal, ok := interfaceRuleSwitchNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_switch_name expected to be basetypes.StringValue, was: %T`, interfaceRuleSwitchNameAttribute))
	}

	interfaceRuleTenantAttribute, ok := attributes["interface_rule_tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_tenant is missing from object`)

		return NewInterfaceRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceRuleTenantVal, ok := interfaceRuleTenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_tenant expected to be basetypes.StringValue, was: %T`, interfaceRuleTenantAttribute))
	}

	interfaceRuleVrfNameAttribute, ok := attributes["interface_rule_vrf_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_vrf_name is missing from object`)

		return NewInterfaceRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceRuleVrfNameVal, ok := interfaceRuleVrfNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_vrf_name expected to be basetypes.StringValue, was: %T`, interfaceRuleVrfNameAttribute))
	}

	if diags.HasError() {
		return NewInterfaceRuleInterfaceCollectionValueUnknown(), diags
	}

	return InterfaceRuleInterfaceCollectionValue{
		InterfaceRuleInterfaces: interfaceRuleInterfacesVal,
		InterfaceRuleL3Out:      interfaceRuleL3OutVal,
		InterfaceRuleSwitchId:   interfaceRuleSwitchIdVal,
		InterfaceRuleSwitchName: interfaceRuleSwitchNameVal,
		InterfaceRuleTenant:     interfaceRuleTenantVal,
		InterfaceRuleVrfName:    interfaceRuleVrfNameVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewInterfaceRuleInterfaceCollectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InterfaceRuleInterfaceCollectionValue {
	object, diags := NewInterfaceRuleInterfaceCollectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInterfaceRuleInterfaceCollectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InterfaceRuleInterfaceCollectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInterfaceRuleInterfaceCollectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInterfaceRuleInterfaceCollectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInterfaceRuleInterfaceCollectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInterfaceRuleInterfaceCollectionValueMust(InterfaceRuleInterfaceCollectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InterfaceRuleInterfaceCollectionType) ValueType(ctx context.Context) attr.Value {
	return InterfaceRuleInterfaceCollectionValue{}
}

var _ basetypes.ObjectValuable = InterfaceRuleInterfaceCollectionValue{}

type InterfaceRuleInterfaceCollectionValue struct {
	InterfaceRuleInterfaces basetypes.ListValue   `tfsdk:"interface_rule_interfaces"`
	InterfaceRuleL3Out      basetypes.StringValue `tfsdk:"interface_rule_l3_out"`
	InterfaceRuleSwitchId   basetypes.StringValue `tfsdk:"interface_rule_switch_id"`
	InterfaceRuleSwitchName basetypes.StringValue `tfsdk:"interface_rule_switch_name"`
	InterfaceRuleTenant     basetypes.StringValue `tfsdk:"interface_rule_tenant"`
	InterfaceRuleVrfName    basetypes.StringValue `tfsdk:"interface_rule_vrf_name"`
	state                   attr.ValueState
}

func (v InterfaceRuleInterfaceCollectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["interface_rule_interfaces"] = basetypes.ListType{
		ElemType: InterfaceRuleInterfacesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["interface_rule_l3_out"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_rule_switch_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_rule_switch_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_rule_tenant"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_rule_vrf_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.InterfaceRuleInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_interfaces"] = val

		val, err = v.InterfaceRuleL3Out.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_l3_out"] = val

		val, err = v.InterfaceRuleSwitchId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_switch_id"] = val

		val, err = v.InterfaceRuleSwitchName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_switch_name"] = val

		val, err = v.InterfaceRuleTenant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_tenant"] = val

		val, err = v.InterfaceRuleVrfName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_vrf_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InterfaceRuleInterfaceCollectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InterfaceRuleInterfaceCollectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InterfaceRuleInterfaceCollectionValue) String() string {
	return "InterfaceRuleInterfaceCollectionValue"
}

func (v InterfaceRuleInterfaceCollectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	interfaceRuleInterfaces := types.ListValueMust(
		InterfaceRuleInterfacesType{
			basetypes.ObjectType{
				AttrTypes: InterfaceRuleInterfacesValue{}.AttributeTypes(ctx),
			},
		},
		v.InterfaceRuleInterfaces.Elements(),
	)

	if v.InterfaceRuleInterfaces.IsNull() {
		interfaceRuleInterfaces = types.ListNull(
			InterfaceRuleInterfacesType{
				basetypes.ObjectType{
					AttrTypes: InterfaceRuleInterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.InterfaceRuleInterfaces.IsUnknown() {
		interfaceRuleInterfaces = types.ListUnknown(
			InterfaceRuleInterfacesType{
				basetypes.ObjectType{
					AttrTypes: InterfaceRuleInterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"interface_rule_interfaces": basetypes.ListType{
			ElemType: InterfaceRuleInterfacesValue{}.Type(ctx),
		},
		"interface_rule_l3_out":      basetypes.StringType{},
		"interface_rule_switch_id":   basetypes.StringType{},
		"interface_rule_switch_name": basetypes.StringType{},
		"interface_rule_tenant":      basetypes.StringType{},
		"interface_rule_vrf_name":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface_rule_interfaces":  interfaceRuleInterfaces,
			"interface_rule_l3_out":      v.InterfaceRuleL3Out,
			"interface_rule_switch_id":   v.InterfaceRuleSwitchId,
			"interface_rule_switch_name": v.InterfaceRuleSwitchName,
			"interface_rule_tenant":      v.InterfaceRuleTenant,
			"interface_rule_vrf_name":    v.InterfaceRuleVrfName,
		})

	return objVal, diags
}

func (v InterfaceRuleInterfaceCollectionValue) Equal(o attr.Value) bool {
	other, ok := o.(InterfaceRuleInterfaceCollectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InterfaceRuleInterfaces.Equal(other.InterfaceRuleInterfaces) {
		return false
	}

	if !v.InterfaceRuleL3Out.Equal(other.InterfaceRuleL3Out) {
		return false
	}

	if !v.InterfaceRuleSwitchId.Equal(other.InterfaceRuleSwitchId) {
		return false
	}

	if !v.InterfaceRuleSwitchName.Equal(other.InterfaceRuleSwitchName) {
		return false
	}

	if !v.InterfaceRuleTenant.Equal(other.InterfaceRuleTenant) {
		return false
	}

	if !v.InterfaceRuleVrfName.Equal(other.InterfaceRuleVrfName) {
		return false
	}

	return true
}

func (v InterfaceRuleInterfaceCollectionValue) Type(ctx context.Context) attr.Type {
	return InterfaceRuleInterfaceCollectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InterfaceRuleInterfaceCollectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface_rule_interfaces": basetypes.ListType{
			ElemType: InterfaceRuleInterfacesValue{}.Type(ctx),
		},
		"interface_rule_l3_out":      basetypes.StringType{},
		"interface_rule_switch_id":   basetypes.StringType{},
		"interface_rule_switch_name": basetypes.StringType{},
		"interface_rule_tenant":      basetypes.StringType{},
		"interface_rule_vrf_name":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InterfaceRuleInterfacesType{}

type InterfaceRuleInterfacesType struct {
	basetypes.ObjectType
}

func (t InterfaceRuleInterfacesType) Equal(o attr.Type) bool {
	other, ok := o.(InterfaceRuleInterfacesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InterfaceRuleInterfacesType) String() string {
	return "InterfaceRuleInterfacesType"
}

func (t InterfaceRuleInterfacesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceRuleInterfaceEncapAttribute, ok := attributes["interface_rule_interface_encap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_encap is missing from object`)

		return nil, diags
	}

	interfaceRuleInterfaceEncapVal, ok := interfaceRuleInterfaceEncapAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_encap expected to be basetypes.StringValue, was: %T`, interfaceRuleInterfaceEncapAttribute))
	}

	interfaceRuleInterfaceNameAttribute, ok := attributes["interface_rule_interface_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_name is missing from object`)

		return nil, diags
	}

	interfaceRuleInterfaceNameVal, ok := interfaceRuleInterfaceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_name expected to be basetypes.StringValue, was: %T`, interfaceRuleInterfaceNameAttribute))
	}

	interfaceRuleInterfaceTypeAttribute, ok := attributes["interface_rule_interface_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_type is missing from object`)

		return nil, diags
	}

	interfaceRuleInterfaceTypeVal, ok := interfaceRuleInterfaceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_type expected to be basetypes.StringValue, was: %T`, interfaceRuleInterfaceTypeAttribute))
	}

	interfaceRuleInterfaceVrfNameAttribute, ok := attributes["interface_rule_interface_vrf_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_vrf_name is missing from object`)

		return nil, diags
	}

	interfaceRuleInterfaceVrfNameVal, ok := interfaceRuleInterfaceVrfNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_vrf_name expected to be basetypes.StringValue, was: %T`, interfaceRuleInterfaceVrfNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InterfaceRuleInterfacesValue{
		InterfaceRuleInterfaceEncap:   interfaceRuleInterfaceEncapVal,
		InterfaceRuleInterfaceName:    interfaceRuleInterfaceNameVal,
		InterfaceRuleInterfaceType:    interfaceRuleInterfaceTypeVal,
		InterfaceRuleInterfaceVrfName: interfaceRuleInterfaceVrfNameVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewInterfaceRuleInterfacesValueNull() InterfaceRuleInterfacesValue {
	return InterfaceRuleInterfacesValue{
		state: attr.ValueStateNull,
	}
}

func NewInterfaceRuleInterfacesValueUnknown() InterfaceRuleInterfacesValue {
	return InterfaceRuleInterfacesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInterfaceRuleInterfacesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InterfaceRuleInterfacesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InterfaceRuleInterfacesValue Attribute Value",
				"While creating a InterfaceRuleInterfacesValue value, a missing attribute value was detected. "+
					"A InterfaceRuleInterfacesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceRuleInterfacesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InterfaceRuleInterfacesValue Attribute Type",
				"While creating a InterfaceRuleInterfacesValue value, an invalid attribute value was detected. "+
					"A InterfaceRuleInterfacesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceRuleInterfacesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InterfaceRuleInterfacesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InterfaceRuleInterfacesValue Attribute Value",
				"While creating a InterfaceRuleInterfacesValue value, an extra attribute value was detected. "+
					"A InterfaceRuleInterfacesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InterfaceRuleInterfacesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInterfaceRuleInterfacesValueUnknown(), diags
	}

	interfaceRuleInterfaceEncapAttribute, ok := attributes["interface_rule_interface_encap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_encap is missing from object`)

		return NewInterfaceRuleInterfacesValueUnknown(), diags
	}

	interfaceRuleInterfaceEncapVal, ok := interfaceRuleInterfaceEncapAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_encap expected to be basetypes.StringValue, was: %T`, interfaceRuleInterfaceEncapAttribute))
	}

	interfaceRuleInterfaceNameAttribute, ok := attributes["interface_rule_interface_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_name is missing from object`)

		return NewInterfaceRuleInterfacesValueUnknown(), diags
	}

	interfaceRuleInterfaceNameVal, ok := interfaceRuleInterfaceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_name expected to be basetypes.StringValue, was: %T`, interfaceRuleInterfaceNameAttribute))
	}

	interfaceRuleInterfaceTypeAttribute, ok := attributes["interface_rule_interface_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_type is missing from object`)

		return NewInterfaceRuleInterfacesValueUnknown(), diags
	}

	interfaceRuleInterfaceTypeVal, ok := interfaceRuleInterfaceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_type expected to be basetypes.StringValue, was: %T`, interfaceRuleInterfaceTypeAttribute))
	}

	interfaceRuleInterfaceVrfNameAttribute, ok := attributes["interface_rule_interface_vrf_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_vrf_name is missing from object`)

		return NewInterfaceRuleInterfacesValueUnknown(), diags
	}

	interfaceRuleInterfaceVrfNameVal, ok := interfaceRuleInterfaceVrfNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_vrf_name expected to be basetypes.StringValue, was: %T`, interfaceRuleInterfaceVrfNameAttribute))
	}

	if diags.HasError() {
		return NewInterfaceRuleInterfacesValueUnknown(), diags
	}

	return InterfaceRuleInterfacesValue{
		InterfaceRuleInterfaceEncap:   interfaceRuleInterfaceEncapVal,
		InterfaceRuleInterfaceName:    interfaceRuleInterfaceNameVal,
		InterfaceRuleInterfaceType:    interfaceRuleInterfaceTypeVal,
		InterfaceRuleInterfaceVrfName: interfaceRuleInterfaceVrfNameVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewInterfaceRuleInterfacesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InterfaceRuleInterfacesValue {
	object, diags := NewInterfaceRuleInterfacesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInterfaceRuleInterfacesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InterfaceRuleInterfacesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInterfaceRuleInterfacesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInterfaceRuleInterfacesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInterfaceRuleInterfacesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInterfaceRuleInterfacesValueMust(InterfaceRuleInterfacesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InterfaceRuleInterfacesType) ValueType(ctx context.Context) attr.Value {
	return InterfaceRuleInterfacesValue{}
}

var _ basetypes.ObjectValuable = InterfaceRuleInterfacesValue{}

type InterfaceRuleInterfacesValue struct {
	InterfaceRuleInterfaceEncap   basetypes.StringValue `tfsdk:"interface_rule_interface_encap"`
	InterfaceRuleInterfaceName    basetypes.StringValue `tfsdk:"interface_rule_interface_name"`
	InterfaceRuleInterfaceType    basetypes.StringValue `tfsdk:"interface_rule_interface_type"`
	InterfaceRuleInterfaceVrfName basetypes.StringValue `tfsdk:"interface_rule_interface_vrf_name"`
	state                         attr.ValueState
}

func (v InterfaceRuleInterfacesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["interface_rule_interface_encap"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_rule_interface_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_rule_interface_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_rule_interface_vrf_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.InterfaceRuleInterfaceEncap.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_interface_encap"] = val

		val, err = v.InterfaceRuleInterfaceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_interface_name"] = val

		val, err = v.InterfaceRuleInterfaceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_interface_type"] = val

		val, err = v.InterfaceRuleInterfaceVrfName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_interface_vrf_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InterfaceRuleInterfacesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InterfaceRuleInterfacesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InterfaceRuleInterfacesValue) String() string {
	return "InterfaceRuleInterfacesValue"
}

func (v InterfaceRuleInterfacesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"interface_rule_interface_encap":    basetypes.StringType{},
		"interface_rule_interface_name":     basetypes.StringType{},
		"interface_rule_interface_type":     basetypes.StringType{},
		"interface_rule_interface_vrf_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface_rule_interface_encap":    v.InterfaceRuleInterfaceEncap,
			"interface_rule_interface_name":     v.InterfaceRuleInterfaceName,
			"interface_rule_interface_type":     v.InterfaceRuleInterfaceType,
			"interface_rule_interface_vrf_name": v.InterfaceRuleInterfaceVrfName,
		})

	return objVal, diags
}

func (v InterfaceRuleInterfacesValue) Equal(o attr.Value) bool {
	other, ok := o.(InterfaceRuleInterfacesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InterfaceRuleInterfaceEncap.Equal(other.InterfaceRuleInterfaceEncap) {
		return false
	}

	if !v.InterfaceRuleInterfaceName.Equal(other.InterfaceRuleInterfaceName) {
		return false
	}

	if !v.InterfaceRuleInterfaceType.Equal(other.InterfaceRuleInterfaceType) {
		return false
	}

	if !v.InterfaceRuleInterfaceVrfName.Equal(other.InterfaceRuleInterfaceVrfName) {
		return false
	}

	return true
}

func (v InterfaceRuleInterfacesValue) Type(ctx context.Context) attr.Type {
	return InterfaceRuleInterfacesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InterfaceRuleInterfacesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface_rule_interface_encap":    basetypes.StringType{},
		"interface_rule_interface_name":     basetypes.StringType{},
		"interface_rule_interface_type":     basetypes.StringType{},
		"interface_rule_interface_vrf_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = L3OutFlowRulesType{}

type L3OutFlowRulesType struct {
	basetypes.ObjectType
}

func (t L3OutFlowRulesType) Equal(o attr.Type) bool {
	other, ok := o.(L3OutFlowRulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t L3OutFlowRulesType) String() string {
	return "L3OutFlowRulesType"
}

func (t L3OutFlowRulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	l3OutFlowRuleInterfaceCollectionAttribute, ok := attributes["l3_out_flow_rule_interface_collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_interface_collection is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleInterfaceCollectionVal, ok := l3OutFlowRuleInterfaceCollectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_interface_collection expected to be basetypes.ListValue, was: %T`, l3OutFlowRuleInterfaceCollectionAttribute))
	}

	l3OutFlowRuleNameAttribute, ok := attributes["l3_out_flow_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_name is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleNameVal, ok := l3OutFlowRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_name expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleNameAttribute))
	}

	l3OutFlowRuleSubnetsAttribute, ok := attributes["l3_out_flow_rule_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_subnets is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleSubnetsVal, ok := l3OutFlowRuleSubnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_subnets expected to be basetypes.SetValue, was: %T`, l3OutFlowRuleSubnetsAttribute))
	}

	l3OutFlowRuleTypeAttribute, ok := attributes["l3_out_flow_rule_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_type is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleTypeVal, ok := l3OutFlowRuleTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_type expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleTypeAttribute))
	}

	l3OutFlowRuleUuidAttribute, ok := attributes["l3_out_flow_rule_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_uuid is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleUuidVal, ok := l3OutFlowRuleUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_uuid expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleUuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return L3OutFlowRulesValue{
		L3OutFlowRuleInterfaceCollection: l3OutFlowRuleInterfaceCollectionVal,
		L3OutFlowRuleName:                l3OutFlowRuleNameVal,
		L3OutFlowRuleSubnets:             l3OutFlowRuleSubnetsVal,
		L3OutFlowRuleType:                l3OutFlowRuleTypeVal,
		L3OutFlowRuleUuid:                l3OutFlowRuleUuidVal,
		state:                            attr.ValueStateKnown,
	}, diags
}

func NewL3OutFlowRulesValueNull() L3OutFlowRulesValue {
	return L3OutFlowRulesValue{
		state: attr.ValueStateNull,
	}
}

func NewL3OutFlowRulesValueUnknown() L3OutFlowRulesValue {
	return L3OutFlowRulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewL3OutFlowRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (L3OutFlowRulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing L3OutFlowRulesValue Attribute Value",
				"While creating a L3OutFlowRulesValue value, a missing attribute value was detected. "+
					"A L3OutFlowRulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L3OutFlowRulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid L3OutFlowRulesValue Attribute Type",
				"While creating a L3OutFlowRulesValue value, an invalid attribute value was detected. "+
					"A L3OutFlowRulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L3OutFlowRulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("L3OutFlowRulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra L3OutFlowRulesValue Attribute Value",
				"While creating a L3OutFlowRulesValue value, an extra attribute value was detected. "+
					"A L3OutFlowRulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra L3OutFlowRulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewL3OutFlowRulesValueUnknown(), diags
	}

	l3OutFlowRuleInterfaceCollectionAttribute, ok := attributes["l3_out_flow_rule_interface_collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_interface_collection is missing from object`)

		return NewL3OutFlowRulesValueUnknown(), diags
	}

	l3OutFlowRuleInterfaceCollectionVal, ok := l3OutFlowRuleInterfaceCollectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_interface_collection expected to be basetypes.ListValue, was: %T`, l3OutFlowRuleInterfaceCollectionAttribute))
	}

	l3OutFlowRuleNameAttribute, ok := attributes["l3_out_flow_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_name is missing from object`)

		return NewL3OutFlowRulesValueUnknown(), diags
	}

	l3OutFlowRuleNameVal, ok := l3OutFlowRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_name expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleNameAttribute))
	}

	l3OutFlowRuleSubnetsAttribute, ok := attributes["l3_out_flow_rule_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_subnets is missing from object`)

		return NewL3OutFlowRulesValueUnknown(), diags
	}

	l3OutFlowRuleSubnetsVal, ok := l3OutFlowRuleSubnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_subnets expected to be basetypes.SetValue, was: %T`, l3OutFlowRuleSubnetsAttribute))
	}

	l3OutFlowRuleTypeAttribute, ok := attributes["l3_out_flow_rule_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_type is missing from object`)

		return NewL3OutFlowRulesValueUnknown(), diags
	}

	l3OutFlowRuleTypeVal, ok := l3OutFlowRuleTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_type expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleTypeAttribute))
	}

	l3OutFlowRuleUuidAttribute, ok := attributes["l3_out_flow_rule_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_uuid is missing from object`)

		return NewL3OutFlowRulesValueUnknown(), diags
	}

	l3OutFlowRuleUuidVal, ok := l3OutFlowRuleUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_uuid expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleUuidAttribute))
	}

	if diags.HasError() {
		return NewL3OutFlowRulesValueUnknown(), diags
	}

	return L3OutFlowRulesValue{
		L3OutFlowRuleInterfaceCollection: l3OutFlowRuleInterfaceCollectionVal,
		L3OutFlowRuleName:                l3OutFlowRuleNameVal,
		L3OutFlowRuleSubnets:             l3OutFlowRuleSubnetsVal,
		L3OutFlowRuleType:                l3OutFlowRuleTypeVal,
		L3OutFlowRuleUuid:                l3OutFlowRuleUuidVal,
		state:                            attr.ValueStateKnown,
	}, diags
}

func NewL3OutFlowRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) L3OutFlowRulesValue {
	object, diags := NewL3OutFlowRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewL3OutFlowRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t L3OutFlowRulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewL3OutFlowRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewL3OutFlowRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewL3OutFlowRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewL3OutFlowRulesValueMust(L3OutFlowRulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t L3OutFlowRulesType) ValueType(ctx context.Context) attr.Value {
	return L3OutFlowRulesValue{}
}

var _ basetypes.ObjectValuable = L3OutFlowRulesValue{}

type L3OutFlowRulesValue struct {
	L3OutFlowRuleInterfaceCollection basetypes.ListValue   `tfsdk:"l3_out_flow_rule_interface_collection"`
	L3OutFlowRuleName                basetypes.StringValue `tfsdk:"l3_out_flow_rule_name"`
	L3OutFlowRuleSubnets             basetypes.SetValue    `tfsdk:"l3_out_flow_rule_subnets"`
	L3OutFlowRuleType                basetypes.StringValue `tfsdk:"l3_out_flow_rule_type"`
	L3OutFlowRuleUuid                basetypes.StringValue `tfsdk:"l3_out_flow_rule_uuid"`
	state                            attr.ValueState
}

func (v L3OutFlowRulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["l3_out_flow_rule_interface_collection"] = basetypes.ListType{
		ElemType: L3OutFlowRuleInterfaceCollectionValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_subnets"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.L3OutFlowRuleInterfaceCollection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_interface_collection"] = val

		val, err = v.L3OutFlowRuleName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_name"] = val

		val, err = v.L3OutFlowRuleSubnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_subnets"] = val

		val, err = v.L3OutFlowRuleType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_type"] = val

		val, err = v.L3OutFlowRuleUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v L3OutFlowRulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v L3OutFlowRulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v L3OutFlowRulesValue) String() string {
	return "L3OutFlowRulesValue"
}

func (v L3OutFlowRulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	l3OutFlowRuleInterfaceCollection := types.ListValueMust(
		L3OutFlowRuleInterfaceCollectionType{
			basetypes.ObjectType{
				AttrTypes: L3OutFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
			},
		},
		v.L3OutFlowRuleInterfaceCollection.Elements(),
	)

	if v.L3OutFlowRuleInterfaceCollection.IsNull() {
		l3OutFlowRuleInterfaceCollection = types.ListNull(
			L3OutFlowRuleInterfaceCollectionType{
				basetypes.ObjectType{
					AttrTypes: L3OutFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.L3OutFlowRuleInterfaceCollection.IsUnknown() {
		l3OutFlowRuleInterfaceCollection = types.ListUnknown(
			L3OutFlowRuleInterfaceCollectionType{
				basetypes.ObjectType{
					AttrTypes: L3OutFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var l3OutFlowRuleSubnetsVal basetypes.SetValue
	switch {
	case v.L3OutFlowRuleSubnets.IsUnknown():
		l3OutFlowRuleSubnetsVal = types.SetUnknown(types.StringType)
	case v.L3OutFlowRuleSubnets.IsNull():
		l3OutFlowRuleSubnetsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		l3OutFlowRuleSubnetsVal, d = types.SetValue(types.StringType, v.L3OutFlowRuleSubnets.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"l3_out_flow_rule_interface_collection": basetypes.ListType{
				ElemType: L3OutFlowRuleInterfaceCollectionValue{}.Type(ctx),
			},
			"l3_out_flow_rule_name": basetypes.StringType{},
			"l3_out_flow_rule_subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"l3_out_flow_rule_type": basetypes.StringType{},
			"l3_out_flow_rule_uuid": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"l3_out_flow_rule_interface_collection": basetypes.ListType{
			ElemType: L3OutFlowRuleInterfaceCollectionValue{}.Type(ctx),
		},
		"l3_out_flow_rule_name": basetypes.StringType{},
		"l3_out_flow_rule_subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"l3_out_flow_rule_type": basetypes.StringType{},
		"l3_out_flow_rule_uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"l3_out_flow_rule_interface_collection": l3OutFlowRuleInterfaceCollection,
			"l3_out_flow_rule_name":                 v.L3OutFlowRuleName,
			"l3_out_flow_rule_subnets":              l3OutFlowRuleSubnetsVal,
			"l3_out_flow_rule_type":                 v.L3OutFlowRuleType,
			"l3_out_flow_rule_uuid":                 v.L3OutFlowRuleUuid,
		})

	return objVal, diags
}

func (v L3OutFlowRulesValue) Equal(o attr.Value) bool {
	other, ok := o.(L3OutFlowRulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.L3OutFlowRuleInterfaceCollection.Equal(other.L3OutFlowRuleInterfaceCollection) {
		return false
	}

	if !v.L3OutFlowRuleName.Equal(other.L3OutFlowRuleName) {
		return false
	}

	if !v.L3OutFlowRuleSubnets.Equal(other.L3OutFlowRuleSubnets) {
		return false
	}

	if !v.L3OutFlowRuleType.Equal(other.L3OutFlowRuleType) {
		return false
	}

	if !v.L3OutFlowRuleUuid.Equal(other.L3OutFlowRuleUuid) {
		return false
	}

	return true
}

func (v L3OutFlowRulesValue) Type(ctx context.Context) attr.Type {
	return L3OutFlowRulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v L3OutFlowRulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"l3_out_flow_rule_interface_collection": basetypes.ListType{
			ElemType: L3OutFlowRuleInterfaceCollectionValue{}.Type(ctx),
		},
		"l3_out_flow_rule_name": basetypes.StringType{},
		"l3_out_flow_rule_subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"l3_out_flow_rule_type": basetypes.StringType{},
		"l3_out_flow_rule_uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = L3OutFlowRuleInterfaceCollectionType{}

type L3OutFlowRuleInterfaceCollectionType struct {
	basetypes.ObjectType
}

func (t L3OutFlowRuleInterfaceCollectionType) Equal(o attr.Type) bool {
	other, ok := o.(L3OutFlowRuleInterfaceCollectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t L3OutFlowRuleInterfaceCollectionType) String() string {
	return "L3OutFlowRuleInterfaceCollectionType"
}

func (t L3OutFlowRuleInterfaceCollectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	l3OutFlowRuleEncapAttribute, ok := attributes["l3_out_flow_rule_encap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_encap is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleEncapVal, ok := l3OutFlowRuleEncapAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_encap expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleEncapAttribute))
	}

	l3OutFlowRuleInterfacesAttribute, ok := attributes["l3_out_flow_rule_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_interfaces is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleInterfacesVal, ok := l3OutFlowRuleInterfacesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_interfaces expected to be basetypes.SetValue, was: %T`, l3OutFlowRuleInterfacesAttribute))
	}

	l3OutFlowRuleL3OutAttribute, ok := attributes["l3_out_flow_rule_l3_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_l3_out is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleL3OutVal, ok := l3OutFlowRuleL3OutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_l3_out expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleL3OutAttribute))
	}

	l3OutFlowRuleSwitchIdAttribute, ok := attributes["l3_out_flow_rule_switch_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_switch_id is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleSwitchIdVal, ok := l3OutFlowRuleSwitchIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_switch_id expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleSwitchIdAttribute))
	}

	l3OutFlowRuleSwitchNameAttribute, ok := attributes["l3_out_flow_rule_switch_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_switch_name is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleSwitchNameVal, ok := l3OutFlowRuleSwitchNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_switch_name expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleSwitchNameAttribute))
	}

	l3OutFlowRuleTenantAttribute, ok := attributes["l3_out_flow_rule_tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_tenant is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleTenantVal, ok := l3OutFlowRuleTenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_tenant expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleTenantAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return L3OutFlowRuleInterfaceCollectionValue{
		L3OutFlowRuleEncap:      l3OutFlowRuleEncapVal,
		L3OutFlowRuleInterfaces: l3OutFlowRuleInterfacesVal,
		L3OutFlowRuleL3Out:      l3OutFlowRuleL3OutVal,
		L3OutFlowRuleSwitchId:   l3OutFlowRuleSwitchIdVal,
		L3OutFlowRuleSwitchName: l3OutFlowRuleSwitchNameVal,
		L3OutFlowRuleTenant:     l3OutFlowRuleTenantVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewL3OutFlowRuleInterfaceCollectionValueNull() L3OutFlowRuleInterfaceCollectionValue {
	return L3OutFlowRuleInterfaceCollectionValue{
		state: attr.ValueStateNull,
	}
}

func NewL3OutFlowRuleInterfaceCollectionValueUnknown() L3OutFlowRuleInterfaceCollectionValue {
	return L3OutFlowRuleInterfaceCollectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewL3OutFlowRuleInterfaceCollectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (L3OutFlowRuleInterfaceCollectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing L3OutFlowRuleInterfaceCollectionValue Attribute Value",
				"While creating a L3OutFlowRuleInterfaceCollectionValue value, a missing attribute value was detected. "+
					"A L3OutFlowRuleInterfaceCollectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L3OutFlowRuleInterfaceCollectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid L3OutFlowRuleInterfaceCollectionValue Attribute Type",
				"While creating a L3OutFlowRuleInterfaceCollectionValue value, an invalid attribute value was detected. "+
					"A L3OutFlowRuleInterfaceCollectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L3OutFlowRuleInterfaceCollectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("L3OutFlowRuleInterfaceCollectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra L3OutFlowRuleInterfaceCollectionValue Attribute Value",
				"While creating a L3OutFlowRuleInterfaceCollectionValue value, an extra attribute value was detected. "+
					"A L3OutFlowRuleInterfaceCollectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra L3OutFlowRuleInterfaceCollectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	l3OutFlowRuleEncapAttribute, ok := attributes["l3_out_flow_rule_encap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_encap is missing from object`)

		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	l3OutFlowRuleEncapVal, ok := l3OutFlowRuleEncapAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_encap expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleEncapAttribute))
	}

	l3OutFlowRuleInterfacesAttribute, ok := attributes["l3_out_flow_rule_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_interfaces is missing from object`)

		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	l3OutFlowRuleInterfacesVal, ok := l3OutFlowRuleInterfacesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_interfaces expected to be basetypes.SetValue, was: %T`, l3OutFlowRuleInterfacesAttribute))
	}

	l3OutFlowRuleL3OutAttribute, ok := attributes["l3_out_flow_rule_l3_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_l3_out is missing from object`)

		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	l3OutFlowRuleL3OutVal, ok := l3OutFlowRuleL3OutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_l3_out expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleL3OutAttribute))
	}

	l3OutFlowRuleSwitchIdAttribute, ok := attributes["l3_out_flow_rule_switch_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_switch_id is missing from object`)

		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	l3OutFlowRuleSwitchIdVal, ok := l3OutFlowRuleSwitchIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_switch_id expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleSwitchIdAttribute))
	}

	l3OutFlowRuleSwitchNameAttribute, ok := attributes["l3_out_flow_rule_switch_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_switch_name is missing from object`)

		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	l3OutFlowRuleSwitchNameVal, ok := l3OutFlowRuleSwitchNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_switch_name expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleSwitchNameAttribute))
	}

	l3OutFlowRuleTenantAttribute, ok := attributes["l3_out_flow_rule_tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_tenant is missing from object`)

		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	l3OutFlowRuleTenantVal, ok := l3OutFlowRuleTenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_tenant expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleTenantAttribute))
	}

	if diags.HasError() {
		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	return L3OutFlowRuleInterfaceCollectionValue{
		L3OutFlowRuleEncap:      l3OutFlowRuleEncapVal,
		L3OutFlowRuleInterfaces: l3OutFlowRuleInterfacesVal,
		L3OutFlowRuleL3Out:      l3OutFlowRuleL3OutVal,
		L3OutFlowRuleSwitchId:   l3OutFlowRuleSwitchIdVal,
		L3OutFlowRuleSwitchName: l3OutFlowRuleSwitchNameVal,
		L3OutFlowRuleTenant:     l3OutFlowRuleTenantVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewL3OutFlowRuleInterfaceCollectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) L3OutFlowRuleInterfaceCollectionValue {
	object, diags := NewL3OutFlowRuleInterfaceCollectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewL3OutFlowRuleInterfaceCollectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t L3OutFlowRuleInterfaceCollectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewL3OutFlowRuleInterfaceCollectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewL3OutFlowRuleInterfaceCollectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewL3OutFlowRuleInterfaceCollectionValueMust(L3OutFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t L3OutFlowRuleInterfaceCollectionType) ValueType(ctx context.Context) attr.Value {
	return L3OutFlowRuleInterfaceCollectionValue{}
}

var _ basetypes.ObjectValuable = L3OutFlowRuleInterfaceCollectionValue{}

type L3OutFlowRuleInterfaceCollectionValue struct {
	L3OutFlowRuleEncap      basetypes.StringValue `tfsdk:"l3_out_flow_rule_encap"`
	L3OutFlowRuleInterfaces basetypes.SetValue    `tfsdk:"l3_out_flow_rule_interfaces"`
	L3OutFlowRuleL3Out      basetypes.StringValue `tfsdk:"l3_out_flow_rule_l3_out"`
	L3OutFlowRuleSwitchId   basetypes.StringValue `tfsdk:"l3_out_flow_rule_switch_id"`
	L3OutFlowRuleSwitchName basetypes.StringValue `tfsdk:"l3_out_flow_rule_switch_name"`
	L3OutFlowRuleTenant     basetypes.StringValue `tfsdk:"l3_out_flow_rule_tenant"`
	state                   attr.ValueState
}

func (v L3OutFlowRuleInterfaceCollectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["l3_out_flow_rule_encap"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_interfaces"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_l3_out"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_switch_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_switch_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_tenant"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.L3OutFlowRuleEncap.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_encap"] = val

		val, err = v.L3OutFlowRuleInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_interfaces"] = val

		val, err = v.L3OutFlowRuleL3Out.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_l3_out"] = val

		val, err = v.L3OutFlowRuleSwitchId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_switch_id"] = val

		val, err = v.L3OutFlowRuleSwitchName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_switch_name"] = val

		val, err = v.L3OutFlowRuleTenant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_tenant"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v L3OutFlowRuleInterfaceCollectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v L3OutFlowRuleInterfaceCollectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v L3OutFlowRuleInterfaceCollectionValue) String() string {
	return "L3OutFlowRuleInterfaceCollectionValue"
}

func (v L3OutFlowRuleInterfaceCollectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var l3OutFlowRuleInterfacesVal basetypes.SetValue
	switch {
	case v.L3OutFlowRuleInterfaces.IsUnknown():
		l3OutFlowRuleInterfacesVal = types.SetUnknown(types.StringType)
	case v.L3OutFlowRuleInterfaces.IsNull():
		l3OutFlowRuleInterfacesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		l3OutFlowRuleInterfacesVal, d = types.SetValue(types.StringType, v.L3OutFlowRuleInterfaces.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"l3_out_flow_rule_encap": basetypes.StringType{},
			"l3_out_flow_rule_interfaces": basetypes.SetType{
				ElemType: types.StringType,
			},
			"l3_out_flow_rule_l3_out":      basetypes.StringType{},
			"l3_out_flow_rule_switch_id":   basetypes.StringType{},
			"l3_out_flow_rule_switch_name": basetypes.StringType{},
			"l3_out_flow_rule_tenant":      basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"l3_out_flow_rule_encap": basetypes.StringType{},
		"l3_out_flow_rule_interfaces": basetypes.SetType{
			ElemType: types.StringType,
		},
		"l3_out_flow_rule_l3_out":      basetypes.StringType{},
		"l3_out_flow_rule_switch_id":   basetypes.StringType{},
		"l3_out_flow_rule_switch_name": basetypes.StringType{},
		"l3_out_flow_rule_tenant":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"l3_out_flow_rule_encap":       v.L3OutFlowRuleEncap,
			"l3_out_flow_rule_interfaces":  l3OutFlowRuleInterfacesVal,
			"l3_out_flow_rule_l3_out":      v.L3OutFlowRuleL3Out,
			"l3_out_flow_rule_switch_id":   v.L3OutFlowRuleSwitchId,
			"l3_out_flow_rule_switch_name": v.L3OutFlowRuleSwitchName,
			"l3_out_flow_rule_tenant":      v.L3OutFlowRuleTenant,
		})

	return objVal, diags
}

func (v L3OutFlowRuleInterfaceCollectionValue) Equal(o attr.Value) bool {
	other, ok := o.(L3OutFlowRuleInterfaceCollectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.L3OutFlowRuleEncap.Equal(other.L3OutFlowRuleEncap) {
		return false
	}

	if !v.L3OutFlowRuleInterfaces.Equal(other.L3OutFlowRuleInterfaces) {
		return false
	}

	if !v.L3OutFlowRuleL3Out.Equal(other.L3OutFlowRuleL3Out) {
		return false
	}

	if !v.L3OutFlowRuleSwitchId.Equal(other.L3OutFlowRuleSwitchId) {
		return false
	}

	if !v.L3OutFlowRuleSwitchName.Equal(other.L3OutFlowRuleSwitchName) {
		return false
	}

	if !v.L3OutFlowRuleTenant.Equal(other.L3OutFlowRuleTenant) {
		return false
	}

	return true
}

func (v L3OutFlowRuleInterfaceCollectionValue) Type(ctx context.Context) attr.Type {
	return L3OutFlowRuleInterfaceCollectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v L3OutFlowRuleInterfaceCollectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"l3_out_flow_rule_encap": basetypes.StringType{},
		"l3_out_flow_rule_interfaces": basetypes.SetType{
			ElemType: types.StringType,
		},
		"l3_out_flow_rule_l3_out":      basetypes.StringType{},
		"l3_out_flow_rule_switch_id":   basetypes.StringType{},
		"l3_out_flow_rule_switch_name": basetypes.StringType{},
		"l3_out_flow_rule_tenant":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LocationType{}

type LocationType struct {
	basetypes.ObjectType
}

func (t LocationType) Equal(o attr.Type) bool {
	other, ok := o.(LocationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LocationType) String() string {
	return "LocationType"
}

func (t LocationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	latitudeAttribute, ok := attributes["latitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latitude is missing from object`)

		return nil, diags
	}

	latitudeVal, ok := latitudeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latitude expected to be basetypes.Float64Value, was: %T`, latitudeAttribute))
	}

	longitudeAttribute, ok := attributes["longitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`longitude is missing from object`)

		return nil, diags
	}

	longitudeVal, ok := longitudeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`longitude expected to be basetypes.Float64Value, was: %T`, longitudeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LocationValue{
		Latitude:  latitudeVal,
		Longitude: longitudeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewLocationValueNull() LocationValue {
	return LocationValue{
		state: attr.ValueStateNull,
	}
}

func NewLocationValueUnknown() LocationValue {
	return LocationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLocationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LocationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LocationValue Attribute Value",
				"While creating a LocationValue value, a missing attribute value was detected. "+
					"A LocationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LocationValue Attribute Type",
				"While creating a LocationValue value, an invalid attribute value was detected. "+
					"A LocationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LocationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LocationValue Attribute Value",
				"While creating a LocationValue value, an extra attribute value was detected. "+
					"A LocationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LocationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLocationValueUnknown(), diags
	}

	latitudeAttribute, ok := attributes["latitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latitude is missing from object`)

		return NewLocationValueUnknown(), diags
	}

	latitudeVal, ok := latitudeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latitude expected to be basetypes.Float64Value, was: %T`, latitudeAttribute))
	}

	longitudeAttribute, ok := attributes["longitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`longitude is missing from object`)

		return NewLocationValueUnknown(), diags
	}

	longitudeVal, ok := longitudeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`longitude expected to be basetypes.Float64Value, was: %T`, longitudeAttribute))
	}

	if diags.HasError() {
		return NewLocationValueUnknown(), diags
	}

	return LocationValue{
		Latitude:  latitudeVal,
		Longitude: longitudeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewLocationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LocationValue {
	object, diags := NewLocationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLocationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LocationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLocationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLocationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLocationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLocationValueMust(LocationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LocationType) ValueType(ctx context.Context) attr.Value {
	return LocationValue{}
}

var _ basetypes.ObjectValuable = LocationValue{}

type LocationValue struct {
	Latitude  basetypes.Float64Value `tfsdk:"latitude"`
	Longitude basetypes.Float64Value `tfsdk:"longitude"`
	state     attr.ValueState
}

func (v LocationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["latitude"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["longitude"] = basetypes.Float64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Latitude.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["latitude"] = val

		val, err = v.Longitude.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["longitude"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LocationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LocationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LocationValue) String() string {
	return "LocationValue"
}

func (v LocationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"latitude":  basetypes.Float64Type{},
		"longitude": basetypes.Float64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"latitude":  v.Latitude,
			"longitude": v.Longitude,
		})

	return objVal, diags
}

func (v LocationValue) Equal(o attr.Value) bool {
	other, ok := o.(LocationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Latitude.Equal(other.Latitude) {
		return false
	}

	if !v.Longitude.Equal(other.Longitude) {
		return false
	}

	return true
}

func (v LocationValue) Type(ctx context.Context) attr.Type {
	return LocationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LocationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"latitude":  basetypes.Float64Type{},
		"longitude": basetypes.Float64Type{},
	}
}

var _ basetypes.ObjectTypable = MessageBusType{}

type MessageBusType struct {
	basetypes.ObjectType
}

func (t MessageBusType) Equal(o attr.Type) bool {
	other, ok := o.(MessageBusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MessageBusType) String() string {
	return "MessageBusType"
}

func (t MessageBusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advisoriesAttribute, ok := attributes["advisories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advisories is missing from object`)

		return nil, diags
	}

	advisoriesVal, ok := advisoriesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advisories expected to be basetypes.SetValue, was: %T`, advisoriesAttribute))
	}

	anomaliesAttribute, ok := attributes["anomalies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anomalies is missing from object`)

		return nil, diags
	}

	anomaliesVal, ok := anomaliesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anomalies expected to be basetypes.SetValue, was: %T`, anomaliesAttribute))
	}

	auditLogsAttribute, ok := attributes["audit_logs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`audit_logs is missing from object`)

		return nil, diags
	}

	auditLogsVal, ok := auditLogsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`audit_logs expected to be basetypes.SetValue, was: %T`, auditLogsAttribute))
	}

	collectionSettingsCollectionTypeAttribute, ok := attributes["collection_settings_collection_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_settings_collection_type is missing from object`)

		return nil, diags
	}

	collectionSettingsCollectionTypeVal, ok := collectionSettingsCollectionTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_settings_collection_type expected to be basetypes.StringValue, was: %T`, collectionSettingsCollectionTypeAttribute))
	}

	collectionTypeAttribute, ok := attributes["collection_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_type is missing from object`)

		return nil, diags
	}

	collectionTypeVal, ok := collectionTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_type expected to be basetypes.StringValue, was: %T`, collectionTypeAttribute))
	}

	faultsAttribute, ok := attributes["faults"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`faults is missing from object`)

		return nil, diags
	}

	faultsVal, ok := faultsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`faults expected to be basetypes.SetValue, was: %T`, faultsAttribute))
	}

	serverAttribute, ok := attributes["server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server is missing from object`)

		return nil, diags
	}

	serverVal, ok := serverAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server expected to be basetypes.StringValue, was: %T`, serverAttribute))
	}

	statisticsAttribute, ok := attributes["statistics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statistics is missing from object`)

		return nil, diags
	}

	statisticsVal, ok := statisticsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statistics expected to be basetypes.SetValue, was: %T`, statisticsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MessageBusValue{
		Advisories:                       advisoriesVal,
		Anomalies:                        anomaliesVal,
		AuditLogs:                        auditLogsVal,
		CollectionSettingsCollectionType: collectionSettingsCollectionTypeVal,
		CollectionType:                   collectionTypeVal,
		Faults:                           faultsVal,
		Server:                           serverVal,
		Statistics:                       statisticsVal,
		state:                            attr.ValueStateKnown,
	}, diags
}

func NewMessageBusValueNull() MessageBusValue {
	return MessageBusValue{
		state: attr.ValueStateNull,
	}
}

func NewMessageBusValueUnknown() MessageBusValue {
	return MessageBusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMessageBusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MessageBusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MessageBusValue Attribute Value",
				"While creating a MessageBusValue value, a missing attribute value was detected. "+
					"A MessageBusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MessageBusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MessageBusValue Attribute Type",
				"While creating a MessageBusValue value, an invalid attribute value was detected. "+
					"A MessageBusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MessageBusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MessageBusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MessageBusValue Attribute Value",
				"While creating a MessageBusValue value, an extra attribute value was detected. "+
					"A MessageBusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MessageBusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMessageBusValueUnknown(), diags
	}

	advisoriesAttribute, ok := attributes["advisories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advisories is missing from object`)

		return NewMessageBusValueUnknown(), diags
	}

	advisoriesVal, ok := advisoriesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advisories expected to be basetypes.SetValue, was: %T`, advisoriesAttribute))
	}

	anomaliesAttribute, ok := attributes["anomalies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anomalies is missing from object`)

		return NewMessageBusValueUnknown(), diags
	}

	anomaliesVal, ok := anomaliesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anomalies expected to be basetypes.SetValue, was: %T`, anomaliesAttribute))
	}

	auditLogsAttribute, ok := attributes["audit_logs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`audit_logs is missing from object`)

		return NewMessageBusValueUnknown(), diags
	}

	auditLogsVal, ok := auditLogsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`audit_logs expected to be basetypes.SetValue, was: %T`, auditLogsAttribute))
	}

	collectionSettingsCollectionTypeAttribute, ok := attributes["collection_settings_collection_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_settings_collection_type is missing from object`)

		return NewMessageBusValueUnknown(), diags
	}

	collectionSettingsCollectionTypeVal, ok := collectionSettingsCollectionTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_settings_collection_type expected to be basetypes.StringValue, was: %T`, collectionSettingsCollectionTypeAttribute))
	}

	collectionTypeAttribute, ok := attributes["collection_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_type is missing from object`)

		return NewMessageBusValueUnknown(), diags
	}

	collectionTypeVal, ok := collectionTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_type expected to be basetypes.StringValue, was: %T`, collectionTypeAttribute))
	}

	faultsAttribute, ok := attributes["faults"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`faults is missing from object`)

		return NewMessageBusValueUnknown(), diags
	}

	faultsVal, ok := faultsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`faults expected to be basetypes.SetValue, was: %T`, faultsAttribute))
	}

	serverAttribute, ok := attributes["server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server is missing from object`)

		return NewMessageBusValueUnknown(), diags
	}

	serverVal, ok := serverAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server expected to be basetypes.StringValue, was: %T`, serverAttribute))
	}

	statisticsAttribute, ok := attributes["statistics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statistics is missing from object`)

		return NewMessageBusValueUnknown(), diags
	}

	statisticsVal, ok := statisticsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statistics expected to be basetypes.SetValue, was: %T`, statisticsAttribute))
	}

	if diags.HasError() {
		return NewMessageBusValueUnknown(), diags
	}

	return MessageBusValue{
		Advisories:                       advisoriesVal,
		Anomalies:                        anomaliesVal,
		AuditLogs:                        auditLogsVal,
		CollectionSettingsCollectionType: collectionSettingsCollectionTypeVal,
		CollectionType:                   collectionTypeVal,
		Faults:                           faultsVal,
		Server:                           serverVal,
		Statistics:                       statisticsVal,
		state:                            attr.ValueStateKnown,
	}, diags
}

func NewMessageBusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MessageBusValue {
	object, diags := NewMessageBusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMessageBusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MessageBusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMessageBusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMessageBusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMessageBusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMessageBusValueMust(MessageBusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MessageBusType) ValueType(ctx context.Context) attr.Value {
	return MessageBusValue{}
}

var _ basetypes.ObjectValuable = MessageBusValue{}

type MessageBusValue struct {
	Advisories                       basetypes.SetValue    `tfsdk:"advisories"`
	Anomalies                        basetypes.SetValue    `tfsdk:"anomalies"`
	AuditLogs                        basetypes.SetValue    `tfsdk:"audit_logs"`
	CollectionSettingsCollectionType basetypes.StringValue `tfsdk:"collection_settings_collection_type"`
	CollectionType                   basetypes.StringValue `tfsdk:"collection_type"`
	Faults                           basetypes.SetValue    `tfsdk:"faults"`
	Server                           basetypes.StringValue `tfsdk:"server"`
	Statistics                       basetypes.SetValue    `tfsdk:"statistics"`
	state                            attr.ValueState
}

func (v MessageBusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["advisories"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["anomalies"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["audit_logs"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["collection_settings_collection_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["collection_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["faults"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["server"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["statistics"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Advisories.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advisories"] = val

		val, err = v.Anomalies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["anomalies"] = val

		val, err = v.AuditLogs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["audit_logs"] = val

		val, err = v.CollectionSettingsCollectionType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection_settings_collection_type"] = val

		val, err = v.CollectionType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection_type"] = val

		val, err = v.Faults.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["faults"] = val

		val, err = v.Server.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server"] = val

		val, err = v.Statistics.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["statistics"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MessageBusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MessageBusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MessageBusValue) String() string {
	return "MessageBusValue"
}

func (v MessageBusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var advisoriesVal basetypes.SetValue
	switch {
	case v.Advisories.IsUnknown():
		advisoriesVal = types.SetUnknown(types.StringType)
	case v.Advisories.IsNull():
		advisoriesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		advisoriesVal, d = types.SetValue(types.StringType, v.Advisories.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advisories": basetypes.SetType{
				ElemType: types.StringType,
			},
			"anomalies": basetypes.SetType{
				ElemType: types.StringType,
			},
			"audit_logs": basetypes.SetType{
				ElemType: types.StringType,
			},
			"collection_settings_collection_type": basetypes.StringType{},
			"collection_type":                     basetypes.StringType{},
			"faults": basetypes.SetType{
				ElemType: types.StringType,
			},
			"server": basetypes.StringType{},
			"statistics": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var anomaliesVal basetypes.SetValue
	switch {
	case v.Anomalies.IsUnknown():
		anomaliesVal = types.SetUnknown(types.StringType)
	case v.Anomalies.IsNull():
		anomaliesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		anomaliesVal, d = types.SetValue(types.StringType, v.Anomalies.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advisories": basetypes.SetType{
				ElemType: types.StringType,
			},
			"anomalies": basetypes.SetType{
				ElemType: types.StringType,
			},
			"audit_logs": basetypes.SetType{
				ElemType: types.StringType,
			},
			"collection_settings_collection_type": basetypes.StringType{},
			"collection_type":                     basetypes.StringType{},
			"faults": basetypes.SetType{
				ElemType: types.StringType,
			},
			"server": basetypes.StringType{},
			"statistics": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var auditLogsVal basetypes.SetValue
	switch {
	case v.AuditLogs.IsUnknown():
		auditLogsVal = types.SetUnknown(types.StringType)
	case v.AuditLogs.IsNull():
		auditLogsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		auditLogsVal, d = types.SetValue(types.StringType, v.AuditLogs.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advisories": basetypes.SetType{
				ElemType: types.StringType,
			},
			"anomalies": basetypes.SetType{
				ElemType: types.StringType,
			},
			"audit_logs": basetypes.SetType{
				ElemType: types.StringType,
			},
			"collection_settings_collection_type": basetypes.StringType{},
			"collection_type":                     basetypes.StringType{},
			"faults": basetypes.SetType{
				ElemType: types.StringType,
			},
			"server": basetypes.StringType{},
			"statistics": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var faultsVal basetypes.SetValue
	switch {
	case v.Faults.IsUnknown():
		faultsVal = types.SetUnknown(types.StringType)
	case v.Faults.IsNull():
		faultsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		faultsVal, d = types.SetValue(types.StringType, v.Faults.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advisories": basetypes.SetType{
				ElemType: types.StringType,
			},
			"anomalies": basetypes.SetType{
				ElemType: types.StringType,
			},
			"audit_logs": basetypes.SetType{
				ElemType: types.StringType,
			},
			"collection_settings_collection_type": basetypes.StringType{},
			"collection_type":                     basetypes.StringType{},
			"faults": basetypes.SetType{
				ElemType: types.StringType,
			},
			"server": basetypes.StringType{},
			"statistics": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var statisticsVal basetypes.SetValue
	switch {
	case v.Statistics.IsUnknown():
		statisticsVal = types.SetUnknown(types.StringType)
	case v.Statistics.IsNull():
		statisticsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		statisticsVal, d = types.SetValue(types.StringType, v.Statistics.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advisories": basetypes.SetType{
				ElemType: types.StringType,
			},
			"anomalies": basetypes.SetType{
				ElemType: types.StringType,
			},
			"audit_logs": basetypes.SetType{
				ElemType: types.StringType,
			},
			"collection_settings_collection_type": basetypes.StringType{},
			"collection_type":                     basetypes.StringType{},
			"faults": basetypes.SetType{
				ElemType: types.StringType,
			},
			"server": basetypes.StringType{},
			"statistics": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"advisories": basetypes.SetType{
			ElemType: types.StringType,
		},
		"anomalies": basetypes.SetType{
			ElemType: types.StringType,
		},
		"audit_logs": basetypes.SetType{
			ElemType: types.StringType,
		},
		"collection_settings_collection_type": basetypes.StringType{},
		"collection_type":                     basetypes.StringType{},
		"faults": basetypes.SetType{
			ElemType: types.StringType,
		},
		"server": basetypes.StringType{},
		"statistics": basetypes.SetType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advisories":                          advisoriesVal,
			"anomalies":                           anomaliesVal,
			"audit_logs":                          auditLogsVal,
			"collection_settings_collection_type": v.CollectionSettingsCollectionType,
			"collection_type":                     v.CollectionType,
			"faults":                              faultsVal,
			"server":                              v.Server,
			"statistics":                          statisticsVal,
		})

	return objVal, diags
}

func (v MessageBusValue) Equal(o attr.Value) bool {
	other, ok := o.(MessageBusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Advisories.Equal(other.Advisories) {
		return false
	}

	if !v.Anomalies.Equal(other.Anomalies) {
		return false
	}

	if !v.AuditLogs.Equal(other.AuditLogs) {
		return false
	}

	if !v.CollectionSettingsCollectionType.Equal(other.CollectionSettingsCollectionType) {
		return false
	}

	if !v.CollectionType.Equal(other.CollectionType) {
		return false
	}

	if !v.Faults.Equal(other.Faults) {
		return false
	}

	if !v.Server.Equal(other.Server) {
		return false
	}

	if !v.Statistics.Equal(other.Statistics) {
		return false
	}

	return true
}

func (v MessageBusValue) Type(ctx context.Context) attr.Type {
	return MessageBusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MessageBusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advisories": basetypes.SetType{
			ElemType: types.StringType,
		},
		"anomalies": basetypes.SetType{
			ElemType: types.StringType,
		},
		"audit_logs": basetypes.SetType{
			ElemType: types.StringType,
		},
		"collection_settings_collection_type": basetypes.StringType{},
		"collection_type":                     basetypes.StringType{},
		"faults": basetypes.SetType{
			ElemType: types.StringType,
		},
		"server": basetypes.StringType{},
		"statistics": basetypes.SetType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = NetflowExporterCollectionType{}

type NetflowExporterCollectionType struct {
	basetypes.ObjectType
}

func (t NetflowExporterCollectionType) Equal(o attr.Type) bool {
	other, ok := o.(NetflowExporterCollectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetflowExporterCollectionType) String() string {
	return "NetflowExporterCollectionType"
}

func (t NetflowExporterCollectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	exporterIpAttribute, ok := attributes["exporter_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exporter_ip is missing from object`)

		return nil, diags
	}

	exporterIpVal, ok := exporterIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exporter_ip expected to be basetypes.StringValue, was: %T`, exporterIpAttribute))
	}

	exporterNameAttribute, ok := attributes["exporter_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exporter_name is missing from object`)

		return nil, diags
	}

	exporterNameVal, ok := exporterNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exporter_name expected to be basetypes.StringValue, was: %T`, exporterNameAttribute))
	}

	sourceInterfaceNameAttribute, ok := attributes["source_interface_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_interface_name is missing from object`)

		return nil, diags
	}

	sourceInterfaceNameVal, ok := sourceInterfaceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_interface_name expected to be basetypes.StringValue, was: %T`, sourceInterfaceNameAttribute))
	}

	udpPortAttribute, ok := attributes["udp_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`udp_port is missing from object`)

		return nil, diags
	}

	udpPortVal, ok := udpPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`udp_port expected to be basetypes.Int64Value, was: %T`, udpPortAttribute))
	}

	vrfAttribute, ok := attributes["vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf is missing from object`)

		return nil, diags
	}

	vrfVal, ok := vrfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf expected to be basetypes.StringValue, was: %T`, vrfAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetflowExporterCollectionValue{
		ExporterIp:          exporterIpVal,
		ExporterName:        exporterNameVal,
		SourceInterfaceName: sourceInterfaceNameVal,
		UdpPort:             udpPortVal,
		Vrf:                 vrfVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewNetflowExporterCollectionValueNull() NetflowExporterCollectionValue {
	return NetflowExporterCollectionValue{
		state: attr.ValueStateNull,
	}
}

func NewNetflowExporterCollectionValueUnknown() NetflowExporterCollectionValue {
	return NetflowExporterCollectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetflowExporterCollectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetflowExporterCollectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetflowExporterCollectionValue Attribute Value",
				"While creating a NetflowExporterCollectionValue value, a missing attribute value was detected. "+
					"A NetflowExporterCollectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetflowExporterCollectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetflowExporterCollectionValue Attribute Type",
				"While creating a NetflowExporterCollectionValue value, an invalid attribute value was detected. "+
					"A NetflowExporterCollectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetflowExporterCollectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetflowExporterCollectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetflowExporterCollectionValue Attribute Value",
				"While creating a NetflowExporterCollectionValue value, an extra attribute value was detected. "+
					"A NetflowExporterCollectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetflowExporterCollectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetflowExporterCollectionValueUnknown(), diags
	}

	exporterIpAttribute, ok := attributes["exporter_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exporter_ip is missing from object`)

		return NewNetflowExporterCollectionValueUnknown(), diags
	}

	exporterIpVal, ok := exporterIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exporter_ip expected to be basetypes.StringValue, was: %T`, exporterIpAttribute))
	}

	exporterNameAttribute, ok := attributes["exporter_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exporter_name is missing from object`)

		return NewNetflowExporterCollectionValueUnknown(), diags
	}

	exporterNameVal, ok := exporterNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exporter_name expected to be basetypes.StringValue, was: %T`, exporterNameAttribute))
	}

	sourceInterfaceNameAttribute, ok := attributes["source_interface_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_interface_name is missing from object`)

		return NewNetflowExporterCollectionValueUnknown(), diags
	}

	sourceInterfaceNameVal, ok := sourceInterfaceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_interface_name expected to be basetypes.StringValue, was: %T`, sourceInterfaceNameAttribute))
	}

	udpPortAttribute, ok := attributes["udp_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`udp_port is missing from object`)

		return NewNetflowExporterCollectionValueUnknown(), diags
	}

	udpPortVal, ok := udpPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`udp_port expected to be basetypes.Int64Value, was: %T`, udpPortAttribute))
	}

	vrfAttribute, ok := attributes["vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf is missing from object`)

		return NewNetflowExporterCollectionValueUnknown(), diags
	}

	vrfVal, ok := vrfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf expected to be basetypes.StringValue, was: %T`, vrfAttribute))
	}

	if diags.HasError() {
		return NewNetflowExporterCollectionValueUnknown(), diags
	}

	return NetflowExporterCollectionValue{
		ExporterIp:          exporterIpVal,
		ExporterName:        exporterNameVal,
		SourceInterfaceName: sourceInterfaceNameVal,
		UdpPort:             udpPortVal,
		Vrf:                 vrfVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewNetflowExporterCollectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetflowExporterCollectionValue {
	object, diags := NewNetflowExporterCollectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetflowExporterCollectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetflowExporterCollectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetflowExporterCollectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetflowExporterCollectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetflowExporterCollectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetflowExporterCollectionValueMust(NetflowExporterCollectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetflowExporterCollectionType) ValueType(ctx context.Context) attr.Value {
	return NetflowExporterCollectionValue{}
}

var _ basetypes.ObjectValuable = NetflowExporterCollectionValue{}

type NetflowExporterCollectionValue struct {
	ExporterIp          basetypes.StringValue `tfsdk:"exporter_ip"`
	ExporterName        basetypes.StringValue `tfsdk:"exporter_name"`
	SourceInterfaceName basetypes.StringValue `tfsdk:"source_interface_name"`
	UdpPort             basetypes.Int64Value  `tfsdk:"udp_port"`
	Vrf                 basetypes.StringValue `tfsdk:"vrf"`
	state               attr.ValueState
}

func (v NetflowExporterCollectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["exporter_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["exporter_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_interface_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["udp_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vrf"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.ExporterIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exporter_ip"] = val

		val, err = v.ExporterName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exporter_name"] = val

		val, err = v.SourceInterfaceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_interface_name"] = val

		val, err = v.UdpPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["udp_port"] = val

		val, err = v.Vrf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetflowExporterCollectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetflowExporterCollectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetflowExporterCollectionValue) String() string {
	return "NetflowExporterCollectionValue"
}

func (v NetflowExporterCollectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"exporter_ip":           basetypes.StringType{},
		"exporter_name":         basetypes.StringType{},
		"source_interface_name": basetypes.StringType{},
		"udp_port":              basetypes.Int64Type{},
		"vrf":                   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"exporter_ip":           v.ExporterIp,
			"exporter_name":         v.ExporterName,
			"source_interface_name": v.SourceInterfaceName,
			"udp_port":              v.UdpPort,
			"vrf":                   v.Vrf,
		})

	return objVal, diags
}

func (v NetflowExporterCollectionValue) Equal(o attr.Value) bool {
	other, ok := o.(NetflowExporterCollectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExporterIp.Equal(other.ExporterIp) {
		return false
	}

	if !v.ExporterName.Equal(other.ExporterName) {
		return false
	}

	if !v.SourceInterfaceName.Equal(other.SourceInterfaceName) {
		return false
	}

	if !v.UdpPort.Equal(other.UdpPort) {
		return false
	}

	if !v.Vrf.Equal(other.Vrf) {
		return false
	}

	return true
}

func (v NetflowExporterCollectionValue) Type(ctx context.Context) attr.Type {
	return NetflowExporterCollectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetflowExporterCollectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"exporter_ip":           basetypes.StringType{},
		"exporter_name":         basetypes.StringType{},
		"source_interface_name": basetypes.StringType{},
		"udp_port":              basetypes.Int64Type{},
		"vrf":                   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NetflowMonitorCollectionType{}

type NetflowMonitorCollectionType struct {
	basetypes.ObjectType
}

func (t NetflowMonitorCollectionType) Equal(o attr.Type) bool {
	other, ok := o.(NetflowMonitorCollectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetflowMonitorCollectionType) String() string {
	return "NetflowMonitorCollectionType"
}

func (t NetflowMonitorCollectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	exporter1NameAttribute, ok := attributes["exporter1_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exporter1_name is missing from object`)

		return nil, diags
	}

	exporter1NameVal, ok := exporter1NameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exporter1_name expected to be basetypes.StringValue, was: %T`, exporter1NameAttribute))
	}

	exporter2NameAttribute, ok := attributes["exporter2_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exporter2_name is missing from object`)

		return nil, diags
	}

	exporter2NameVal, ok := exporter2NameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exporter2_name expected to be basetypes.StringValue, was: %T`, exporter2NameAttribute))
	}

	monitorNameAttribute, ok := attributes["monitor_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitor_name is missing from object`)

		return nil, diags
	}

	monitorNameVal, ok := monitorNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitor_name expected to be basetypes.StringValue, was: %T`, monitorNameAttribute))
	}

	monitorRecordNameAttribute, ok := attributes["monitor_record_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitor_record_name is missing from object`)

		return nil, diags
	}

	monitorRecordNameVal, ok := monitorRecordNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitor_record_name expected to be basetypes.StringValue, was: %T`, monitorRecordNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetflowMonitorCollectionValue{
		Exporter1Name:     exporter1NameVal,
		Exporter2Name:     exporter2NameVal,
		MonitorName:       monitorNameVal,
		MonitorRecordName: monitorRecordNameVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNetflowMonitorCollectionValueNull() NetflowMonitorCollectionValue {
	return NetflowMonitorCollectionValue{
		state: attr.ValueStateNull,
	}
}

func NewNetflowMonitorCollectionValueUnknown() NetflowMonitorCollectionValue {
	return NetflowMonitorCollectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetflowMonitorCollectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetflowMonitorCollectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetflowMonitorCollectionValue Attribute Value",
				"While creating a NetflowMonitorCollectionValue value, a missing attribute value was detected. "+
					"A NetflowMonitorCollectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetflowMonitorCollectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetflowMonitorCollectionValue Attribute Type",
				"While creating a NetflowMonitorCollectionValue value, an invalid attribute value was detected. "+
					"A NetflowMonitorCollectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetflowMonitorCollectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetflowMonitorCollectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetflowMonitorCollectionValue Attribute Value",
				"While creating a NetflowMonitorCollectionValue value, an extra attribute value was detected. "+
					"A NetflowMonitorCollectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetflowMonitorCollectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetflowMonitorCollectionValueUnknown(), diags
	}

	exporter1NameAttribute, ok := attributes["exporter1_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exporter1_name is missing from object`)

		return NewNetflowMonitorCollectionValueUnknown(), diags
	}

	exporter1NameVal, ok := exporter1NameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exporter1_name expected to be basetypes.StringValue, was: %T`, exporter1NameAttribute))
	}

	exporter2NameAttribute, ok := attributes["exporter2_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exporter2_name is missing from object`)

		return NewNetflowMonitorCollectionValueUnknown(), diags
	}

	exporter2NameVal, ok := exporter2NameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exporter2_name expected to be basetypes.StringValue, was: %T`, exporter2NameAttribute))
	}

	monitorNameAttribute, ok := attributes["monitor_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitor_name is missing from object`)

		return NewNetflowMonitorCollectionValueUnknown(), diags
	}

	monitorNameVal, ok := monitorNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitor_name expected to be basetypes.StringValue, was: %T`, monitorNameAttribute))
	}

	monitorRecordNameAttribute, ok := attributes["monitor_record_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitor_record_name is missing from object`)

		return NewNetflowMonitorCollectionValueUnknown(), diags
	}

	monitorRecordNameVal, ok := monitorRecordNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitor_record_name expected to be basetypes.StringValue, was: %T`, monitorRecordNameAttribute))
	}

	if diags.HasError() {
		return NewNetflowMonitorCollectionValueUnknown(), diags
	}

	return NetflowMonitorCollectionValue{
		Exporter1Name:     exporter1NameVal,
		Exporter2Name:     exporter2NameVal,
		MonitorName:       monitorNameVal,
		MonitorRecordName: monitorRecordNameVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNetflowMonitorCollectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetflowMonitorCollectionValue {
	object, diags := NewNetflowMonitorCollectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetflowMonitorCollectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetflowMonitorCollectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetflowMonitorCollectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetflowMonitorCollectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetflowMonitorCollectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetflowMonitorCollectionValueMust(NetflowMonitorCollectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetflowMonitorCollectionType) ValueType(ctx context.Context) attr.Value {
	return NetflowMonitorCollectionValue{}
}

var _ basetypes.ObjectValuable = NetflowMonitorCollectionValue{}

type NetflowMonitorCollectionValue struct {
	Exporter1Name     basetypes.StringValue `tfsdk:"exporter1_name"`
	Exporter2Name     basetypes.StringValue `tfsdk:"exporter2_name"`
	MonitorName       basetypes.StringValue `tfsdk:"monitor_name"`
	MonitorRecordName basetypes.StringValue `tfsdk:"monitor_record_name"`
	state             attr.ValueState
}

func (v NetflowMonitorCollectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["exporter1_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["exporter2_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["monitor_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["monitor_record_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Exporter1Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exporter1_name"] = val

		val, err = v.Exporter2Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exporter2_name"] = val

		val, err = v.MonitorName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monitor_name"] = val

		val, err = v.MonitorRecordName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monitor_record_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetflowMonitorCollectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetflowMonitorCollectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetflowMonitorCollectionValue) String() string {
	return "NetflowMonitorCollectionValue"
}

func (v NetflowMonitorCollectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"exporter1_name":      basetypes.StringType{},
		"exporter2_name":      basetypes.StringType{},
		"monitor_name":        basetypes.StringType{},
		"monitor_record_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"exporter1_name":      v.Exporter1Name,
			"exporter2_name":      v.Exporter2Name,
			"monitor_name":        v.MonitorName,
			"monitor_record_name": v.MonitorRecordName,
		})

	return objVal, diags
}

func (v NetflowMonitorCollectionValue) Equal(o attr.Value) bool {
	other, ok := o.(NetflowMonitorCollectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Exporter1Name.Equal(other.Exporter1Name) {
		return false
	}

	if !v.Exporter2Name.Equal(other.Exporter2Name) {
		return false
	}

	if !v.MonitorName.Equal(other.MonitorName) {
		return false
	}

	if !v.MonitorRecordName.Equal(other.MonitorRecordName) {
		return false
	}

	return true
}

func (v NetflowMonitorCollectionValue) Type(ctx context.Context) attr.Type {
	return NetflowMonitorCollectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetflowMonitorCollectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"exporter1_name":      basetypes.StringType{},
		"exporter2_name":      basetypes.StringType{},
		"monitor_name":        basetypes.StringType{},
		"monitor_record_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NetflowRecordCollectionType{}

type NetflowRecordCollectionType struct {
	basetypes.ObjectType
}

func (t NetflowRecordCollectionType) Equal(o attr.Type) bool {
	other, ok := o.(NetflowRecordCollectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetflowRecordCollectionType) String() string {
	return "NetflowRecordCollectionType"
}

func (t NetflowRecordCollectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	layer2RecordAttribute, ok := attributes["layer2_record"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`layer2_record is missing from object`)

		return nil, diags
	}

	layer2RecordVal, ok := layer2RecordAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`layer2_record expected to be basetypes.BoolValue, was: %T`, layer2RecordAttribute))
	}

	recordNameAttribute, ok := attributes["record_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_name is missing from object`)

		return nil, diags
	}

	recordNameVal, ok := recordNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_name expected to be basetypes.StringValue, was: %T`, recordNameAttribute))
	}

	recordTemplateAttribute, ok := attributes["record_template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_template is missing from object`)

		return nil, diags
	}

	recordTemplateVal, ok := recordTemplateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_template expected to be basetypes.StringValue, was: %T`, recordTemplateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetflowRecordCollectionValue{
		Layer2Record:   layer2RecordVal,
		RecordName:     recordNameVal,
		RecordTemplate: recordTemplateVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewNetflowRecordCollectionValueNull() NetflowRecordCollectionValue {
	return NetflowRecordCollectionValue{
		state: attr.ValueStateNull,
	}
}

func NewNetflowRecordCollectionValueUnknown() NetflowRecordCollectionValue {
	return NetflowRecordCollectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetflowRecordCollectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetflowRecordCollectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetflowRecordCollectionValue Attribute Value",
				"While creating a NetflowRecordCollectionValue value, a missing attribute value was detected. "+
					"A NetflowRecordCollectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetflowRecordCollectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetflowRecordCollectionValue Attribute Type",
				"While creating a NetflowRecordCollectionValue value, an invalid attribute value was detected. "+
					"A NetflowRecordCollectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetflowRecordCollectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetflowRecordCollectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetflowRecordCollectionValue Attribute Value",
				"While creating a NetflowRecordCollectionValue value, an extra attribute value was detected. "+
					"A NetflowRecordCollectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetflowRecordCollectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetflowRecordCollectionValueUnknown(), diags
	}

	layer2RecordAttribute, ok := attributes["layer2_record"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`layer2_record is missing from object`)

		return NewNetflowRecordCollectionValueUnknown(), diags
	}

	layer2RecordVal, ok := layer2RecordAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`layer2_record expected to be basetypes.BoolValue, was: %T`, layer2RecordAttribute))
	}

	recordNameAttribute, ok := attributes["record_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_name is missing from object`)

		return NewNetflowRecordCollectionValueUnknown(), diags
	}

	recordNameVal, ok := recordNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_name expected to be basetypes.StringValue, was: %T`, recordNameAttribute))
	}

	recordTemplateAttribute, ok := attributes["record_template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_template is missing from object`)

		return NewNetflowRecordCollectionValueUnknown(), diags
	}

	recordTemplateVal, ok := recordTemplateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_template expected to be basetypes.StringValue, was: %T`, recordTemplateAttribute))
	}

	if diags.HasError() {
		return NewNetflowRecordCollectionValueUnknown(), diags
	}

	return NetflowRecordCollectionValue{
		Layer2Record:   layer2RecordVal,
		RecordName:     recordNameVal,
		RecordTemplate: recordTemplateVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewNetflowRecordCollectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetflowRecordCollectionValue {
	object, diags := NewNetflowRecordCollectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetflowRecordCollectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetflowRecordCollectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetflowRecordCollectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetflowRecordCollectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetflowRecordCollectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetflowRecordCollectionValueMust(NetflowRecordCollectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetflowRecordCollectionType) ValueType(ctx context.Context) attr.Value {
	return NetflowRecordCollectionValue{}
}

var _ basetypes.ObjectValuable = NetflowRecordCollectionValue{}

type NetflowRecordCollectionValue struct {
	Layer2Record   basetypes.BoolValue   `tfsdk:"layer2_record"`
	RecordName     basetypes.StringValue `tfsdk:"record_name"`
	RecordTemplate basetypes.StringValue `tfsdk:"record_template"`
	state          attr.ValueState
}

func (v NetflowRecordCollectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["layer2_record"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["record_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["record_template"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Layer2Record.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["layer2_record"] = val

		val, err = v.RecordName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["record_name"] = val

		val, err = v.RecordTemplate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["record_template"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetflowRecordCollectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetflowRecordCollectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetflowRecordCollectionValue) String() string {
	return "NetflowRecordCollectionValue"
}

func (v NetflowRecordCollectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"layer2_record":   basetypes.BoolType{},
		"record_name":     basetypes.StringType{},
		"record_template": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"layer2_record":   v.Layer2Record,
			"record_name":     v.RecordName,
			"record_template": v.RecordTemplate,
		})

	return objVal, diags
}

func (v NetflowRecordCollectionValue) Equal(o attr.Value) bool {
	other, ok := o.(NetflowRecordCollectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Layer2Record.Equal(other.Layer2Record) {
		return false
	}

	if !v.RecordName.Equal(other.RecordName) {
		return false
	}

	if !v.RecordTemplate.Equal(other.RecordTemplate) {
		return false
	}

	return true
}

func (v NetflowRecordCollectionValue) Type(ctx context.Context) attr.Type {
	return NetflowRecordCollectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetflowRecordCollectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"layer2_record":   basetypes.BoolType{},
		"record_name":     basetypes.StringType{},
		"record_template": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NetflowSamplerCollectionType{}

type NetflowSamplerCollectionType struct {
	basetypes.ObjectType
}

func (t NetflowSamplerCollectionType) Equal(o attr.Type) bool {
	other, ok := o.(NetflowSamplerCollectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetflowSamplerCollectionType) String() string {
	return "NetflowSamplerCollectionType"
}

func (t NetflowSamplerCollectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	numSamplesAttribute, ok := attributes["num_samples"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_samples is missing from object`)

		return nil, diags
	}

	numSamplesVal, ok := numSamplesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_samples expected to be basetypes.Int64Value, was: %T`, numSamplesAttribute))
	}

	samplerNameAttribute, ok := attributes["sampler_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sampler_name is missing from object`)

		return nil, diags
	}

	samplerNameVal, ok := samplerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sampler_name expected to be basetypes.StringValue, was: %T`, samplerNameAttribute))
	}

	samplingRateAttribute, ok := attributes["sampling_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sampling_rate is missing from object`)

		return nil, diags
	}

	samplingRateVal, ok := samplingRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sampling_rate expected to be basetypes.Int64Value, was: %T`, samplingRateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetflowSamplerCollectionValue{
		NumSamples:   numSamplesVal,
		SamplerName:  samplerNameVal,
		SamplingRate: samplingRateVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewNetflowSamplerCollectionValueNull() NetflowSamplerCollectionValue {
	return NetflowSamplerCollectionValue{
		state: attr.ValueStateNull,
	}
}

func NewNetflowSamplerCollectionValueUnknown() NetflowSamplerCollectionValue {
	return NetflowSamplerCollectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetflowSamplerCollectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetflowSamplerCollectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetflowSamplerCollectionValue Attribute Value",
				"While creating a NetflowSamplerCollectionValue value, a missing attribute value was detected. "+
					"A NetflowSamplerCollectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetflowSamplerCollectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetflowSamplerCollectionValue Attribute Type",
				"While creating a NetflowSamplerCollectionValue value, an invalid attribute value was detected. "+
					"A NetflowSamplerCollectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetflowSamplerCollectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetflowSamplerCollectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetflowSamplerCollectionValue Attribute Value",
				"While creating a NetflowSamplerCollectionValue value, an extra attribute value was detected. "+
					"A NetflowSamplerCollectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetflowSamplerCollectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetflowSamplerCollectionValueUnknown(), diags
	}

	numSamplesAttribute, ok := attributes["num_samples"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_samples is missing from object`)

		return NewNetflowSamplerCollectionValueUnknown(), diags
	}

	numSamplesVal, ok := numSamplesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_samples expected to be basetypes.Int64Value, was: %T`, numSamplesAttribute))
	}

	samplerNameAttribute, ok := attributes["sampler_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sampler_name is missing from object`)

		return NewNetflowSamplerCollectionValueUnknown(), diags
	}

	samplerNameVal, ok := samplerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sampler_name expected to be basetypes.StringValue, was: %T`, samplerNameAttribute))
	}

	samplingRateAttribute, ok := attributes["sampling_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sampling_rate is missing from object`)

		return NewNetflowSamplerCollectionValueUnknown(), diags
	}

	samplingRateVal, ok := samplingRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sampling_rate expected to be basetypes.Int64Value, was: %T`, samplingRateAttribute))
	}

	if diags.HasError() {
		return NewNetflowSamplerCollectionValueUnknown(), diags
	}

	return NetflowSamplerCollectionValue{
		NumSamples:   numSamplesVal,
		SamplerName:  samplerNameVal,
		SamplingRate: samplingRateVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewNetflowSamplerCollectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetflowSamplerCollectionValue {
	object, diags := NewNetflowSamplerCollectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetflowSamplerCollectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetflowSamplerCollectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetflowSamplerCollectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetflowSamplerCollectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetflowSamplerCollectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetflowSamplerCollectionValueMust(NetflowSamplerCollectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetflowSamplerCollectionType) ValueType(ctx context.Context) attr.Value {
	return NetflowSamplerCollectionValue{}
}

var _ basetypes.ObjectValuable = NetflowSamplerCollectionValue{}

type NetflowSamplerCollectionValue struct {
	NumSamples   basetypes.Int64Value  `tfsdk:"num_samples"`
	SamplerName  basetypes.StringValue `tfsdk:"sampler_name"`
	SamplingRate basetypes.Int64Value  `tfsdk:"sampling_rate"`
	state        attr.ValueState
}

func (v NetflowSamplerCollectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["num_samples"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["sampler_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sampling_rate"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.NumSamples.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_samples"] = val

		val, err = v.SamplerName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sampler_name"] = val

		val, err = v.SamplingRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sampling_rate"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetflowSamplerCollectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetflowSamplerCollectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetflowSamplerCollectionValue) String() string {
	return "NetflowSamplerCollectionValue"
}

func (v NetflowSamplerCollectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"num_samples":   basetypes.Int64Type{},
		"sampler_name":  basetypes.StringType{},
		"sampling_rate": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"num_samples":   v.NumSamples,
			"sampler_name":  v.SamplerName,
			"sampling_rate": v.SamplingRate,
		})

	return objVal, diags
}

func (v NetflowSamplerCollectionValue) Equal(o attr.Value) bool {
	other, ok := o.(NetflowSamplerCollectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NumSamples.Equal(other.NumSamples) {
		return false
	}

	if !v.SamplerName.Equal(other.SamplerName) {
		return false
	}

	if !v.SamplingRate.Equal(other.SamplingRate) {
		return false
	}

	return true
}

func (v NetflowSamplerCollectionValue) Type(ctx context.Context) attr.Type {
	return NetflowSamplerCollectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetflowSamplerCollectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"num_samples":   basetypes.Int64Type{},
		"sampler_name":  basetypes.StringType{},
		"sampling_rate": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = VrfFlowRulesType{}

type VrfFlowRulesType struct {
	basetypes.ObjectType
}

func (t VrfFlowRulesType) Equal(o attr.Type) bool {
	other, ok := o.(VrfFlowRulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrfFlowRulesType) String() string {
	return "VrfFlowRulesType"
}

func (t VrfFlowRulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	vrfFlowRuleAttributesAttribute, ok := attributes["vrf_flow_rule_attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_attributes is missing from object`)

		return nil, diags
	}

	vrfFlowRuleAttributesVal, ok := vrfFlowRuleAttributesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_attributes expected to be basetypes.ListValue, was: %T`, vrfFlowRuleAttributesAttribute))
	}

	vrfFlowRuleNameAttribute, ok := attributes["vrf_flow_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_name is missing from object`)

		return nil, diags
	}

	vrfFlowRuleNameVal, ok := vrfFlowRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_name expected to be basetypes.StringValue, was: %T`, vrfFlowRuleNameAttribute))
	}

	vrfFlowRuleSubnetsAttribute, ok := attributes["vrf_flow_rule_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_subnets is missing from object`)

		return nil, diags
	}

	vrfFlowRuleSubnetsVal, ok := vrfFlowRuleSubnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_subnets expected to be basetypes.SetValue, was: %T`, vrfFlowRuleSubnetsAttribute))
	}

	vrfFlowRuleTenantAttribute, ok := attributes["vrf_flow_rule_tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_tenant is missing from object`)

		return nil, diags
	}

	vrfFlowRuleTenantVal, ok := vrfFlowRuleTenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_tenant expected to be basetypes.StringValue, was: %T`, vrfFlowRuleTenantAttribute))
	}

	vrfFlowRuleUuidAttribute, ok := attributes["vrf_flow_rule_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_uuid is missing from object`)

		return nil, diags
	}

	vrfFlowRuleUuidVal, ok := vrfFlowRuleUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_uuid expected to be basetypes.StringValue, was: %T`, vrfFlowRuleUuidAttribute))
	}

	vrfFlowRuleVrfAttribute, ok := attributes["vrf_flow_rule_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_vrf is missing from object`)

		return nil, diags
	}

	vrfFlowRuleVrfVal, ok := vrfFlowRuleVrfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_vrf expected to be basetypes.StringValue, was: %T`, vrfFlowRuleVrfAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrfFlowRulesValue{
		VrfFlowRuleAttributes: vrfFlowRuleAttributesVal,
		VrfFlowRuleName:       vrfFlowRuleNameVal,
		VrfFlowRuleSubnets:    vrfFlowRuleSubnetsVal,
		VrfFlowRuleTenant:     vrfFlowRuleTenantVal,
		VrfFlowRuleUuid:       vrfFlowRuleUuidVal,
		VrfFlowRuleVrf:        vrfFlowRuleVrfVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewVrfFlowRulesValueNull() VrfFlowRulesValue {
	return VrfFlowRulesValue{
		state: attr.ValueStateNull,
	}
}

func NewVrfFlowRulesValueUnknown() VrfFlowRulesValue {
	return VrfFlowRulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrfFlowRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrfFlowRulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrfFlowRulesValue Attribute Value",
				"While creating a VrfFlowRulesValue value, a missing attribute value was detected. "+
					"A VrfFlowRulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfFlowRulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrfFlowRulesValue Attribute Type",
				"While creating a VrfFlowRulesValue value, an invalid attribute value was detected. "+
					"A VrfFlowRulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfFlowRulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrfFlowRulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrfFlowRulesValue Attribute Value",
				"While creating a VrfFlowRulesValue value, an extra attribute value was detected. "+
					"A VrfFlowRulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrfFlowRulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrfFlowRulesValueUnknown(), diags
	}

	vrfFlowRuleAttributesAttribute, ok := attributes["vrf_flow_rule_attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_attributes is missing from object`)

		return NewVrfFlowRulesValueUnknown(), diags
	}

	vrfFlowRuleAttributesVal, ok := vrfFlowRuleAttributesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_attributes expected to be basetypes.ListValue, was: %T`, vrfFlowRuleAttributesAttribute))
	}

	vrfFlowRuleNameAttribute, ok := attributes["vrf_flow_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_name is missing from object`)

		return NewVrfFlowRulesValueUnknown(), diags
	}

	vrfFlowRuleNameVal, ok := vrfFlowRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_name expected to be basetypes.StringValue, was: %T`, vrfFlowRuleNameAttribute))
	}

	vrfFlowRuleSubnetsAttribute, ok := attributes["vrf_flow_rule_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_subnets is missing from object`)

		return NewVrfFlowRulesValueUnknown(), diags
	}

	vrfFlowRuleSubnetsVal, ok := vrfFlowRuleSubnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_subnets expected to be basetypes.SetValue, was: %T`, vrfFlowRuleSubnetsAttribute))
	}

	vrfFlowRuleTenantAttribute, ok := attributes["vrf_flow_rule_tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_tenant is missing from object`)

		return NewVrfFlowRulesValueUnknown(), diags
	}

	vrfFlowRuleTenantVal, ok := vrfFlowRuleTenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_tenant expected to be basetypes.StringValue, was: %T`, vrfFlowRuleTenantAttribute))
	}

	vrfFlowRuleUuidAttribute, ok := attributes["vrf_flow_rule_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_uuid is missing from object`)

		return NewVrfFlowRulesValueUnknown(), diags
	}

	vrfFlowRuleUuidVal, ok := vrfFlowRuleUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_uuid expected to be basetypes.StringValue, was: %T`, vrfFlowRuleUuidAttribute))
	}

	vrfFlowRuleVrfAttribute, ok := attributes["vrf_flow_rule_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_vrf is missing from object`)

		return NewVrfFlowRulesValueUnknown(), diags
	}

	vrfFlowRuleVrfVal, ok := vrfFlowRuleVrfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_vrf expected to be basetypes.StringValue, was: %T`, vrfFlowRuleVrfAttribute))
	}

	if diags.HasError() {
		return NewVrfFlowRulesValueUnknown(), diags
	}

	return VrfFlowRulesValue{
		VrfFlowRuleAttributes: vrfFlowRuleAttributesVal,
		VrfFlowRuleName:       vrfFlowRuleNameVal,
		VrfFlowRuleSubnets:    vrfFlowRuleSubnetsVal,
		VrfFlowRuleTenant:     vrfFlowRuleTenantVal,
		VrfFlowRuleUuid:       vrfFlowRuleUuidVal,
		VrfFlowRuleVrf:        vrfFlowRuleVrfVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewVrfFlowRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrfFlowRulesValue {
	object, diags := NewVrfFlowRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrfFlowRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrfFlowRulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrfFlowRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrfFlowRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrfFlowRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrfFlowRulesValueMust(VrfFlowRulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrfFlowRulesType) ValueType(ctx context.Context) attr.Value {
	return VrfFlowRulesValue{}
}

var _ basetypes.ObjectValuable = VrfFlowRulesValue{}

type VrfFlowRulesValue struct {
	VrfFlowRuleAttributes basetypes.ListValue   `tfsdk:"vrf_flow_rule_attributes"`
	VrfFlowRuleName       basetypes.StringValue `tfsdk:"vrf_flow_rule_name"`
	VrfFlowRuleSubnets    basetypes.SetValue    `tfsdk:"vrf_flow_rule_subnets"`
	VrfFlowRuleTenant     basetypes.StringValue `tfsdk:"vrf_flow_rule_tenant"`
	VrfFlowRuleUuid       basetypes.StringValue `tfsdk:"vrf_flow_rule_uuid"`
	VrfFlowRuleVrf        basetypes.StringValue `tfsdk:"vrf_flow_rule_vrf"`
	state                 attr.ValueState
}

func (v VrfFlowRulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["vrf_flow_rule_attributes"] = basetypes.ListType{
		ElemType: VrfFlowRuleAttributesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_subnets"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_tenant"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_vrf"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.VrfFlowRuleAttributes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_attributes"] = val

		val, err = v.VrfFlowRuleName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_name"] = val

		val, err = v.VrfFlowRuleSubnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_subnets"] = val

		val, err = v.VrfFlowRuleTenant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_tenant"] = val

		val, err = v.VrfFlowRuleUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_uuid"] = val

		val, err = v.VrfFlowRuleVrf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_vrf"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrfFlowRulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrfFlowRulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrfFlowRulesValue) String() string {
	return "VrfFlowRulesValue"
}

func (v VrfFlowRulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	vrfFlowRuleAttributes := types.ListValueMust(
		VrfFlowRuleAttributesType{
			basetypes.ObjectType{
				AttrTypes: VrfFlowRuleAttributesValue{}.AttributeTypes(ctx),
			},
		},
		v.VrfFlowRuleAttributes.Elements(),
	)

	if v.VrfFlowRuleAttributes.IsNull() {
		vrfFlowRuleAttributes = types.ListNull(
			VrfFlowRuleAttributesType{
				basetypes.ObjectType{
					AttrTypes: VrfFlowRuleAttributesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VrfFlowRuleAttributes.IsUnknown() {
		vrfFlowRuleAttributes = types.ListUnknown(
			VrfFlowRuleAttributesType{
				basetypes.ObjectType{
					AttrTypes: VrfFlowRuleAttributesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var vrfFlowRuleSubnetsVal basetypes.SetValue
	switch {
	case v.VrfFlowRuleSubnets.IsUnknown():
		vrfFlowRuleSubnetsVal = types.SetUnknown(types.StringType)
	case v.VrfFlowRuleSubnets.IsNull():
		vrfFlowRuleSubnetsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		vrfFlowRuleSubnetsVal, d = types.SetValue(types.StringType, v.VrfFlowRuleSubnets.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"vrf_flow_rule_attributes": basetypes.ListType{
				ElemType: VrfFlowRuleAttributesValue{}.Type(ctx),
			},
			"vrf_flow_rule_name": basetypes.StringType{},
			"vrf_flow_rule_subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"vrf_flow_rule_tenant": basetypes.StringType{},
			"vrf_flow_rule_uuid":   basetypes.StringType{},
			"vrf_flow_rule_vrf":    basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"vrf_flow_rule_attributes": basetypes.ListType{
			ElemType: VrfFlowRuleAttributesValue{}.Type(ctx),
		},
		"vrf_flow_rule_name": basetypes.StringType{},
		"vrf_flow_rule_subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"vrf_flow_rule_tenant": basetypes.StringType{},
		"vrf_flow_rule_uuid":   basetypes.StringType{},
		"vrf_flow_rule_vrf":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"vrf_flow_rule_attributes": vrfFlowRuleAttributes,
			"vrf_flow_rule_name":       v.VrfFlowRuleName,
			"vrf_flow_rule_subnets":    vrfFlowRuleSubnetsVal,
			"vrf_flow_rule_tenant":     v.VrfFlowRuleTenant,
			"vrf_flow_rule_uuid":       v.VrfFlowRuleUuid,
			"vrf_flow_rule_vrf":        v.VrfFlowRuleVrf,
		})

	return objVal, diags
}

func (v VrfFlowRulesValue) Equal(o attr.Value) bool {
	other, ok := o.(VrfFlowRulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.VrfFlowRuleAttributes.Equal(other.VrfFlowRuleAttributes) {
		return false
	}

	if !v.VrfFlowRuleName.Equal(other.VrfFlowRuleName) {
		return false
	}

	if !v.VrfFlowRuleSubnets.Equal(other.VrfFlowRuleSubnets) {
		return false
	}

	if !v.VrfFlowRuleTenant.Equal(other.VrfFlowRuleTenant) {
		return false
	}

	if !v.VrfFlowRuleUuid.Equal(other.VrfFlowRuleUuid) {
		return false
	}

	if !v.VrfFlowRuleVrf.Equal(other.VrfFlowRuleVrf) {
		return false
	}

	return true
}

func (v VrfFlowRulesValue) Type(ctx context.Context) attr.Type {
	return VrfFlowRulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrfFlowRulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"vrf_flow_rule_attributes": basetypes.ListType{
			ElemType: VrfFlowRuleAttributesValue{}.Type(ctx),
		},
		"vrf_flow_rule_name": basetypes.StringType{},
		"vrf_flow_rule_subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"vrf_flow_rule_tenant": basetypes.StringType{},
		"vrf_flow_rule_uuid":   basetypes.StringType{},
		"vrf_flow_rule_vrf":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VrfFlowRuleAttributesType{}

type VrfFlowRuleAttributesType struct {
	basetypes.ObjectType
}

func (t VrfFlowRuleAttributesType) Equal(o attr.Type) bool {
	other, ok := o.(VrfFlowRuleAttributesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrfFlowRuleAttributesType) String() string {
	return "VrfFlowRuleAttributesType"
}

func (t VrfFlowRuleAttributesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	vrfFlowRuleAttributeIdAttribute, ok := attributes["vrf_flow_rule_attribute_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_attribute_id is missing from object`)

		return nil, diags
	}

	vrfFlowRuleAttributeIdVal, ok := vrfFlowRuleAttributeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_attribute_id expected to be basetypes.StringValue, was: %T`, vrfFlowRuleAttributeIdAttribute))
	}

	vrfFlowRuleBidirectionalAttribute, ok := attributes["vrf_flow_rule_bidirectional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_bidirectional is missing from object`)

		return nil, diags
	}

	vrfFlowRuleBidirectionalVal, ok := vrfFlowRuleBidirectionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_bidirectional expected to be basetypes.BoolValue, was: %T`, vrfFlowRuleBidirectionalAttribute))
	}

	vrfFlowRuleDstIpAttribute, ok := attributes["vrf_flow_rule_dst_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_dst_ip is missing from object`)

		return nil, diags
	}

	vrfFlowRuleDstIpVal, ok := vrfFlowRuleDstIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_dst_ip expected to be basetypes.StringValue, was: %T`, vrfFlowRuleDstIpAttribute))
	}

	vrfFlowRuleDstPortAttribute, ok := attributes["vrf_flow_rule_dst_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_dst_port is missing from object`)

		return nil, diags
	}

	vrfFlowRuleDstPortVal, ok := vrfFlowRuleDstPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_dst_port expected to be basetypes.StringValue, was: %T`, vrfFlowRuleDstPortAttribute))
	}

	vrfFlowRuleProtocolAttribute, ok := attributes["vrf_flow_rule_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_protocol is missing from object`)

		return nil, diags
	}

	vrfFlowRuleProtocolVal, ok := vrfFlowRuleProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_protocol expected to be basetypes.StringValue, was: %T`, vrfFlowRuleProtocolAttribute))
	}

	vrfFlowRuleSrcIpAttribute, ok := attributes["vrf_flow_rule_src_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_src_ip is missing from object`)

		return nil, diags
	}

	vrfFlowRuleSrcIpVal, ok := vrfFlowRuleSrcIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_src_ip expected to be basetypes.StringValue, was: %T`, vrfFlowRuleSrcIpAttribute))
	}

	vrfFlowRuleSrcPortAttribute, ok := attributes["vrf_flow_rule_src_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_src_port is missing from object`)

		return nil, diags
	}

	vrfFlowRuleSrcPortVal, ok := vrfFlowRuleSrcPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_src_port expected to be basetypes.StringValue, was: %T`, vrfFlowRuleSrcPortAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrfFlowRuleAttributesValue{
		VrfFlowRuleAttributeId:   vrfFlowRuleAttributeIdVal,
		VrfFlowRuleBidirectional: vrfFlowRuleBidirectionalVal,
		VrfFlowRuleDstIp:         vrfFlowRuleDstIpVal,
		VrfFlowRuleDstPort:       vrfFlowRuleDstPortVal,
		VrfFlowRuleProtocol:      vrfFlowRuleProtocolVal,
		VrfFlowRuleSrcIp:         vrfFlowRuleSrcIpVal,
		VrfFlowRuleSrcPort:       vrfFlowRuleSrcPortVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewVrfFlowRuleAttributesValueNull() VrfFlowRuleAttributesValue {
	return VrfFlowRuleAttributesValue{
		state: attr.ValueStateNull,
	}
}

func NewVrfFlowRuleAttributesValueUnknown() VrfFlowRuleAttributesValue {
	return VrfFlowRuleAttributesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrfFlowRuleAttributesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrfFlowRuleAttributesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrfFlowRuleAttributesValue Attribute Value",
				"While creating a VrfFlowRuleAttributesValue value, a missing attribute value was detected. "+
					"A VrfFlowRuleAttributesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfFlowRuleAttributesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrfFlowRuleAttributesValue Attribute Type",
				"While creating a VrfFlowRuleAttributesValue value, an invalid attribute value was detected. "+
					"A VrfFlowRuleAttributesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfFlowRuleAttributesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrfFlowRuleAttributesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrfFlowRuleAttributesValue Attribute Value",
				"While creating a VrfFlowRuleAttributesValue value, an extra attribute value was detected. "+
					"A VrfFlowRuleAttributesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrfFlowRuleAttributesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	vrfFlowRuleAttributeIdAttribute, ok := attributes["vrf_flow_rule_attribute_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_attribute_id is missing from object`)

		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	vrfFlowRuleAttributeIdVal, ok := vrfFlowRuleAttributeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_attribute_id expected to be basetypes.StringValue, was: %T`, vrfFlowRuleAttributeIdAttribute))
	}

	vrfFlowRuleBidirectionalAttribute, ok := attributes["vrf_flow_rule_bidirectional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_bidirectional is missing from object`)

		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	vrfFlowRuleBidirectionalVal, ok := vrfFlowRuleBidirectionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_bidirectional expected to be basetypes.BoolValue, was: %T`, vrfFlowRuleBidirectionalAttribute))
	}

	vrfFlowRuleDstIpAttribute, ok := attributes["vrf_flow_rule_dst_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_dst_ip is missing from object`)

		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	vrfFlowRuleDstIpVal, ok := vrfFlowRuleDstIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_dst_ip expected to be basetypes.StringValue, was: %T`, vrfFlowRuleDstIpAttribute))
	}

	vrfFlowRuleDstPortAttribute, ok := attributes["vrf_flow_rule_dst_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_dst_port is missing from object`)

		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	vrfFlowRuleDstPortVal, ok := vrfFlowRuleDstPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_dst_port expected to be basetypes.StringValue, was: %T`, vrfFlowRuleDstPortAttribute))
	}

	vrfFlowRuleProtocolAttribute, ok := attributes["vrf_flow_rule_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_protocol is missing from object`)

		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	vrfFlowRuleProtocolVal, ok := vrfFlowRuleProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_protocol expected to be basetypes.StringValue, was: %T`, vrfFlowRuleProtocolAttribute))
	}

	vrfFlowRuleSrcIpAttribute, ok := attributes["vrf_flow_rule_src_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_src_ip is missing from object`)

		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	vrfFlowRuleSrcIpVal, ok := vrfFlowRuleSrcIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_src_ip expected to be basetypes.StringValue, was: %T`, vrfFlowRuleSrcIpAttribute))
	}

	vrfFlowRuleSrcPortAttribute, ok := attributes["vrf_flow_rule_src_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_src_port is missing from object`)

		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	vrfFlowRuleSrcPortVal, ok := vrfFlowRuleSrcPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_src_port expected to be basetypes.StringValue, was: %T`, vrfFlowRuleSrcPortAttribute))
	}

	if diags.HasError() {
		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	return VrfFlowRuleAttributesValue{
		VrfFlowRuleAttributeId:   vrfFlowRuleAttributeIdVal,
		VrfFlowRuleBidirectional: vrfFlowRuleBidirectionalVal,
		VrfFlowRuleDstIp:         vrfFlowRuleDstIpVal,
		VrfFlowRuleDstPort:       vrfFlowRuleDstPortVal,
		VrfFlowRuleProtocol:      vrfFlowRuleProtocolVal,
		VrfFlowRuleSrcIp:         vrfFlowRuleSrcIpVal,
		VrfFlowRuleSrcPort:       vrfFlowRuleSrcPortVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewVrfFlowRuleAttributesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrfFlowRuleAttributesValue {
	object, diags := NewVrfFlowRuleAttributesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrfFlowRuleAttributesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrfFlowRuleAttributesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrfFlowRuleAttributesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrfFlowRuleAttributesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrfFlowRuleAttributesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrfFlowRuleAttributesValueMust(VrfFlowRuleAttributesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrfFlowRuleAttributesType) ValueType(ctx context.Context) attr.Value {
	return VrfFlowRuleAttributesValue{}
}

var _ basetypes.ObjectValuable = VrfFlowRuleAttributesValue{}

type VrfFlowRuleAttributesValue struct {
	VrfFlowRuleAttributeId   basetypes.StringValue `tfsdk:"vrf_flow_rule_attribute_id"`
	VrfFlowRuleBidirectional basetypes.BoolValue   `tfsdk:"vrf_flow_rule_bidirectional"`
	VrfFlowRuleDstIp         basetypes.StringValue `tfsdk:"vrf_flow_rule_dst_ip"`
	VrfFlowRuleDstPort       basetypes.StringValue `tfsdk:"vrf_flow_rule_dst_port"`
	VrfFlowRuleProtocol      basetypes.StringValue `tfsdk:"vrf_flow_rule_protocol"`
	VrfFlowRuleSrcIp         basetypes.StringValue `tfsdk:"vrf_flow_rule_src_ip"`
	VrfFlowRuleSrcPort       basetypes.StringValue `tfsdk:"vrf_flow_rule_src_port"`
	state                    attr.ValueState
}

func (v VrfFlowRuleAttributesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["vrf_flow_rule_attribute_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_bidirectional"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_dst_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_dst_port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_src_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_src_port"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.VrfFlowRuleAttributeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_attribute_id"] = val

		val, err = v.VrfFlowRuleBidirectional.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_bidirectional"] = val

		val, err = v.VrfFlowRuleDstIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_dst_ip"] = val

		val, err = v.VrfFlowRuleDstPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_dst_port"] = val

		val, err = v.VrfFlowRuleProtocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_protocol"] = val

		val, err = v.VrfFlowRuleSrcIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_src_ip"] = val

		val, err = v.VrfFlowRuleSrcPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_src_port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrfFlowRuleAttributesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrfFlowRuleAttributesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrfFlowRuleAttributesValue) String() string {
	return "VrfFlowRuleAttributesValue"
}

func (v VrfFlowRuleAttributesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"vrf_flow_rule_attribute_id":  basetypes.StringType{},
		"vrf_flow_rule_bidirectional": basetypes.BoolType{},
		"vrf_flow_rule_dst_ip":        basetypes.StringType{},
		"vrf_flow_rule_dst_port":      basetypes.StringType{},
		"vrf_flow_rule_protocol":      basetypes.StringType{},
		"vrf_flow_rule_src_ip":        basetypes.StringType{},
		"vrf_flow_rule_src_port":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"vrf_flow_rule_attribute_id":  v.VrfFlowRuleAttributeId,
			"vrf_flow_rule_bidirectional": v.VrfFlowRuleBidirectional,
			"vrf_flow_rule_dst_ip":        v.VrfFlowRuleDstIp,
			"vrf_flow_rule_dst_port":      v.VrfFlowRuleDstPort,
			"vrf_flow_rule_protocol":      v.VrfFlowRuleProtocol,
			"vrf_flow_rule_src_ip":        v.VrfFlowRuleSrcIp,
			"vrf_flow_rule_src_port":      v.VrfFlowRuleSrcPort,
		})

	return objVal, diags
}

func (v VrfFlowRuleAttributesValue) Equal(o attr.Value) bool {
	other, ok := o.(VrfFlowRuleAttributesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.VrfFlowRuleAttributeId.Equal(other.VrfFlowRuleAttributeId) {
		return false
	}

	if !v.VrfFlowRuleBidirectional.Equal(other.VrfFlowRuleBidirectional) {
		return false
	}

	if !v.VrfFlowRuleDstIp.Equal(other.VrfFlowRuleDstIp) {
		return false
	}

	if !v.VrfFlowRuleDstPort.Equal(other.VrfFlowRuleDstPort) {
		return false
	}

	if !v.VrfFlowRuleProtocol.Equal(other.VrfFlowRuleProtocol) {
		return false
	}

	if !v.VrfFlowRuleSrcIp.Equal(other.VrfFlowRuleSrcIp) {
		return false
	}

	if !v.VrfFlowRuleSrcPort.Equal(other.VrfFlowRuleSrcPort) {
		return false
	}

	return true
}

func (v VrfFlowRuleAttributesValue) Type(ctx context.Context) attr.Type {
	return VrfFlowRuleAttributesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrfFlowRuleAttributesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"vrf_flow_rule_attribute_id":  basetypes.StringType{},
		"vrf_flow_rule_bidirectional": basetypes.BoolType{},
		"vrf_flow_rule_dst_ip":        basetypes.StringType{},
		"vrf_flow_rule_dst_port":      basetypes.StringType{},
		"vrf_flow_rule_protocol":      basetypes.StringType{},
		"vrf_flow_rule_src_ip":        basetypes.StringType{},
		"vrf_flow_rule_src_port":      basetypes.StringType{},
	}
}
