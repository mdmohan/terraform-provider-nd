// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_fabric_vxlan

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/float64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func FabricVxlanResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"aaa": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"advanced_ssh_option": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"advertise_physical_ip": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"advertise_physical_ip_on_border": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(true),
			},
			"aiml_qos": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"aiml_qos_policy": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("400G"),
			},
			"alert_suspend": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("disabled"),
			},
			"allow_vlan_on_leaf_tor_pairing": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("none"),
			},
			"allowed_actions": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"analysis_settings_is_enabled": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"anycast_border_gateway_advertise_physical_ip": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"anycast_gateway_mac": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"anycast_loopback_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(10),
			},
			"anycast_rendezvous_point_ip_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("10.254.254.0/24"),
			},
			"auto_bgp_neighbor_description": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(true),
			},
			"auto_symmetric_default_vrf": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"auto_symmetric_vrf_lite": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"auto_unique_vrf_lite_ip_prefix": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"auto_vrf_lite_default_vrf": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"banner": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"bfd": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"bfd_authentication": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"bfd_authentication_key": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"bfd_authentication_key_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(100),
			},
			"bfd_ibgp": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"bfd_isis": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"bfd_ospf": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"bfd_pim": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"bgp_asn": schema.StringAttribute{
				Required:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"bgp_authentication": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"bgp_authentication_key": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"bgp_authentication_key_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("3des"),
			},
			"bgp_loopback_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(0),
			},
			"bgp_loopback_ip_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("10.2.0.0/22"),
			},
			"bgp_loopback_ipv6_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("fd00::a02:0/119"),
			},
			"bootstrap_multi_subnet": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"brownfield_network_name_format": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("Auto_Net_VNI$$VNI$$_VLAN$$VLAN_ID$$"),
			},
			"brownfield_skip_overlay_network_attachments": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"category": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("fabric"),
			},
			"cdp": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"controller_status": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The controller status of the fabric_vxlan_evpn resource",
				MarkdownDescription: "The controller status of the fabric_vxlan_evpn resource",
				Default:             stringdefault.StaticString("enabled"),
			},
			"copp_policy": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("strict"),
			},
			"cost": schema.Float64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             float64default.StaticFloat64(1.2),
			},
			"day0_bootstrap": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"default_private_vlan_secondary_network_template": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("Pvlan_Secondary_Network"),
			},
			"default_queuing_policy": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"default_queuing_policy_cloudscale": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("queuing_policy_default_8q_cloudscale"),
			},
			"default_queuing_policy_other": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("queuing_policy_default_other"),
			},
			"default_queuing_policy_r_series": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("queuing_policy_default_r_series"),
			},
			"default_vrf_redistribution_bgp_route_map": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("extcon-rmap-filter"),
			},
			"dhcp_end_address": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"dhcp_protocol_version": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("dhcpv4"),
			},
			"dhcp_start_address": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"dns_collection": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"dns_vrf_collection": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"email": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"advisories": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"anomalies": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"collection_frequency_in_days": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             int64default.StaticInt64(42),
						},
						"collection_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             stringdefault.StaticString("basic"),
						},
						"format": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             stringdefault.StaticString("html"),
						},
						"name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"only_include_active_alerts": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             booldefault.StaticBool(false),
						},
						"receiver_email": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"risk_and_conformance_reports": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"start_date": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
					},
					CustomType: EmailType{
						ObjectType: types.ObjectType{
							AttrTypes: EmailValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"export_format": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("json"),
			},
			"export_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("full"),
			},
			"extra_config_aaa": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"extra_config_intra_fabric_links": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"extra_config_leaf": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"extra_config_nxos_bootstrap": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"extra_config_spine": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"extra_config_tor": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"fabric_interface_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("p2p"),
			},
			"fabric_mtu": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(9216),
			},
			"fabric_name": schema.StringAttribute{
				Required:            true,
				Description:         "The name of the fabric_vxlan_evpn resource",
				MarkdownDescription: "The name of the fabric_vxlan_evpn resource",
			},
			"fabric_type": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"fabric_vpc_domain_id": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"fabric_vpc_qos": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"fabric_vpc_qos_policy_name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("spine_qos_for_fabric_vpc_peering"),
			},
			"flow_telemetry": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"greenfield_debug_flag": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("disable"),
			},
			"host_interface_admin_state": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(true),
			},
			"ibgp_peer_template": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "Terraform unique Id for the fabric_vxlan_evpn resource",
				MarkdownDescription: "Terraform unique Id for the fabric_vxlan_evpn resource",
			},
			"inband_dhcp_servers": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"inband_management": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"interface_flow_rules": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"interface_flow_rule_attributes": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"interface_flow_rule_attribute_id": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_flow_rule_bidirectional": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "",
										MarkdownDescription: "",
										Default:             booldefault.StaticBool(false),
									},
									"interface_flow_rule_dst_ip": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_flow_rule_dst_port": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_flow_rule_protocol": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_flow_rule_src_ip": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_flow_rule_src_port": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
								},
								CustomType: InterfaceFlowRuleAttributesType{
									ObjectType: types.ObjectType{
										AttrTypes: InterfaceFlowRuleAttributesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"interface_flow_rule_interface_collection": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"interface_flow_rule_interfaces": schema.SetAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_flow_rule_switch_id": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_flow_rule_switch_name": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
								},
								CustomType: InterfaceFlowRuleInterfaceCollectionType{
									ObjectType: types.ObjectType{
										AttrTypes: InterfaceFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"interface_flow_rule_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"interface_flow_rule_subnets": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"interface_flow_rule_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             stringdefault.StaticString("physical"),
						},
						"interface_flow_rule_uuid": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
					},
					CustomType: InterfaceFlowRulesType{
						ObjectType: types.ObjectType{
							AttrTypes: InterfaceFlowRulesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"interface_rules": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"interface_rule_enable_fabric_interconnect": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             booldefault.StaticBool(true),
						},
						"interface_rule_enable_l3_out": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             booldefault.StaticBool(true),
						},
						"interface_rule_enabled": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             booldefault.StaticBool(true),
						},
						"interface_rule_interface_collection": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"interface_rule_interfaces": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"interface_rule_interface_encap": schema.StringAttribute{
													Optional:            true,
													Description:         "",
													MarkdownDescription: "",
												},
												"interface_rule_interface_name": schema.StringAttribute{
													Optional:            true,
													Description:         "",
													MarkdownDescription: "",
												},
												"interface_rule_interface_type": schema.StringAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "",
													MarkdownDescription: "",
													Default:             stringdefault.StaticString("routed"),
												},
												"interface_rule_interface_vrf_name": schema.StringAttribute{
													Optional:            true,
													Description:         "",
													MarkdownDescription: "",
												},
											},
											CustomType: InterfaceRuleInterfacesType{
												ObjectType: types.ObjectType{
													AttrTypes: InterfaceRuleInterfacesValue{}.AttributeTypes(ctx),
												},
											},
										},
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_rule_l3_out": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_rule_switch_id": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_rule_switch_name": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_rule_tenant": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"interface_rule_vrf_name": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
								},
								CustomType: InterfaceRuleInterfaceCollectionType{
									ObjectType: types.ObjectType{
										AttrTypes: InterfaceRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"interface_rule_name": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             stringdefault.StaticString("TAInterfaceRule1"),
						},
						"interface_rule_subnets": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"interface_rule_uuid": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
					},
					CustomType: InterfaceRulesType{
						ObjectType: types.ObjectType{
							AttrTypes: InterfaceRulesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"interface_statistics_load_interval": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(10),
			},
			"intra_fabric_subnet_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("10.4.0.0/16"),
			},
			"ip_service_level_agreement_id_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("10000-19999"),
			},
			"ipv6_anycast_rendezvous_point_ip_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("fd00::254:254:0/118"),
			},
			"ipv6_link_local": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(true),
			},
			"ipv6_multicast_group_subnet": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("ff1e::/121"),
			},
			"ipv6_subnet_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("fd00::a04:0/112"),
			},
			"ipv6_subnet_target_mask": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(126),
			},
			"isis_area_number": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("0001"),
			},
			"isis_authentication": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"isis_authentication_key": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"isis_authentication_keychain_key_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(127),
			},
			"isis_authentication_keychain_name": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"isis_level": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("level-2"),
			},
			"isis_overload": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(true),
			},
			"isis_overload_elapse_time": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(60),
			},
			"isis_point_to_point": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(true),
			},
			"key_management_entity_server_ip": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"key_management_entity_server_port": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(42),
			},
			"l2_host_interface_mtu": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(9216),
			},
			"l2_vni_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("30000-49000"),
			},
			"l3_out_flow_rules": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"l3_out_flow_rule_interface_collection": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"l3_out_flow_rule_encap": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"l3_out_flow_rule_interfaces": schema.SetAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"l3_out_flow_rule_l3_out": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"l3_out_flow_rule_switch_id": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"l3_out_flow_rule_switch_name": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"l3_out_flow_rule_tenant": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
								},
								CustomType: L3OutFlowRuleInterfaceCollectionType{
									ObjectType: types.ObjectType{
										AttrTypes: L3OutFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"l3_out_flow_rule_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"l3_out_flow_rule_subnets": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"l3_out_flow_rule_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             stringdefault.StaticString("subInterface"),
						},
						"l3_out_flow_rule_uuid": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
					},
					CustomType: L3OutFlowRulesType{
						ObjectType: types.ObjectType{
							AttrTypes: L3OutFlowRulesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"l3_vni_ipv6_multicast_group": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("ff1e::"),
			},
			"l3_vni_no_vlan_default_option": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"l3_vni_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("50000-59000"),
			},
			"l3vni_multicast_group": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("239.1.1.0"),
			},
			"leaf_to_r_id_range": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"leaf_tor_vpc_port_channel_id_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("1-499"),
			},
			"leafibgp_peer_template": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"license_tier": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The license tier of the fabric_vxlan_evpn resource",
				MarkdownDescription: "The license tier of the fabric_vxlan_evpn resource",
				Default:             stringdefault.StaticString("premier"),
			},
			"link_state_routing_protocol": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("ospf"),
			},
			"link_state_routing_tag": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("UNDERLAY"),
			},
			"local_dhcp_server": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"location": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"latitude": schema.Float64Attribute{
						Optional:            true,
						Description:         "",
						MarkdownDescription: "",
					},
					"longitude": schema.Float64Attribute{
						Optional:            true,
						Description:         "",
						MarkdownDescription: "",
					},
				},
				CustomType: LocationType{
					ObjectType: types.ObjectType{
						AttrTypes: LocationValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"macsec": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"macsec_algorithm": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("AES_128_CMAC"),
			},
			"macsec_cipher_suite": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("GCM-AES-XPN-256"),
			},
			"macsec_fallback_algorithm": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("AES_128_CMAC"),
			},
			"macsec_fallback_key_string": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"macsec_key_string": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"macsec_report_timer": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(5),
			},
			"management_gateway": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"management_ipv4_prefix": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(24),
			},
			"management_ipv6_prefix": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(64),
			},
			"message_bus": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"advisories": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"anomalies": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"audit_logs": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"collection_settings_collection_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             stringdefault.StaticString("basic"),
						},
						"collection_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             stringdefault.StaticString("alertsAndEvents"),
						},
						"faults": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"server": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"statistics": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
					},
					CustomType: MessageBusType{
						ObjectType: types.ObjectType{
							AttrTypes: MessageBusValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"microburst": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"mpls_handoff": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"mpls_isis_area_number": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("0001"),
			},
			"mpls_loopback_identifier": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(101),
			},
			"mpls_loopback_ip_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("10.101.0.0/25"),
			},
			"mst_instance_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("0-3,5,7-9"),
			},
			"multicast_group_subnet": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"mvpn_vrf_route_import_id": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(true),
			},
			"mvpn_vrf_route_import_id_range": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"net_flow": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"netflow": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"netflow_exporter_collection": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"exporter_ip": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"exporter_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"source_interface_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"udp_port": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             int64default.StaticInt64(1),
						},
						"vrf": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
					},
					CustomType: NetflowExporterCollectionType{
						ObjectType: types.ObjectType{
							AttrTypes: NetflowExporterCollectionValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"netflow_monitor_collection": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"exporter1_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"exporter2_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"monitor_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"monitor_record_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
					},
					CustomType: NetflowMonitorCollectionType{
						ObjectType: types.ObjectType{
							AttrTypes: NetflowMonitorCollectionValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"netflow_record_collection": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"layer2_record": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             booldefault.StaticBool(false),
						},
						"record_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"record_template": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             stringdefault.StaticString("netflowIpv4Record"),
						},
					},
					CustomType: NetflowRecordCollectionType{
						ObjectType: types.ObjectType{
							AttrTypes: NetflowRecordCollectionValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"netflow_sampler_collection": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"num_samples": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             int64default.StaticInt64(1),
						},
						"sampler_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"sampling_rate": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "",
							MarkdownDescription: "",
							Default:             int64default.StaticInt64(1),
						},
					},
					CustomType: NetflowSamplerCollectionType{
						ObjectType: types.ObjectType{
							AttrTypes: NetflowSamplerCollectionValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"network_extension_template": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("Default_Network_Extension_Universal"),
			},
			"network_template": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("Default_Network_Universal"),
			},
			"network_vlan_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("2300-2999"),
			},
			"next_generation_oam": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(true),
			},
			"ngoam_south_bound_loop_detect": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"ngoam_south_bound_loop_detect_probe_interval": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(300),
			},
			"ngoam_south_bound_loop_detect_recovery_interval": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(600),
			},
			"ntp_server_collection": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"ntp_server_vrf_collection": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"nve_hold_down_timer": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(180),
			},
			"nve_loopback_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(1),
			},
			"nve_loopback_ip_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("10.3.0.0/22"),
			},
			"nve_loopback_ipv6_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("fd00::a03:0/118"),
			},
			"nxapi": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"nxapi_http": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"nxapi_http_port": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(80),
			},
			"nxapi_https_port": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(443),
			},
			"object_tracking_number_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("100-299"),
			},
			"operating_mode": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("flowTelemetry"),
			},
			"orchestration_status": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The orchestration status of the fabric_vxlan_evpn resource",
				MarkdownDescription: "The orchestration status of the fabric_vxlan_evpn resource",
				Default:             stringdefault.StaticString("enabled"),
			},
			"ospf_area_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("0.0.0.0"),
			},
			"ospf_authentication": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"ospf_authentication_key": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"ospf_authentication_key_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(127),
			},
			"overlay_mode": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("cli"),
			},
			"per_vrf_loopback_auto_provision": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"per_vrf_loopback_auto_provision_ipv6": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"per_vrf_loopback_ip_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("10.5.0.0/22"),
			},
			"per_vrf_loopback_ipv6_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("fd00::a05:0/112"),
			},
			"performance_monitoring": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"phantom_rendezvous_point_loopback_id1": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(2),
			},
			"phantom_rendezvous_point_loopback_id2": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(3),
			},
			"phantom_rendezvous_point_loopback_id3": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(4),
			},
			"phantom_rendezvous_point_loopback_id4": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(5),
			},
			"pim_hello_authentication": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"pim_hello_authentication_key": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"policy_based_routing": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"power_redundancy_mode": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("redundant"),
			},
			"pre_interface_config_leaf": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"pre_interface_config_spine": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"pre_interface_config_tor": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"priority_flow_control_watch_interval": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(101),
			},
			"private_vlan": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"ptp": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"ptp_domain_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(0),
			},
			"ptp_loopback_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(0),
			},
			"ptp_vlan_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(2),
			},
			"quantum_key_distribution": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"quantum_key_distribution_profile_name": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"real_time_backup": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(true),
			},
			"real_time_interface_statistics_collection": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"rendezvous_point_count": schema.Int64Attribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"rendezvous_point_loopback_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(254),
			},
			"rendezvous_point_mode": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("asm"),
			},
			"replication_mode": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"route_map_sequence_number_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("1-65534"),
			},
			"route_reflector_count": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(2),
			},
			"router_id_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("10.2.0.0/23"),
			},
			"s_flow": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"scheduled_backup": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(true),
			},
			"scheduled_backup_time": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"security_domain": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("all"),
			},
			"security_group_status": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("disabled"),
			},
			"security_group_tag": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"security_group_tag_id_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("10000-14000"),
			},
			"security_group_tag_prefix": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("SG_"),
			},
			"security_group_tag_preprovision": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"seed_switch_core_interfaces": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"sensitivity": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("low"),
			},
			"server": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"service_network_vlan_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("3000-3199"),
			},
			"shared_vpc_domain_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(1),
			},
			"site_id": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"skip_certificate_verification": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"snmp_trap": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(true),
			},
			"spine_switch_core_interfaces": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"static_underlay_ip_allocation": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"stp_bridge_priority": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(0),
			},
			"stp_root_option": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("unmanaged"),
			},
			"stp_vlan_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("1,3-5,7,9-11"),
			},
			"strict_config_compliance_mode": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"sub_interface_dot1q_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("2-511"),
			},
			"syslog_anomalies": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"syslog_facility": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"syslog_server_collection": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"syslog_server_vrf_collection": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"syslog_servers": schema.SetAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"syslog_severity_collection": schema.SetAttribute{
				ElementType:         types.Int64Type,
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"target_subnet_mask": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(30),
			},
			"tcam_allocation": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(true),
			},
			"telemetry_collection": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"telemetry_collection_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("outOfBand"),
			},
			"telemetry_source_interface": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"telemetry_source_vrf": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"telemetry_status": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The telemetry status of the fabric_vxlan_evpn resource",
				MarkdownDescription: "The telemetry status of the fabric_vxlan_evpn resource",
				Default:             stringdefault.StaticString("enabled"),
			},
			"telemetry_streaming_protocol": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("ipv4"),
			},
			"tenant_dhcp": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(true),
			},
			"tenant_routed_multicast": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"tenant_routed_multicast_ipv6": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"traffic_analytics": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("enabled"),
			},
			"traffic_analytics_filter_rules": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("supported"),
			},
			"traffic_analytics_mode": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("full"),
			},
			"traffic_analytics_rules_enabled": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(true),
			},
			"trap_forwarder_status": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The trap forwarder status of the fabric_vxlan_evpn resource",
				MarkdownDescription: "The trap forwarder status of the fabric_vxlan_evpn resource",
				Default:             stringdefault.StaticString("enabled"),
			},
			"trustpoint_label": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"udp_categorization": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("supported"),
			},
			"udp_categorization_support": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("supported"),
			},
			"un_numbered_bootstrap_lb_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(253),
			},
			"un_numbered_dhcp_end_address": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"un_numbered_dhcp_start_address": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"underlay_ipv6": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"vpc_auto_recovery_timer": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(360),
			},
			"vpc_delay_restore_timer": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(150),
			},
			"vpc_domain_id_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("1-1000"),
			},
			"vpc_ipv6_neighbor_discovery_sync": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(true),
			},
			"vpc_layer3_peer_router": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(true),
			},
			"vpc_peer_keep_alive_option": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("management"),
			},
			"vpc_peer_link_enable_native_vlan": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"vpc_peer_link_port_channel_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("500"),
			},
			"vpc_peer_link_vlan": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("3600"),
			},
			"vpc_tor_delay_restore_timer": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(30),
			},
			"vrf_extension_template": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("Default_VRF_Extension_Universal"),
			},
			"vrf_flow_rules": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"vrf_flow_rule_attributes": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"vrf_flow_rule_attribute_id": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"vrf_flow_rule_bidirectional": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "",
										MarkdownDescription: "",
										Default:             booldefault.StaticBool(false),
									},
									"vrf_flow_rule_dst_ip": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"vrf_flow_rule_dst_port": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"vrf_flow_rule_protocol": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"vrf_flow_rule_src_ip": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
									"vrf_flow_rule_src_port": schema.StringAttribute{
										Optional:            true,
										Description:         "",
										MarkdownDescription: "",
									},
								},
								CustomType: VrfFlowRuleAttributesType{
									ObjectType: types.ObjectType{
										AttrTypes: VrfFlowRuleAttributesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"vrf_flow_rule_name": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"vrf_flow_rule_subnets": schema.SetAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"vrf_flow_rule_tenant": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"vrf_flow_rule_uuid": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"vrf_flow_rule_vrf": schema.StringAttribute{
							Optional:            true,
							Description:         "",
							MarkdownDescription: "",
						},
					},
					CustomType: VrfFlowRulesType{
						ObjectType: types.ObjectType{
							AttrTypes: VrfFlowRulesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"vrf_lite_auto_config": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("manual"),
			},
			"vrf_lite_macsec": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"vrf_lite_macsec_algorithm": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("AES_128_CMAC"),
			},
			"vrf_lite_macsec_cipher_suite": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("GCM-AES-XPN-256"),
			},
			"vrf_lite_macsec_fallback_algorithm": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("AES_128_CMAC"),
			},
			"vrf_lite_macsec_fallback_key_string": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"vrf_lite_macsec_key_string": schema.StringAttribute{
				Optional:            true,
				Description:         "",
				MarkdownDescription: "",
			},
			"vrf_lite_subnet_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("10.33.0.0/16"),
			},
			"vrf_lite_subnet_target_mask": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             int64default.StaticInt64(30),
			},
			"vrf_route_import_id_reallocation": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             booldefault.StaticBool(false),
			},
			"vrf_template": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("Default_VRF_Universal"),
			},
			"vrf_vlan_range": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "",
				MarkdownDescription: "",
				Default:             stringdefault.StaticString("2000-2299"),
			},
		},
	}
}

type FabricVxlanModel struct {
	Aaa                                        types.Bool    `tfsdk:"aaa"`
	AdvancedSshOption                          types.Bool    `tfsdk:"advanced_ssh_option"`
	AdvertisePhysicalIp                        types.Bool    `tfsdk:"advertise_physical_ip"`
	AdvertisePhysicalIpOnBorder                types.Bool    `tfsdk:"advertise_physical_ip_on_border"`
	AimlQos                                    types.Bool    `tfsdk:"aiml_qos"`
	AimlQosPolicy                              types.String  `tfsdk:"aiml_qos_policy"`
	AlertSuspend                               types.String  `tfsdk:"alert_suspend"`
	AllowVlanOnLeafTorPairing                  types.String  `tfsdk:"allow_vlan_on_leaf_tor_pairing"`
	AllowedActions                             types.Set     `tfsdk:"allowed_actions"`
	AnalysisSettingsIsEnabled                  types.Bool    `tfsdk:"analysis_settings_is_enabled"`
	AnycastBorderGatewayAdvertisePhysicalIp    types.Bool    `tfsdk:"anycast_border_gateway_advertise_physical_ip"`
	AnycastGatewayMac                          types.String  `tfsdk:"anycast_gateway_mac"`
	AnycastLoopbackId                          types.Int64   `tfsdk:"anycast_loopback_id"`
	AnycastRendezvousPointIpRange              types.String  `tfsdk:"anycast_rendezvous_point_ip_range"`
	AutoBgpNeighborDescription                 types.Bool    `tfsdk:"auto_bgp_neighbor_description"`
	AutoSymmetricDefaultVrf                    types.Bool    `tfsdk:"auto_symmetric_default_vrf"`
	AutoSymmetricVrfLite                       types.Bool    `tfsdk:"auto_symmetric_vrf_lite"`
	AutoUniqueVrfLiteIpPrefix                  types.Bool    `tfsdk:"auto_unique_vrf_lite_ip_prefix"`
	AutoVrfLiteDefaultVrf                      types.Bool    `tfsdk:"auto_vrf_lite_default_vrf"`
	Banner                                     types.String  `tfsdk:"banner"`
	Bfd                                        types.Bool    `tfsdk:"bfd"`
	BfdAuthentication                          types.Bool    `tfsdk:"bfd_authentication"`
	BfdAuthenticationKey                       types.String  `tfsdk:"bfd_authentication_key"`
	BfdAuthenticationKeyId                     types.Int64   `tfsdk:"bfd_authentication_key_id"`
	BfdIbgp                                    types.Bool    `tfsdk:"bfd_ibgp"`
	BfdIsis                                    types.Bool    `tfsdk:"bfd_isis"`
	BfdOspf                                    types.Bool    `tfsdk:"bfd_ospf"`
	BfdPim                                     types.Bool    `tfsdk:"bfd_pim"`
	BgpAsn                                     types.String  `tfsdk:"bgp_asn"`
	BgpAuthentication                          types.Bool    `tfsdk:"bgp_authentication"`
	BgpAuthenticationKey                       types.String  `tfsdk:"bgp_authentication_key"`
	BgpAuthenticationKeyType                   types.String  `tfsdk:"bgp_authentication_key_type"`
	BgpLoopbackId                              types.Int64   `tfsdk:"bgp_loopback_id"`
	BgpLoopbackIpRange                         types.String  `tfsdk:"bgp_loopback_ip_range"`
	BgpLoopbackIpv6Range                       types.String  `tfsdk:"bgp_loopback_ipv6_range"`
	BootstrapMultiSubnet                       types.String  `tfsdk:"bootstrap_multi_subnet"`
	BrownfieldNetworkNameFormat                types.String  `tfsdk:"brownfield_network_name_format"`
	BrownfieldSkipOverlayNetworkAttachments    types.Bool    `tfsdk:"brownfield_skip_overlay_network_attachments"`
	Category                                   types.String  `tfsdk:"category"`
	Cdp                                        types.Bool    `tfsdk:"cdp"`
	ControllerStatus                           types.String  `tfsdk:"controller_status"`
	CoppPolicy                                 types.String  `tfsdk:"copp_policy"`
	Cost                                       types.Float64 `tfsdk:"cost"`
	Day0Bootstrap                              types.Bool    `tfsdk:"day0_bootstrap"`
	DefaultPrivateVlanSecondaryNetworkTemplate types.String  `tfsdk:"default_private_vlan_secondary_network_template"`
	DefaultQueuingPolicy                       types.Bool    `tfsdk:"default_queuing_policy"`
	DefaultQueuingPolicyCloudscale             types.String  `tfsdk:"default_queuing_policy_cloudscale"`
	DefaultQueuingPolicyOther                  types.String  `tfsdk:"default_queuing_policy_other"`
	DefaultQueuingPolicyRSeries                types.String  `tfsdk:"default_queuing_policy_r_series"`
	DefaultVrfRedistributionBgpRouteMap        types.String  `tfsdk:"default_vrf_redistribution_bgp_route_map"`
	DhcpEndAddress                             types.String  `tfsdk:"dhcp_end_address"`
	DhcpProtocolVersion                        types.String  `tfsdk:"dhcp_protocol_version"`
	DhcpStartAddress                           types.String  `tfsdk:"dhcp_start_address"`
	DnsCollection                              types.Set     `tfsdk:"dns_collection"`
	DnsVrfCollection                           types.Set     `tfsdk:"dns_vrf_collection"`
	Email                                      types.List    `tfsdk:"email"`
	ExportFormat                               types.String  `tfsdk:"export_format"`
	ExportType                                 types.String  `tfsdk:"export_type"`
	ExtraConfigAaa                             types.String  `tfsdk:"extra_config_aaa"`
	ExtraConfigIntraFabricLinks                types.String  `tfsdk:"extra_config_intra_fabric_links"`
	ExtraConfigLeaf                            types.String  `tfsdk:"extra_config_leaf"`
	ExtraConfigNxosBootstrap                   types.String  `tfsdk:"extra_config_nxos_bootstrap"`
	ExtraConfigSpine                           types.String  `tfsdk:"extra_config_spine"`
	ExtraConfigTor                             types.String  `tfsdk:"extra_config_tor"`
	FabricInterfaceType                        types.String  `tfsdk:"fabric_interface_type"`
	FabricMtu                                  types.Int64   `tfsdk:"fabric_mtu"`
	FabricName                                 types.String  `tfsdk:"fabric_name"`
	FabricType                                 types.String  `tfsdk:"fabric_type"`
	FabricVpcDomainId                          types.Bool    `tfsdk:"fabric_vpc_domain_id"`
	FabricVpcQos                               types.Bool    `tfsdk:"fabric_vpc_qos"`
	FabricVpcQosPolicyName                     types.String  `tfsdk:"fabric_vpc_qos_policy_name"`
	FlowTelemetry                              types.Bool    `tfsdk:"flow_telemetry"`
	GreenfieldDebugFlag                        types.String  `tfsdk:"greenfield_debug_flag"`
	HostInterfaceAdminState                    types.Bool    `tfsdk:"host_interface_admin_state"`
	IbgpPeerTemplate                           types.String  `tfsdk:"ibgp_peer_template"`
	Id                                         types.String  `tfsdk:"id"`
	InbandDhcpServers                          types.String  `tfsdk:"inband_dhcp_servers"`
	InbandManagement                           types.Bool    `tfsdk:"inband_management"`
	InterfaceFlowRules                         types.List    `tfsdk:"interface_flow_rules"`
	InterfaceRules                             types.List    `tfsdk:"interface_rules"`
	InterfaceStatisticsLoadInterval            types.Int64   `tfsdk:"interface_statistics_load_interval"`
	IntraFabricSubnetRange                     types.String  `tfsdk:"intra_fabric_subnet_range"`
	IpServiceLevelAgreementIdRange             types.String  `tfsdk:"ip_service_level_agreement_id_range"`
	Ipv6AnycastRendezvousPointIpRange          types.String  `tfsdk:"ipv6_anycast_rendezvous_point_ip_range"`
	Ipv6LinkLocal                              types.Bool    `tfsdk:"ipv6_link_local"`
	Ipv6MulticastGroupSubnet                   types.String  `tfsdk:"ipv6_multicast_group_subnet"`
	Ipv6SubnetRange                            types.String  `tfsdk:"ipv6_subnet_range"`
	Ipv6SubnetTargetMask                       types.Int64   `tfsdk:"ipv6_subnet_target_mask"`
	IsisAreaNumber                             types.String  `tfsdk:"isis_area_number"`
	IsisAuthentication                         types.Bool    `tfsdk:"isis_authentication"`
	IsisAuthenticationKey                      types.String  `tfsdk:"isis_authentication_key"`
	IsisAuthenticationKeychainKeyId            types.Int64   `tfsdk:"isis_authentication_keychain_key_id"`
	IsisAuthenticationKeychainName             types.String  `tfsdk:"isis_authentication_keychain_name"`
	IsisLevel                                  types.String  `tfsdk:"isis_level"`
	IsisOverload                               types.Bool    `tfsdk:"isis_overload"`
	IsisOverloadElapseTime                     types.Int64   `tfsdk:"isis_overload_elapse_time"`
	IsisPointToPoint                           types.Bool    `tfsdk:"isis_point_to_point"`
	KeyManagementEntityServerIp                types.String  `tfsdk:"key_management_entity_server_ip"`
	KeyManagementEntityServerPort              types.Int64   `tfsdk:"key_management_entity_server_port"`
	L2HostInterfaceMtu                         types.Int64   `tfsdk:"l2_host_interface_mtu"`
	L2VniRange                                 types.String  `tfsdk:"l2_vni_range"`
	L3OutFlowRules                             types.List    `tfsdk:"l3_out_flow_rules"`
	L3VniIpv6MulticastGroup                    types.String  `tfsdk:"l3_vni_ipv6_multicast_group"`
	L3VniNoVlanDefaultOption                   types.Bool    `tfsdk:"l3_vni_no_vlan_default_option"`
	L3VniRange                                 types.String  `tfsdk:"l3_vni_range"`
	L3vniMulticastGroup                        types.String  `tfsdk:"l3vni_multicast_group"`
	LeafToRIdRange                             types.Bool    `tfsdk:"leaf_to_r_id_range"`
	LeafTorVpcPortChannelIdRange               types.String  `tfsdk:"leaf_tor_vpc_port_channel_id_range"`
	LeafibgpPeerTemplate                       types.String  `tfsdk:"leafibgp_peer_template"`
	LicenseTier                                types.String  `tfsdk:"license_tier"`
	LinkStateRoutingProtocol                   types.String  `tfsdk:"link_state_routing_protocol"`
	LinkStateRoutingTag                        types.String  `tfsdk:"link_state_routing_tag"`
	LocalDhcpServer                            types.Bool    `tfsdk:"local_dhcp_server"`
	Location                                   LocationValue `tfsdk:"location"`
	Macsec                                     types.Bool    `tfsdk:"macsec"`
	MacsecAlgorithm                            types.String  `tfsdk:"macsec_algorithm"`
	MacsecCipherSuite                          types.String  `tfsdk:"macsec_cipher_suite"`
	MacsecFallbackAlgorithm                    types.String  `tfsdk:"macsec_fallback_algorithm"`
	MacsecFallbackKeyString                    types.String  `tfsdk:"macsec_fallback_key_string"`
	MacsecKeyString                            types.String  `tfsdk:"macsec_key_string"`
	MacsecReportTimer                          types.Int64   `tfsdk:"macsec_report_timer"`
	ManagementGateway                          types.String  `tfsdk:"management_gateway"`
	ManagementIpv4Prefix                       types.Int64   `tfsdk:"management_ipv4_prefix"`
	ManagementIpv6Prefix                       types.Int64   `tfsdk:"management_ipv6_prefix"`
	MessageBus                                 types.List    `tfsdk:"message_bus"`
	Microburst                                 types.Bool    `tfsdk:"microburst"`
	MplsHandoff                                types.Bool    `tfsdk:"mpls_handoff"`
	MplsIsisAreaNumber                         types.String  `tfsdk:"mpls_isis_area_number"`
	MplsLoopbackIdentifier                     types.Int64   `tfsdk:"mpls_loopback_identifier"`
	MplsLoopbackIpRange                        types.String  `tfsdk:"mpls_loopback_ip_range"`
	MstInstanceRange                           types.String  `tfsdk:"mst_instance_range"`
	MulticastGroupSubnet                       types.String  `tfsdk:"multicast_group_subnet"`
	MvpnVrfRouteImportId                       types.Bool    `tfsdk:"mvpn_vrf_route_import_id"`
	MvpnVrfRouteImportIdRange                  types.String  `tfsdk:"mvpn_vrf_route_import_id_range"`
	NetFlow                                    types.Bool    `tfsdk:"net_flow"`
	Netflow                                    types.Bool    `tfsdk:"netflow"`
	NetflowExporterCollection                  types.List    `tfsdk:"netflow_exporter_collection"`
	NetflowMonitorCollection                   types.List    `tfsdk:"netflow_monitor_collection"`
	NetflowRecordCollection                    types.List    `tfsdk:"netflow_record_collection"`
	NetflowSamplerCollection                   types.List    `tfsdk:"netflow_sampler_collection"`
	NetworkExtensionTemplate                   types.String  `tfsdk:"network_extension_template"`
	NetworkTemplate                            types.String  `tfsdk:"network_template"`
	NetworkVlanRange                           types.String  `tfsdk:"network_vlan_range"`
	NextGenerationOam                          types.Bool    `tfsdk:"next_generation_oam"`
	NgoamSouthBoundLoopDetect                  types.Bool    `tfsdk:"ngoam_south_bound_loop_detect"`
	NgoamSouthBoundLoopDetectProbeInterval     types.Int64   `tfsdk:"ngoam_south_bound_loop_detect_probe_interval"`
	NgoamSouthBoundLoopDetectRecoveryInterval  types.Int64   `tfsdk:"ngoam_south_bound_loop_detect_recovery_interval"`
	NtpServerCollection                        types.Set     `tfsdk:"ntp_server_collection"`
	NtpServerVrfCollection                     types.Set     `tfsdk:"ntp_server_vrf_collection"`
	NveHoldDownTimer                           types.Int64   `tfsdk:"nve_hold_down_timer"`
	NveLoopbackId                              types.Int64   `tfsdk:"nve_loopback_id"`
	NveLoopbackIpRange                         types.String  `tfsdk:"nve_loopback_ip_range"`
	NveLoopbackIpv6Range                       types.String  `tfsdk:"nve_loopback_ipv6_range"`
	Nxapi                                      types.Bool    `tfsdk:"nxapi"`
	NxapiHttp                                  types.Bool    `tfsdk:"nxapi_http"`
	NxapiHttpPort                              types.Int64   `tfsdk:"nxapi_http_port"`
	NxapiHttpsPort                             types.Int64   `tfsdk:"nxapi_https_port"`
	ObjectTrackingNumberRange                  types.String  `tfsdk:"object_tracking_number_range"`
	OperatingMode                              types.String  `tfsdk:"operating_mode"`
	OrchestrationStatus                        types.String  `tfsdk:"orchestration_status"`
	OspfAreaId                                 types.String  `tfsdk:"ospf_area_id"`
	OspfAuthentication                         types.Bool    `tfsdk:"ospf_authentication"`
	OspfAuthenticationKey                      types.String  `tfsdk:"ospf_authentication_key"`
	OspfAuthenticationKeyId                    types.Int64   `tfsdk:"ospf_authentication_key_id"`
	OverlayMode                                types.String  `tfsdk:"overlay_mode"`
	PerVrfLoopbackAutoProvision                types.Bool    `tfsdk:"per_vrf_loopback_auto_provision"`
	PerVrfLoopbackAutoProvisionIpv6            types.Bool    `tfsdk:"per_vrf_loopback_auto_provision_ipv6"`
	PerVrfLoopbackIpRange                      types.String  `tfsdk:"per_vrf_loopback_ip_range"`
	PerVrfLoopbackIpv6Range                    types.String  `tfsdk:"per_vrf_loopback_ipv6_range"`
	PerformanceMonitoring                      types.Bool    `tfsdk:"performance_monitoring"`
	PhantomRendezvousPointLoopbackId1          types.Int64   `tfsdk:"phantom_rendezvous_point_loopback_id1"`
	PhantomRendezvousPointLoopbackId2          types.Int64   `tfsdk:"phantom_rendezvous_point_loopback_id2"`
	PhantomRendezvousPointLoopbackId3          types.Int64   `tfsdk:"phantom_rendezvous_point_loopback_id3"`
	PhantomRendezvousPointLoopbackId4          types.Int64   `tfsdk:"phantom_rendezvous_point_loopback_id4"`
	PimHelloAuthentication                     types.Bool    `tfsdk:"pim_hello_authentication"`
	PimHelloAuthenticationKey                  types.String  `tfsdk:"pim_hello_authentication_key"`
	PolicyBasedRouting                         types.Bool    `tfsdk:"policy_based_routing"`
	PowerRedundancyMode                        types.String  `tfsdk:"power_redundancy_mode"`
	PreInterfaceConfigLeaf                     types.String  `tfsdk:"pre_interface_config_leaf"`
	PreInterfaceConfigSpine                    types.String  `tfsdk:"pre_interface_config_spine"`
	PreInterfaceConfigTor                      types.String  `tfsdk:"pre_interface_config_tor"`
	PriorityFlowControlWatchInterval           types.Int64   `tfsdk:"priority_flow_control_watch_interval"`
	PrivateVlan                                types.Bool    `tfsdk:"private_vlan"`
	Ptp                                        types.Bool    `tfsdk:"ptp"`
	PtpDomainId                                types.Int64   `tfsdk:"ptp_domain_id"`
	PtpLoopbackId                              types.Int64   `tfsdk:"ptp_loopback_id"`
	PtpVlanId                                  types.Int64   `tfsdk:"ptp_vlan_id"`
	QuantumKeyDistribution                     types.Bool    `tfsdk:"quantum_key_distribution"`
	QuantumKeyDistributionProfileName          types.String  `tfsdk:"quantum_key_distribution_profile_name"`
	RealTimeBackup                             types.Bool    `tfsdk:"real_time_backup"`
	RealTimeInterfaceStatisticsCollection      types.Bool    `tfsdk:"real_time_interface_statistics_collection"`
	RendezvousPointCount                       types.Int64   `tfsdk:"rendezvous_point_count"`
	RendezvousPointLoopbackId                  types.Int64   `tfsdk:"rendezvous_point_loopback_id"`
	RendezvousPointMode                        types.String  `tfsdk:"rendezvous_point_mode"`
	ReplicationMode                            types.String  `tfsdk:"replication_mode"`
	RouteMapSequenceNumberRange                types.String  `tfsdk:"route_map_sequence_number_range"`
	RouteReflectorCount                        types.Int64   `tfsdk:"route_reflector_count"`
	RouterIdRange                              types.String  `tfsdk:"router_id_range"`
	SFlow                                      types.Bool    `tfsdk:"s_flow"`
	ScheduledBackup                            types.Bool    `tfsdk:"scheduled_backup"`
	ScheduledBackupTime                        types.String  `tfsdk:"scheduled_backup_time"`
	SecurityDomain                             types.String  `tfsdk:"security_domain"`
	SecurityGroupStatus                        types.String  `tfsdk:"security_group_status"`
	SecurityGroupTag                           types.Bool    `tfsdk:"security_group_tag"`
	SecurityGroupTagIdRange                    types.String  `tfsdk:"security_group_tag_id_range"`
	SecurityGroupTagPrefix                     types.String  `tfsdk:"security_group_tag_prefix"`
	SecurityGroupTagPreprovision               types.Bool    `tfsdk:"security_group_tag_preprovision"`
	SeedSwitchCoreInterfaces                   types.String  `tfsdk:"seed_switch_core_interfaces"`
	Sensitivity                                types.String  `tfsdk:"sensitivity"`
	Server                                     types.String  `tfsdk:"server"`
	ServiceNetworkVlanRange                    types.String  `tfsdk:"service_network_vlan_range"`
	SharedVpcDomainId                          types.Int64   `tfsdk:"shared_vpc_domain_id"`
	SiteId                                     types.String  `tfsdk:"site_id"`
	SkipCertificateVerification                types.Bool    `tfsdk:"skip_certificate_verification"`
	SnmpTrap                                   types.Bool    `tfsdk:"snmp_trap"`
	SpineSwitchCoreInterfaces                  types.String  `tfsdk:"spine_switch_core_interfaces"`
	StaticUnderlayIpAllocation                 types.Bool    `tfsdk:"static_underlay_ip_allocation"`
	StpBridgePriority                          types.Int64   `tfsdk:"stp_bridge_priority"`
	StpRootOption                              types.String  `tfsdk:"stp_root_option"`
	StpVlanRange                               types.String  `tfsdk:"stp_vlan_range"`
	StrictConfigComplianceMode                 types.Bool    `tfsdk:"strict_config_compliance_mode"`
	SubInterfaceDot1qRange                     types.String  `tfsdk:"sub_interface_dot1q_range"`
	SyslogAnomalies                            types.Set     `tfsdk:"syslog_anomalies"`
	SyslogFacility                             types.String  `tfsdk:"syslog_facility"`
	SyslogServerCollection                     types.Set     `tfsdk:"syslog_server_collection"`
	SyslogServerVrfCollection                  types.Set     `tfsdk:"syslog_server_vrf_collection"`
	SyslogServers                              types.Set     `tfsdk:"syslog_servers"`
	SyslogSeverityCollection                   types.Set     `tfsdk:"syslog_severity_collection"`
	TargetSubnetMask                           types.Int64   `tfsdk:"target_subnet_mask"`
	TcamAllocation                             types.Bool    `tfsdk:"tcam_allocation"`
	TelemetryCollection                        types.Bool    `tfsdk:"telemetry_collection"`
	TelemetryCollectionType                    types.String  `tfsdk:"telemetry_collection_type"`
	TelemetrySourceInterface                   types.String  `tfsdk:"telemetry_source_interface"`
	TelemetrySourceVrf                         types.String  `tfsdk:"telemetry_source_vrf"`
	TelemetryStatus                            types.String  `tfsdk:"telemetry_status"`
	TelemetryStreamingProtocol                 types.String  `tfsdk:"telemetry_streaming_protocol"`
	TenantDhcp                                 types.Bool    `tfsdk:"tenant_dhcp"`
	TenantRoutedMulticast                      types.Bool    `tfsdk:"tenant_routed_multicast"`
	TenantRoutedMulticastIpv6                  types.Bool    `tfsdk:"tenant_routed_multicast_ipv6"`
	TrafficAnalytics                           types.String  `tfsdk:"traffic_analytics"`
	TrafficAnalyticsFilterRules                types.String  `tfsdk:"traffic_analytics_filter_rules"`
	TrafficAnalyticsMode                       types.String  `tfsdk:"traffic_analytics_mode"`
	TrafficAnalyticsRulesEnabled               types.Bool    `tfsdk:"traffic_analytics_rules_enabled"`
	TrapForwarderStatus                        types.String  `tfsdk:"trap_forwarder_status"`
	TrustpointLabel                            types.String  `tfsdk:"trustpoint_label"`
	UdpCategorization                          types.String  `tfsdk:"udp_categorization"`
	UdpCategorizationSupport                   types.String  `tfsdk:"udp_categorization_support"`
	UnNumberedBootstrapLbId                    types.Int64   `tfsdk:"un_numbered_bootstrap_lb_id"`
	UnNumberedDhcpEndAddress                   types.String  `tfsdk:"un_numbered_dhcp_end_address"`
	UnNumberedDhcpStartAddress                 types.String  `tfsdk:"un_numbered_dhcp_start_address"`
	UnderlayIpv6                               types.Bool    `tfsdk:"underlay_ipv6"`
	VpcAutoRecoveryTimer                       types.Int64   `tfsdk:"vpc_auto_recovery_timer"`
	VpcDelayRestoreTimer                       types.Int64   `tfsdk:"vpc_delay_restore_timer"`
	VpcDomainIdRange                           types.String  `tfsdk:"vpc_domain_id_range"`
	VpcIpv6NeighborDiscoverySync               types.Bool    `tfsdk:"vpc_ipv6_neighbor_discovery_sync"`
	VpcLayer3PeerRouter                        types.Bool    `tfsdk:"vpc_layer3_peer_router"`
	VpcPeerKeepAliveOption                     types.String  `tfsdk:"vpc_peer_keep_alive_option"`
	VpcPeerLinkEnableNativeVlan                types.Bool    `tfsdk:"vpc_peer_link_enable_native_vlan"`
	VpcPeerLinkPortChannelId                   types.String  `tfsdk:"vpc_peer_link_port_channel_id"`
	VpcPeerLinkVlan                            types.String  `tfsdk:"vpc_peer_link_vlan"`
	VpcTorDelayRestoreTimer                    types.Int64   `tfsdk:"vpc_tor_delay_restore_timer"`
	VrfExtensionTemplate                       types.String  `tfsdk:"vrf_extension_template"`
	VrfFlowRules                               types.List    `tfsdk:"vrf_flow_rules"`
	VrfLiteAutoConfig                          types.String  `tfsdk:"vrf_lite_auto_config"`
	VrfLiteMacsec                              types.Bool    `tfsdk:"vrf_lite_macsec"`
	VrfLiteMacsecAlgorithm                     types.String  `tfsdk:"vrf_lite_macsec_algorithm"`
	VrfLiteMacsecCipherSuite                   types.String  `tfsdk:"vrf_lite_macsec_cipher_suite"`
	VrfLiteMacsecFallbackAlgorithm             types.String  `tfsdk:"vrf_lite_macsec_fallback_algorithm"`
	VrfLiteMacsecFallbackKeyString             types.String  `tfsdk:"vrf_lite_macsec_fallback_key_string"`
	VrfLiteMacsecKeyString                     types.String  `tfsdk:"vrf_lite_macsec_key_string"`
	VrfLiteSubnetRange                         types.String  `tfsdk:"vrf_lite_subnet_range"`
	VrfLiteSubnetTargetMask                    types.Int64   `tfsdk:"vrf_lite_subnet_target_mask"`
	VrfRouteImportIdReallocation               types.Bool    `tfsdk:"vrf_route_import_id_reallocation"`
	VrfTemplate                                types.String  `tfsdk:"vrf_template"`
	VrfVlanRange                               types.String  `tfsdk:"vrf_vlan_range"`
}

var _ basetypes.ObjectTypable = EmailType{}

type EmailType struct {
	basetypes.ObjectType
}

func (t EmailType) Equal(o attr.Type) bool {
	other, ok := o.(EmailType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EmailType) String() string {
	return "EmailType"
}

func (t EmailType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advisoriesAttribute, ok := attributes["advisories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advisories is missing from object`)

		return nil, diags
	}

	advisoriesVal, ok := advisoriesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advisories expected to be basetypes.SetValue, was: %T`, advisoriesAttribute))
	}

	anomaliesAttribute, ok := attributes["anomalies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anomalies is missing from object`)

		return nil, diags
	}

	anomaliesVal, ok := anomaliesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anomalies expected to be basetypes.SetValue, was: %T`, anomaliesAttribute))
	}

	collectionFrequencyInDaysAttribute, ok := attributes["collection_frequency_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_frequency_in_days is missing from object`)

		return nil, diags
	}

	collectionFrequencyInDaysVal, ok := collectionFrequencyInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_frequency_in_days expected to be basetypes.Int64Value, was: %T`, collectionFrequencyInDaysAttribute))
	}

	collectionTypeAttribute, ok := attributes["collection_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_type is missing from object`)

		return nil, diags
	}

	collectionTypeVal, ok := collectionTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_type expected to be basetypes.StringValue, was: %T`, collectionTypeAttribute))
	}

	formatAttribute, ok := attributes["format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`format is missing from object`)

		return nil, diags
	}

	formatVal, ok := formatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`format expected to be basetypes.StringValue, was: %T`, formatAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	onlyIncludeActiveAlertsAttribute, ok := attributes["only_include_active_alerts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`only_include_active_alerts is missing from object`)

		return nil, diags
	}

	onlyIncludeActiveAlertsVal, ok := onlyIncludeActiveAlertsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`only_include_active_alerts expected to be basetypes.BoolValue, was: %T`, onlyIncludeActiveAlertsAttribute))
	}

	receiverEmailAttribute, ok := attributes["receiver_email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`receiver_email is missing from object`)

		return nil, diags
	}

	receiverEmailVal, ok := receiverEmailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`receiver_email expected to be basetypes.StringValue, was: %T`, receiverEmailAttribute))
	}

	riskAndConformanceReportsAttribute, ok := attributes["risk_and_conformance_reports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`risk_and_conformance_reports is missing from object`)

		return nil, diags
	}

	riskAndConformanceReportsVal, ok := riskAndConformanceReportsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`risk_and_conformance_reports expected to be basetypes.SetValue, was: %T`, riskAndConformanceReportsAttribute))
	}

	startDateAttribute, ok := attributes["start_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_date is missing from object`)

		return nil, diags
	}

	startDateVal, ok := startDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_date expected to be basetypes.StringValue, was: %T`, startDateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EmailValue{
		Advisories:                advisoriesVal,
		Anomalies:                 anomaliesVal,
		CollectionFrequencyInDays: collectionFrequencyInDaysVal,
		CollectionType:            collectionTypeVal,
		Format:                    formatVal,
		Name:                      nameVal,
		OnlyIncludeActiveAlerts:   onlyIncludeActiveAlertsVal,
		ReceiverEmail:             receiverEmailVal,
		RiskAndConformanceReports: riskAndConformanceReportsVal,
		StartDate:                 startDateVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewEmailValueNull() EmailValue {
	return EmailValue{
		state: attr.ValueStateNull,
	}
}

func NewEmailValueUnknown() EmailValue {
	return EmailValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEmailValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EmailValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EmailValue Attribute Value",
				"While creating a EmailValue value, a missing attribute value was detected. "+
					"A EmailValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EmailValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EmailValue Attribute Type",
				"While creating a EmailValue value, an invalid attribute value was detected. "+
					"A EmailValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EmailValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EmailValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EmailValue Attribute Value",
				"While creating a EmailValue value, an extra attribute value was detected. "+
					"A EmailValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EmailValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEmailValueUnknown(), diags
	}

	advisoriesAttribute, ok := attributes["advisories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advisories is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	advisoriesVal, ok := advisoriesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advisories expected to be basetypes.SetValue, was: %T`, advisoriesAttribute))
	}

	anomaliesAttribute, ok := attributes["anomalies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anomalies is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	anomaliesVal, ok := anomaliesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anomalies expected to be basetypes.SetValue, was: %T`, anomaliesAttribute))
	}

	collectionFrequencyInDaysAttribute, ok := attributes["collection_frequency_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_frequency_in_days is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	collectionFrequencyInDaysVal, ok := collectionFrequencyInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_frequency_in_days expected to be basetypes.Int64Value, was: %T`, collectionFrequencyInDaysAttribute))
	}

	collectionTypeAttribute, ok := attributes["collection_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_type is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	collectionTypeVal, ok := collectionTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_type expected to be basetypes.StringValue, was: %T`, collectionTypeAttribute))
	}

	formatAttribute, ok := attributes["format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`format is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	formatVal, ok := formatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`format expected to be basetypes.StringValue, was: %T`, formatAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	onlyIncludeActiveAlertsAttribute, ok := attributes["only_include_active_alerts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`only_include_active_alerts is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	onlyIncludeActiveAlertsVal, ok := onlyIncludeActiveAlertsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`only_include_active_alerts expected to be basetypes.BoolValue, was: %T`, onlyIncludeActiveAlertsAttribute))
	}

	receiverEmailAttribute, ok := attributes["receiver_email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`receiver_email is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	receiverEmailVal, ok := receiverEmailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`receiver_email expected to be basetypes.StringValue, was: %T`, receiverEmailAttribute))
	}

	riskAndConformanceReportsAttribute, ok := attributes["risk_and_conformance_reports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`risk_and_conformance_reports is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	riskAndConformanceReportsVal, ok := riskAndConformanceReportsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`risk_and_conformance_reports expected to be basetypes.SetValue, was: %T`, riskAndConformanceReportsAttribute))
	}

	startDateAttribute, ok := attributes["start_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_date is missing from object`)

		return NewEmailValueUnknown(), diags
	}

	startDateVal, ok := startDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_date expected to be basetypes.StringValue, was: %T`, startDateAttribute))
	}

	if diags.HasError() {
		return NewEmailValueUnknown(), diags
	}

	return EmailValue{
		Advisories:                advisoriesVal,
		Anomalies:                 anomaliesVal,
		CollectionFrequencyInDays: collectionFrequencyInDaysVal,
		CollectionType:            collectionTypeVal,
		Format:                    formatVal,
		Name:                      nameVal,
		OnlyIncludeActiveAlerts:   onlyIncludeActiveAlertsVal,
		ReceiverEmail:             receiverEmailVal,
		RiskAndConformanceReports: riskAndConformanceReportsVal,
		StartDate:                 startDateVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewEmailValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EmailValue {
	object, diags := NewEmailValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEmailValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EmailType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEmailValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEmailValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEmailValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEmailValueMust(EmailValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EmailType) ValueType(ctx context.Context) attr.Value {
	return EmailValue{}
}

var _ basetypes.ObjectValuable = EmailValue{}

type EmailValue struct {
	Advisories                basetypes.SetValue    `tfsdk:"advisories"`
	Anomalies                 basetypes.SetValue    `tfsdk:"anomalies"`
	CollectionFrequencyInDays basetypes.Int64Value  `tfsdk:"collection_frequency_in_days"`
	CollectionType            basetypes.StringValue `tfsdk:"collection_type"`
	Format                    basetypes.StringValue `tfsdk:"format"`
	Name                      basetypes.StringValue `tfsdk:"name"`
	OnlyIncludeActiveAlerts   basetypes.BoolValue   `tfsdk:"only_include_active_alerts"`
	ReceiverEmail             basetypes.StringValue `tfsdk:"receiver_email"`
	RiskAndConformanceReports basetypes.SetValue    `tfsdk:"risk_and_conformance_reports"`
	StartDate                 basetypes.StringValue `tfsdk:"start_date"`
	state                     attr.ValueState
}

func (v EmailValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["advisories"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["anomalies"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["collection_frequency_in_days"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["collection_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["only_include_active_alerts"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["receiver_email"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["risk_and_conformance_reports"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["start_date"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Advisories.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advisories"] = val

		val, err = v.Anomalies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["anomalies"] = val

		val, err = v.CollectionFrequencyInDays.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection_frequency_in_days"] = val

		val, err = v.CollectionType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection_type"] = val

		val, err = v.Format.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["format"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OnlyIncludeActiveAlerts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["only_include_active_alerts"] = val

		val, err = v.ReceiverEmail.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["receiver_email"] = val

		val, err = v.RiskAndConformanceReports.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["risk_and_conformance_reports"] = val

		val, err = v.StartDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start_date"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EmailValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EmailValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EmailValue) String() string {
	return "EmailValue"
}

func (v EmailValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var advisoriesVal basetypes.SetValue
	switch {
	case v.Advisories.IsUnknown():
		advisoriesVal = types.SetUnknown(types.StringType)
	case v.Advisories.IsNull():
		advisoriesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		advisoriesVal, d = types.SetValue(types.StringType, v.Advisories.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advisories": basetypes.SetType{
				ElemType: types.StringType,
			},
			"anomalies": basetypes.SetType{
				ElemType: types.StringType,
			},
			"collection_frequency_in_days": basetypes.Int64Type{},
			"collection_type":              basetypes.StringType{},
			"format":                       basetypes.StringType{},
			"name":                         basetypes.StringType{},
			"only_include_active_alerts":   basetypes.BoolType{},
			"receiver_email":               basetypes.StringType{},
			"risk_and_conformance_reports": basetypes.SetType{
				ElemType: types.StringType,
			},
			"start_date": basetypes.StringType{},
		}), diags
	}

	var anomaliesVal basetypes.SetValue
	switch {
	case v.Anomalies.IsUnknown():
		anomaliesVal = types.SetUnknown(types.StringType)
	case v.Anomalies.IsNull():
		anomaliesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		anomaliesVal, d = types.SetValue(types.StringType, v.Anomalies.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advisories": basetypes.SetType{
				ElemType: types.StringType,
			},
			"anomalies": basetypes.SetType{
				ElemType: types.StringType,
			},
			"collection_frequency_in_days": basetypes.Int64Type{},
			"collection_type":              basetypes.StringType{},
			"format":                       basetypes.StringType{},
			"name":                         basetypes.StringType{},
			"only_include_active_alerts":   basetypes.BoolType{},
			"receiver_email":               basetypes.StringType{},
			"risk_and_conformance_reports": basetypes.SetType{
				ElemType: types.StringType,
			},
			"start_date": basetypes.StringType{},
		}), diags
	}

	var riskAndConformanceReportsVal basetypes.SetValue
	switch {
	case v.RiskAndConformanceReports.IsUnknown():
		riskAndConformanceReportsVal = types.SetUnknown(types.StringType)
	case v.RiskAndConformanceReports.IsNull():
		riskAndConformanceReportsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		riskAndConformanceReportsVal, d = types.SetValue(types.StringType, v.RiskAndConformanceReports.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advisories": basetypes.SetType{
				ElemType: types.StringType,
			},
			"anomalies": basetypes.SetType{
				ElemType: types.StringType,
			},
			"collection_frequency_in_days": basetypes.Int64Type{},
			"collection_type":              basetypes.StringType{},
			"format":                       basetypes.StringType{},
			"name":                         basetypes.StringType{},
			"only_include_active_alerts":   basetypes.BoolType{},
			"receiver_email":               basetypes.StringType{},
			"risk_and_conformance_reports": basetypes.SetType{
				ElemType: types.StringType,
			},
			"start_date": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"advisories": basetypes.SetType{
			ElemType: types.StringType,
		},
		"anomalies": basetypes.SetType{
			ElemType: types.StringType,
		},
		"collection_frequency_in_days": basetypes.Int64Type{},
		"collection_type":              basetypes.StringType{},
		"format":                       basetypes.StringType{},
		"name":                         basetypes.StringType{},
		"only_include_active_alerts":   basetypes.BoolType{},
		"receiver_email":               basetypes.StringType{},
		"risk_and_conformance_reports": basetypes.SetType{
			ElemType: types.StringType,
		},
		"start_date": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advisories":                   advisoriesVal,
			"anomalies":                    anomaliesVal,
			"collection_frequency_in_days": v.CollectionFrequencyInDays,
			"collection_type":              v.CollectionType,
			"format":                       v.Format,
			"name":                         v.Name,
			"only_include_active_alerts":   v.OnlyIncludeActiveAlerts,
			"receiver_email":               v.ReceiverEmail,
			"risk_and_conformance_reports": riskAndConformanceReportsVal,
			"start_date":                   v.StartDate,
		})

	return objVal, diags
}

func (v EmailValue) Equal(o attr.Value) bool {
	other, ok := o.(EmailValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Advisories.Equal(other.Advisories) {
		return false
	}

	if !v.Anomalies.Equal(other.Anomalies) {
		return false
	}

	if !v.CollectionFrequencyInDays.Equal(other.CollectionFrequencyInDays) {
		return false
	}

	if !v.CollectionType.Equal(other.CollectionType) {
		return false
	}

	if !v.Format.Equal(other.Format) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OnlyIncludeActiveAlerts.Equal(other.OnlyIncludeActiveAlerts) {
		return false
	}

	if !v.ReceiverEmail.Equal(other.ReceiverEmail) {
		return false
	}

	if !v.RiskAndConformanceReports.Equal(other.RiskAndConformanceReports) {
		return false
	}

	if !v.StartDate.Equal(other.StartDate) {
		return false
	}

	return true
}

func (v EmailValue) Type(ctx context.Context) attr.Type {
	return EmailType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EmailValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advisories": basetypes.SetType{
			ElemType: types.StringType,
		},
		"anomalies": basetypes.SetType{
			ElemType: types.StringType,
		},
		"collection_frequency_in_days": basetypes.Int64Type{},
		"collection_type":              basetypes.StringType{},
		"format":                       basetypes.StringType{},
		"name":                         basetypes.StringType{},
		"only_include_active_alerts":   basetypes.BoolType{},
		"receiver_email":               basetypes.StringType{},
		"risk_and_conformance_reports": basetypes.SetType{
			ElemType: types.StringType,
		},
		"start_date": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InterfaceFlowRulesType{}

type InterfaceFlowRulesType struct {
	basetypes.ObjectType
}

func (t InterfaceFlowRulesType) Equal(o attr.Type) bool {
	other, ok := o.(InterfaceFlowRulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InterfaceFlowRulesType) String() string {
	return "InterfaceFlowRulesType"
}

func (t InterfaceFlowRulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceFlowRuleAttributesAttribute, ok := attributes["interface_flow_rule_attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_attributes is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleAttributesVal, ok := interfaceFlowRuleAttributesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_attributes expected to be basetypes.ListValue, was: %T`, interfaceFlowRuleAttributesAttribute))
	}

	interfaceFlowRuleInterfaceCollectionAttribute, ok := attributes["interface_flow_rule_interface_collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_interface_collection is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleInterfaceCollectionVal, ok := interfaceFlowRuleInterfaceCollectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_interface_collection expected to be basetypes.ListValue, was: %T`, interfaceFlowRuleInterfaceCollectionAttribute))
	}

	interfaceFlowRuleNameAttribute, ok := attributes["interface_flow_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_name is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleNameVal, ok := interfaceFlowRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_name expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleNameAttribute))
	}

	interfaceFlowRuleSubnetsAttribute, ok := attributes["interface_flow_rule_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_subnets is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleSubnetsVal, ok := interfaceFlowRuleSubnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_subnets expected to be basetypes.SetValue, was: %T`, interfaceFlowRuleSubnetsAttribute))
	}

	interfaceFlowRuleTypeAttribute, ok := attributes["interface_flow_rule_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_type is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleTypeVal, ok := interfaceFlowRuleTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_type expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleTypeAttribute))
	}

	interfaceFlowRuleUuidAttribute, ok := attributes["interface_flow_rule_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_uuid is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleUuidVal, ok := interfaceFlowRuleUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_uuid expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleUuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InterfaceFlowRulesValue{
		InterfaceFlowRuleAttributes:          interfaceFlowRuleAttributesVal,
		InterfaceFlowRuleInterfaceCollection: interfaceFlowRuleInterfaceCollectionVal,
		InterfaceFlowRuleName:                interfaceFlowRuleNameVal,
		InterfaceFlowRuleSubnets:             interfaceFlowRuleSubnetsVal,
		InterfaceFlowRuleType:                interfaceFlowRuleTypeVal,
		InterfaceFlowRuleUuid:                interfaceFlowRuleUuidVal,
		state:                                attr.ValueStateKnown,
	}, diags
}

func NewInterfaceFlowRulesValueNull() InterfaceFlowRulesValue {
	return InterfaceFlowRulesValue{
		state: attr.ValueStateNull,
	}
}

func NewInterfaceFlowRulesValueUnknown() InterfaceFlowRulesValue {
	return InterfaceFlowRulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInterfaceFlowRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InterfaceFlowRulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InterfaceFlowRulesValue Attribute Value",
				"While creating a InterfaceFlowRulesValue value, a missing attribute value was detected. "+
					"A InterfaceFlowRulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceFlowRulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InterfaceFlowRulesValue Attribute Type",
				"While creating a InterfaceFlowRulesValue value, an invalid attribute value was detected. "+
					"A InterfaceFlowRulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceFlowRulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InterfaceFlowRulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InterfaceFlowRulesValue Attribute Value",
				"While creating a InterfaceFlowRulesValue value, an extra attribute value was detected. "+
					"A InterfaceFlowRulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InterfaceFlowRulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInterfaceFlowRulesValueUnknown(), diags
	}

	interfaceFlowRuleAttributesAttribute, ok := attributes["interface_flow_rule_attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_attributes is missing from object`)

		return NewInterfaceFlowRulesValueUnknown(), diags
	}

	interfaceFlowRuleAttributesVal, ok := interfaceFlowRuleAttributesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_attributes expected to be basetypes.ListValue, was: %T`, interfaceFlowRuleAttributesAttribute))
	}

	interfaceFlowRuleInterfaceCollectionAttribute, ok := attributes["interface_flow_rule_interface_collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_interface_collection is missing from object`)

		return NewInterfaceFlowRulesValueUnknown(), diags
	}

	interfaceFlowRuleInterfaceCollectionVal, ok := interfaceFlowRuleInterfaceCollectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_interface_collection expected to be basetypes.ListValue, was: %T`, interfaceFlowRuleInterfaceCollectionAttribute))
	}

	interfaceFlowRuleNameAttribute, ok := attributes["interface_flow_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_name is missing from object`)

		return NewInterfaceFlowRulesValueUnknown(), diags
	}

	interfaceFlowRuleNameVal, ok := interfaceFlowRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_name expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleNameAttribute))
	}

	interfaceFlowRuleSubnetsAttribute, ok := attributes["interface_flow_rule_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_subnets is missing from object`)

		return NewInterfaceFlowRulesValueUnknown(), diags
	}

	interfaceFlowRuleSubnetsVal, ok := interfaceFlowRuleSubnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_subnets expected to be basetypes.SetValue, was: %T`, interfaceFlowRuleSubnetsAttribute))
	}

	interfaceFlowRuleTypeAttribute, ok := attributes["interface_flow_rule_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_type is missing from object`)

		return NewInterfaceFlowRulesValueUnknown(), diags
	}

	interfaceFlowRuleTypeVal, ok := interfaceFlowRuleTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_type expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleTypeAttribute))
	}

	interfaceFlowRuleUuidAttribute, ok := attributes["interface_flow_rule_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_uuid is missing from object`)

		return NewInterfaceFlowRulesValueUnknown(), diags
	}

	interfaceFlowRuleUuidVal, ok := interfaceFlowRuleUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_uuid expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleUuidAttribute))
	}

	if diags.HasError() {
		return NewInterfaceFlowRulesValueUnknown(), diags
	}

	return InterfaceFlowRulesValue{
		InterfaceFlowRuleAttributes:          interfaceFlowRuleAttributesVal,
		InterfaceFlowRuleInterfaceCollection: interfaceFlowRuleInterfaceCollectionVal,
		InterfaceFlowRuleName:                interfaceFlowRuleNameVal,
		InterfaceFlowRuleSubnets:             interfaceFlowRuleSubnetsVal,
		InterfaceFlowRuleType:                interfaceFlowRuleTypeVal,
		InterfaceFlowRuleUuid:                interfaceFlowRuleUuidVal,
		state:                                attr.ValueStateKnown,
	}, diags
}

func NewInterfaceFlowRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InterfaceFlowRulesValue {
	object, diags := NewInterfaceFlowRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInterfaceFlowRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InterfaceFlowRulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInterfaceFlowRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInterfaceFlowRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInterfaceFlowRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInterfaceFlowRulesValueMust(InterfaceFlowRulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InterfaceFlowRulesType) ValueType(ctx context.Context) attr.Value {
	return InterfaceFlowRulesValue{}
}

var _ basetypes.ObjectValuable = InterfaceFlowRulesValue{}

type InterfaceFlowRulesValue struct {
	InterfaceFlowRuleAttributes          basetypes.ListValue   `tfsdk:"interface_flow_rule_attributes"`
	InterfaceFlowRuleInterfaceCollection basetypes.ListValue   `tfsdk:"interface_flow_rule_interface_collection"`
	InterfaceFlowRuleName                basetypes.StringValue `tfsdk:"interface_flow_rule_name"`
	InterfaceFlowRuleSubnets             basetypes.SetValue    `tfsdk:"interface_flow_rule_subnets"`
	InterfaceFlowRuleType                basetypes.StringValue `tfsdk:"interface_flow_rule_type"`
	InterfaceFlowRuleUuid                basetypes.StringValue `tfsdk:"interface_flow_rule_uuid"`
	state                                attr.ValueState
}

func (v InterfaceFlowRulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["interface_flow_rule_attributes"] = basetypes.ListType{
		ElemType: InterfaceFlowRuleAttributesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["interface_flow_rule_interface_collection"] = basetypes.ListType{
		ElemType: InterfaceFlowRuleInterfaceCollectionValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["interface_flow_rule_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_subnets"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["interface_flow_rule_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.InterfaceFlowRuleAttributes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_attributes"] = val

		val, err = v.InterfaceFlowRuleInterfaceCollection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_interface_collection"] = val

		val, err = v.InterfaceFlowRuleName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_name"] = val

		val, err = v.InterfaceFlowRuleSubnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_subnets"] = val

		val, err = v.InterfaceFlowRuleType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_type"] = val

		val, err = v.InterfaceFlowRuleUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InterfaceFlowRulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InterfaceFlowRulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InterfaceFlowRulesValue) String() string {
	return "InterfaceFlowRulesValue"
}

func (v InterfaceFlowRulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	interfaceFlowRuleAttributes := types.ListValueMust(
		InterfaceFlowRuleAttributesType{
			basetypes.ObjectType{
				AttrTypes: InterfaceFlowRuleAttributesValue{}.AttributeTypes(ctx),
			},
		},
		v.InterfaceFlowRuleAttributes.Elements(),
	)

	if v.InterfaceFlowRuleAttributes.IsNull() {
		interfaceFlowRuleAttributes = types.ListNull(
			InterfaceFlowRuleAttributesType{
				basetypes.ObjectType{
					AttrTypes: InterfaceFlowRuleAttributesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.InterfaceFlowRuleAttributes.IsUnknown() {
		interfaceFlowRuleAttributes = types.ListUnknown(
			InterfaceFlowRuleAttributesType{
				basetypes.ObjectType{
					AttrTypes: InterfaceFlowRuleAttributesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	interfaceFlowRuleInterfaceCollection := types.ListValueMust(
		InterfaceFlowRuleInterfaceCollectionType{
			basetypes.ObjectType{
				AttrTypes: InterfaceFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
			},
		},
		v.InterfaceFlowRuleInterfaceCollection.Elements(),
	)

	if v.InterfaceFlowRuleInterfaceCollection.IsNull() {
		interfaceFlowRuleInterfaceCollection = types.ListNull(
			InterfaceFlowRuleInterfaceCollectionType{
				basetypes.ObjectType{
					AttrTypes: InterfaceFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.InterfaceFlowRuleInterfaceCollection.IsUnknown() {
		interfaceFlowRuleInterfaceCollection = types.ListUnknown(
			InterfaceFlowRuleInterfaceCollectionType{
				basetypes.ObjectType{
					AttrTypes: InterfaceFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var interfaceFlowRuleSubnetsVal basetypes.SetValue
	switch {
	case v.InterfaceFlowRuleSubnets.IsUnknown():
		interfaceFlowRuleSubnetsVal = types.SetUnknown(types.StringType)
	case v.InterfaceFlowRuleSubnets.IsNull():
		interfaceFlowRuleSubnetsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		interfaceFlowRuleSubnetsVal, d = types.SetValue(types.StringType, v.InterfaceFlowRuleSubnets.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"interface_flow_rule_attributes": basetypes.ListType{
				ElemType: InterfaceFlowRuleAttributesValue{}.Type(ctx),
			},
			"interface_flow_rule_interface_collection": basetypes.ListType{
				ElemType: InterfaceFlowRuleInterfaceCollectionValue{}.Type(ctx),
			},
			"interface_flow_rule_name": basetypes.StringType{},
			"interface_flow_rule_subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"interface_flow_rule_type": basetypes.StringType{},
			"interface_flow_rule_uuid": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"interface_flow_rule_attributes": basetypes.ListType{
			ElemType: InterfaceFlowRuleAttributesValue{}.Type(ctx),
		},
		"interface_flow_rule_interface_collection": basetypes.ListType{
			ElemType: InterfaceFlowRuleInterfaceCollectionValue{}.Type(ctx),
		},
		"interface_flow_rule_name": basetypes.StringType{},
		"interface_flow_rule_subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"interface_flow_rule_type": basetypes.StringType{},
		"interface_flow_rule_uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface_flow_rule_attributes":           interfaceFlowRuleAttributes,
			"interface_flow_rule_interface_collection": interfaceFlowRuleInterfaceCollection,
			"interface_flow_rule_name":                 v.InterfaceFlowRuleName,
			"interface_flow_rule_subnets":              interfaceFlowRuleSubnetsVal,
			"interface_flow_rule_type":                 v.InterfaceFlowRuleType,
			"interface_flow_rule_uuid":                 v.InterfaceFlowRuleUuid,
		})

	return objVal, diags
}

func (v InterfaceFlowRulesValue) Equal(o attr.Value) bool {
	other, ok := o.(InterfaceFlowRulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InterfaceFlowRuleAttributes.Equal(other.InterfaceFlowRuleAttributes) {
		return false
	}

	if !v.InterfaceFlowRuleInterfaceCollection.Equal(other.InterfaceFlowRuleInterfaceCollection) {
		return false
	}

	if !v.InterfaceFlowRuleName.Equal(other.InterfaceFlowRuleName) {
		return false
	}

	if !v.InterfaceFlowRuleSubnets.Equal(other.InterfaceFlowRuleSubnets) {
		return false
	}

	if !v.InterfaceFlowRuleType.Equal(other.InterfaceFlowRuleType) {
		return false
	}

	if !v.InterfaceFlowRuleUuid.Equal(other.InterfaceFlowRuleUuid) {
		return false
	}

	return true
}

func (v InterfaceFlowRulesValue) Type(ctx context.Context) attr.Type {
	return InterfaceFlowRulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InterfaceFlowRulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface_flow_rule_attributes": basetypes.ListType{
			ElemType: InterfaceFlowRuleAttributesValue{}.Type(ctx),
		},
		"interface_flow_rule_interface_collection": basetypes.ListType{
			ElemType: InterfaceFlowRuleInterfaceCollectionValue{}.Type(ctx),
		},
		"interface_flow_rule_name": basetypes.StringType{},
		"interface_flow_rule_subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"interface_flow_rule_type": basetypes.StringType{},
		"interface_flow_rule_uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InterfaceFlowRuleAttributesType{}

type InterfaceFlowRuleAttributesType struct {
	basetypes.ObjectType
}

func (t InterfaceFlowRuleAttributesType) Equal(o attr.Type) bool {
	other, ok := o.(InterfaceFlowRuleAttributesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InterfaceFlowRuleAttributesType) String() string {
	return "InterfaceFlowRuleAttributesType"
}

func (t InterfaceFlowRuleAttributesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceFlowRuleAttributeIdAttribute, ok := attributes["interface_flow_rule_attribute_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_attribute_id is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleAttributeIdVal, ok := interfaceFlowRuleAttributeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_attribute_id expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleAttributeIdAttribute))
	}

	interfaceFlowRuleBidirectionalAttribute, ok := attributes["interface_flow_rule_bidirectional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_bidirectional is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleBidirectionalVal, ok := interfaceFlowRuleBidirectionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_bidirectional expected to be basetypes.BoolValue, was: %T`, interfaceFlowRuleBidirectionalAttribute))
	}

	interfaceFlowRuleDstIpAttribute, ok := attributes["interface_flow_rule_dst_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_dst_ip is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleDstIpVal, ok := interfaceFlowRuleDstIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_dst_ip expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleDstIpAttribute))
	}

	interfaceFlowRuleDstPortAttribute, ok := attributes["interface_flow_rule_dst_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_dst_port is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleDstPortVal, ok := interfaceFlowRuleDstPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_dst_port expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleDstPortAttribute))
	}

	interfaceFlowRuleProtocolAttribute, ok := attributes["interface_flow_rule_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_protocol is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleProtocolVal, ok := interfaceFlowRuleProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_protocol expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleProtocolAttribute))
	}

	interfaceFlowRuleSrcIpAttribute, ok := attributes["interface_flow_rule_src_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_src_ip is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleSrcIpVal, ok := interfaceFlowRuleSrcIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_src_ip expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleSrcIpAttribute))
	}

	interfaceFlowRuleSrcPortAttribute, ok := attributes["interface_flow_rule_src_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_src_port is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleSrcPortVal, ok := interfaceFlowRuleSrcPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_src_port expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleSrcPortAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InterfaceFlowRuleAttributesValue{
		InterfaceFlowRuleAttributeId:   interfaceFlowRuleAttributeIdVal,
		InterfaceFlowRuleBidirectional: interfaceFlowRuleBidirectionalVal,
		InterfaceFlowRuleDstIp:         interfaceFlowRuleDstIpVal,
		InterfaceFlowRuleDstPort:       interfaceFlowRuleDstPortVal,
		InterfaceFlowRuleProtocol:      interfaceFlowRuleProtocolVal,
		InterfaceFlowRuleSrcIp:         interfaceFlowRuleSrcIpVal,
		InterfaceFlowRuleSrcPort:       interfaceFlowRuleSrcPortVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewInterfaceFlowRuleAttributesValueNull() InterfaceFlowRuleAttributesValue {
	return InterfaceFlowRuleAttributesValue{
		state: attr.ValueStateNull,
	}
}

func NewInterfaceFlowRuleAttributesValueUnknown() InterfaceFlowRuleAttributesValue {
	return InterfaceFlowRuleAttributesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInterfaceFlowRuleAttributesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InterfaceFlowRuleAttributesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InterfaceFlowRuleAttributesValue Attribute Value",
				"While creating a InterfaceFlowRuleAttributesValue value, a missing attribute value was detected. "+
					"A InterfaceFlowRuleAttributesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceFlowRuleAttributesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InterfaceFlowRuleAttributesValue Attribute Type",
				"While creating a InterfaceFlowRuleAttributesValue value, an invalid attribute value was detected. "+
					"A InterfaceFlowRuleAttributesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceFlowRuleAttributesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InterfaceFlowRuleAttributesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InterfaceFlowRuleAttributesValue Attribute Value",
				"While creating a InterfaceFlowRuleAttributesValue value, an extra attribute value was detected. "+
					"A InterfaceFlowRuleAttributesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InterfaceFlowRuleAttributesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	interfaceFlowRuleAttributeIdAttribute, ok := attributes["interface_flow_rule_attribute_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_attribute_id is missing from object`)

		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	interfaceFlowRuleAttributeIdVal, ok := interfaceFlowRuleAttributeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_attribute_id expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleAttributeIdAttribute))
	}

	interfaceFlowRuleBidirectionalAttribute, ok := attributes["interface_flow_rule_bidirectional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_bidirectional is missing from object`)

		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	interfaceFlowRuleBidirectionalVal, ok := interfaceFlowRuleBidirectionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_bidirectional expected to be basetypes.BoolValue, was: %T`, interfaceFlowRuleBidirectionalAttribute))
	}

	interfaceFlowRuleDstIpAttribute, ok := attributes["interface_flow_rule_dst_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_dst_ip is missing from object`)

		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	interfaceFlowRuleDstIpVal, ok := interfaceFlowRuleDstIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_dst_ip expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleDstIpAttribute))
	}

	interfaceFlowRuleDstPortAttribute, ok := attributes["interface_flow_rule_dst_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_dst_port is missing from object`)

		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	interfaceFlowRuleDstPortVal, ok := interfaceFlowRuleDstPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_dst_port expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleDstPortAttribute))
	}

	interfaceFlowRuleProtocolAttribute, ok := attributes["interface_flow_rule_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_protocol is missing from object`)

		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	interfaceFlowRuleProtocolVal, ok := interfaceFlowRuleProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_protocol expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleProtocolAttribute))
	}

	interfaceFlowRuleSrcIpAttribute, ok := attributes["interface_flow_rule_src_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_src_ip is missing from object`)

		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	interfaceFlowRuleSrcIpVal, ok := interfaceFlowRuleSrcIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_src_ip expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleSrcIpAttribute))
	}

	interfaceFlowRuleSrcPortAttribute, ok := attributes["interface_flow_rule_src_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_src_port is missing from object`)

		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	interfaceFlowRuleSrcPortVal, ok := interfaceFlowRuleSrcPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_src_port expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleSrcPortAttribute))
	}

	if diags.HasError() {
		return NewInterfaceFlowRuleAttributesValueUnknown(), diags
	}

	return InterfaceFlowRuleAttributesValue{
		InterfaceFlowRuleAttributeId:   interfaceFlowRuleAttributeIdVal,
		InterfaceFlowRuleBidirectional: interfaceFlowRuleBidirectionalVal,
		InterfaceFlowRuleDstIp:         interfaceFlowRuleDstIpVal,
		InterfaceFlowRuleDstPort:       interfaceFlowRuleDstPortVal,
		InterfaceFlowRuleProtocol:      interfaceFlowRuleProtocolVal,
		InterfaceFlowRuleSrcIp:         interfaceFlowRuleSrcIpVal,
		InterfaceFlowRuleSrcPort:       interfaceFlowRuleSrcPortVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewInterfaceFlowRuleAttributesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InterfaceFlowRuleAttributesValue {
	object, diags := NewInterfaceFlowRuleAttributesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInterfaceFlowRuleAttributesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InterfaceFlowRuleAttributesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInterfaceFlowRuleAttributesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInterfaceFlowRuleAttributesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInterfaceFlowRuleAttributesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInterfaceFlowRuleAttributesValueMust(InterfaceFlowRuleAttributesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InterfaceFlowRuleAttributesType) ValueType(ctx context.Context) attr.Value {
	return InterfaceFlowRuleAttributesValue{}
}

var _ basetypes.ObjectValuable = InterfaceFlowRuleAttributesValue{}

type InterfaceFlowRuleAttributesValue struct {
	InterfaceFlowRuleAttributeId   basetypes.StringValue `tfsdk:"interface_flow_rule_attribute_id"`
	InterfaceFlowRuleBidirectional basetypes.BoolValue   `tfsdk:"interface_flow_rule_bidirectional"`
	InterfaceFlowRuleDstIp         basetypes.StringValue `tfsdk:"interface_flow_rule_dst_ip"`
	InterfaceFlowRuleDstPort       basetypes.StringValue `tfsdk:"interface_flow_rule_dst_port"`
	InterfaceFlowRuleProtocol      basetypes.StringValue `tfsdk:"interface_flow_rule_protocol"`
	InterfaceFlowRuleSrcIp         basetypes.StringValue `tfsdk:"interface_flow_rule_src_ip"`
	InterfaceFlowRuleSrcPort       basetypes.StringValue `tfsdk:"interface_flow_rule_src_port"`
	state                          attr.ValueState
}

func (v InterfaceFlowRuleAttributesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["interface_flow_rule_attribute_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_bidirectional"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_dst_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_dst_port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_src_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_src_port"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.InterfaceFlowRuleAttributeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_attribute_id"] = val

		val, err = v.InterfaceFlowRuleBidirectional.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_bidirectional"] = val

		val, err = v.InterfaceFlowRuleDstIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_dst_ip"] = val

		val, err = v.InterfaceFlowRuleDstPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_dst_port"] = val

		val, err = v.InterfaceFlowRuleProtocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_protocol"] = val

		val, err = v.InterfaceFlowRuleSrcIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_src_ip"] = val

		val, err = v.InterfaceFlowRuleSrcPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_src_port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InterfaceFlowRuleAttributesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InterfaceFlowRuleAttributesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InterfaceFlowRuleAttributesValue) String() string {
	return "InterfaceFlowRuleAttributesValue"
}

func (v InterfaceFlowRuleAttributesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"interface_flow_rule_attribute_id":  basetypes.StringType{},
		"interface_flow_rule_bidirectional": basetypes.BoolType{},
		"interface_flow_rule_dst_ip":        basetypes.StringType{},
		"interface_flow_rule_dst_port":      basetypes.StringType{},
		"interface_flow_rule_protocol":      basetypes.StringType{},
		"interface_flow_rule_src_ip":        basetypes.StringType{},
		"interface_flow_rule_src_port":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface_flow_rule_attribute_id":  v.InterfaceFlowRuleAttributeId,
			"interface_flow_rule_bidirectional": v.InterfaceFlowRuleBidirectional,
			"interface_flow_rule_dst_ip":        v.InterfaceFlowRuleDstIp,
			"interface_flow_rule_dst_port":      v.InterfaceFlowRuleDstPort,
			"interface_flow_rule_protocol":      v.InterfaceFlowRuleProtocol,
			"interface_flow_rule_src_ip":        v.InterfaceFlowRuleSrcIp,
			"interface_flow_rule_src_port":      v.InterfaceFlowRuleSrcPort,
		})

	return objVal, diags
}

func (v InterfaceFlowRuleAttributesValue) Equal(o attr.Value) bool {
	other, ok := o.(InterfaceFlowRuleAttributesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InterfaceFlowRuleAttributeId.Equal(other.InterfaceFlowRuleAttributeId) {
		return false
	}

	if !v.InterfaceFlowRuleBidirectional.Equal(other.InterfaceFlowRuleBidirectional) {
		return false
	}

	if !v.InterfaceFlowRuleDstIp.Equal(other.InterfaceFlowRuleDstIp) {
		return false
	}

	if !v.InterfaceFlowRuleDstPort.Equal(other.InterfaceFlowRuleDstPort) {
		return false
	}

	if !v.InterfaceFlowRuleProtocol.Equal(other.InterfaceFlowRuleProtocol) {
		return false
	}

	if !v.InterfaceFlowRuleSrcIp.Equal(other.InterfaceFlowRuleSrcIp) {
		return false
	}

	if !v.InterfaceFlowRuleSrcPort.Equal(other.InterfaceFlowRuleSrcPort) {
		return false
	}

	return true
}

func (v InterfaceFlowRuleAttributesValue) Type(ctx context.Context) attr.Type {
	return InterfaceFlowRuleAttributesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InterfaceFlowRuleAttributesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface_flow_rule_attribute_id":  basetypes.StringType{},
		"interface_flow_rule_bidirectional": basetypes.BoolType{},
		"interface_flow_rule_dst_ip":        basetypes.StringType{},
		"interface_flow_rule_dst_port":      basetypes.StringType{},
		"interface_flow_rule_protocol":      basetypes.StringType{},
		"interface_flow_rule_src_ip":        basetypes.StringType{},
		"interface_flow_rule_src_port":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InterfaceFlowRuleInterfaceCollectionType{}

type InterfaceFlowRuleInterfaceCollectionType struct {
	basetypes.ObjectType
}

func (t InterfaceFlowRuleInterfaceCollectionType) Equal(o attr.Type) bool {
	other, ok := o.(InterfaceFlowRuleInterfaceCollectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InterfaceFlowRuleInterfaceCollectionType) String() string {
	return "InterfaceFlowRuleInterfaceCollectionType"
}

func (t InterfaceFlowRuleInterfaceCollectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceFlowRuleInterfacesAttribute, ok := attributes["interface_flow_rule_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_interfaces is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleInterfacesVal, ok := interfaceFlowRuleInterfacesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_interfaces expected to be basetypes.SetValue, was: %T`, interfaceFlowRuleInterfacesAttribute))
	}

	interfaceFlowRuleSwitchIdAttribute, ok := attributes["interface_flow_rule_switch_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_switch_id is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleSwitchIdVal, ok := interfaceFlowRuleSwitchIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_switch_id expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleSwitchIdAttribute))
	}

	interfaceFlowRuleSwitchNameAttribute, ok := attributes["interface_flow_rule_switch_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_switch_name is missing from object`)

		return nil, diags
	}

	interfaceFlowRuleSwitchNameVal, ok := interfaceFlowRuleSwitchNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_switch_name expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleSwitchNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InterfaceFlowRuleInterfaceCollectionValue{
		InterfaceFlowRuleInterfaces: interfaceFlowRuleInterfacesVal,
		InterfaceFlowRuleSwitchId:   interfaceFlowRuleSwitchIdVal,
		InterfaceFlowRuleSwitchName: interfaceFlowRuleSwitchNameVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewInterfaceFlowRuleInterfaceCollectionValueNull() InterfaceFlowRuleInterfaceCollectionValue {
	return InterfaceFlowRuleInterfaceCollectionValue{
		state: attr.ValueStateNull,
	}
}

func NewInterfaceFlowRuleInterfaceCollectionValueUnknown() InterfaceFlowRuleInterfaceCollectionValue {
	return InterfaceFlowRuleInterfaceCollectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInterfaceFlowRuleInterfaceCollectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InterfaceFlowRuleInterfaceCollectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InterfaceFlowRuleInterfaceCollectionValue Attribute Value",
				"While creating a InterfaceFlowRuleInterfaceCollectionValue value, a missing attribute value was detected. "+
					"A InterfaceFlowRuleInterfaceCollectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceFlowRuleInterfaceCollectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InterfaceFlowRuleInterfaceCollectionValue Attribute Type",
				"While creating a InterfaceFlowRuleInterfaceCollectionValue value, an invalid attribute value was detected. "+
					"A InterfaceFlowRuleInterfaceCollectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceFlowRuleInterfaceCollectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InterfaceFlowRuleInterfaceCollectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InterfaceFlowRuleInterfaceCollectionValue Attribute Value",
				"While creating a InterfaceFlowRuleInterfaceCollectionValue value, an extra attribute value was detected. "+
					"A InterfaceFlowRuleInterfaceCollectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InterfaceFlowRuleInterfaceCollectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInterfaceFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceFlowRuleInterfacesAttribute, ok := attributes["interface_flow_rule_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_interfaces is missing from object`)

		return NewInterfaceFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceFlowRuleInterfacesVal, ok := interfaceFlowRuleInterfacesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_interfaces expected to be basetypes.SetValue, was: %T`, interfaceFlowRuleInterfacesAttribute))
	}

	interfaceFlowRuleSwitchIdAttribute, ok := attributes["interface_flow_rule_switch_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_switch_id is missing from object`)

		return NewInterfaceFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceFlowRuleSwitchIdVal, ok := interfaceFlowRuleSwitchIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_switch_id expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleSwitchIdAttribute))
	}

	interfaceFlowRuleSwitchNameAttribute, ok := attributes["interface_flow_rule_switch_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_flow_rule_switch_name is missing from object`)

		return NewInterfaceFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceFlowRuleSwitchNameVal, ok := interfaceFlowRuleSwitchNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_flow_rule_switch_name expected to be basetypes.StringValue, was: %T`, interfaceFlowRuleSwitchNameAttribute))
	}

	if diags.HasError() {
		return NewInterfaceFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	return InterfaceFlowRuleInterfaceCollectionValue{
		InterfaceFlowRuleInterfaces: interfaceFlowRuleInterfacesVal,
		InterfaceFlowRuleSwitchId:   interfaceFlowRuleSwitchIdVal,
		InterfaceFlowRuleSwitchName: interfaceFlowRuleSwitchNameVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewInterfaceFlowRuleInterfaceCollectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InterfaceFlowRuleInterfaceCollectionValue {
	object, diags := NewInterfaceFlowRuleInterfaceCollectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInterfaceFlowRuleInterfaceCollectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InterfaceFlowRuleInterfaceCollectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInterfaceFlowRuleInterfaceCollectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInterfaceFlowRuleInterfaceCollectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInterfaceFlowRuleInterfaceCollectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInterfaceFlowRuleInterfaceCollectionValueMust(InterfaceFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InterfaceFlowRuleInterfaceCollectionType) ValueType(ctx context.Context) attr.Value {
	return InterfaceFlowRuleInterfaceCollectionValue{}
}

var _ basetypes.ObjectValuable = InterfaceFlowRuleInterfaceCollectionValue{}

type InterfaceFlowRuleInterfaceCollectionValue struct {
	InterfaceFlowRuleInterfaces basetypes.SetValue    `tfsdk:"interface_flow_rule_interfaces"`
	InterfaceFlowRuleSwitchId   basetypes.StringValue `tfsdk:"interface_flow_rule_switch_id"`
	InterfaceFlowRuleSwitchName basetypes.StringValue `tfsdk:"interface_flow_rule_switch_name"`
	state                       attr.ValueState
}

func (v InterfaceFlowRuleInterfaceCollectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["interface_flow_rule_interfaces"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["interface_flow_rule_switch_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_flow_rule_switch_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.InterfaceFlowRuleInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_interfaces"] = val

		val, err = v.InterfaceFlowRuleSwitchId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_switch_id"] = val

		val, err = v.InterfaceFlowRuleSwitchName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_flow_rule_switch_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InterfaceFlowRuleInterfaceCollectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InterfaceFlowRuleInterfaceCollectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InterfaceFlowRuleInterfaceCollectionValue) String() string {
	return "InterfaceFlowRuleInterfaceCollectionValue"
}

func (v InterfaceFlowRuleInterfaceCollectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var interfaceFlowRuleInterfacesVal basetypes.SetValue
	switch {
	case v.InterfaceFlowRuleInterfaces.IsUnknown():
		interfaceFlowRuleInterfacesVal = types.SetUnknown(types.StringType)
	case v.InterfaceFlowRuleInterfaces.IsNull():
		interfaceFlowRuleInterfacesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		interfaceFlowRuleInterfacesVal, d = types.SetValue(types.StringType, v.InterfaceFlowRuleInterfaces.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"interface_flow_rule_interfaces": basetypes.SetType{
				ElemType: types.StringType,
			},
			"interface_flow_rule_switch_id":   basetypes.StringType{},
			"interface_flow_rule_switch_name": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"interface_flow_rule_interfaces": basetypes.SetType{
			ElemType: types.StringType,
		},
		"interface_flow_rule_switch_id":   basetypes.StringType{},
		"interface_flow_rule_switch_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface_flow_rule_interfaces":  interfaceFlowRuleInterfacesVal,
			"interface_flow_rule_switch_id":   v.InterfaceFlowRuleSwitchId,
			"interface_flow_rule_switch_name": v.InterfaceFlowRuleSwitchName,
		})

	return objVal, diags
}

func (v InterfaceFlowRuleInterfaceCollectionValue) Equal(o attr.Value) bool {
	other, ok := o.(InterfaceFlowRuleInterfaceCollectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InterfaceFlowRuleInterfaces.Equal(other.InterfaceFlowRuleInterfaces) {
		return false
	}

	if !v.InterfaceFlowRuleSwitchId.Equal(other.InterfaceFlowRuleSwitchId) {
		return false
	}

	if !v.InterfaceFlowRuleSwitchName.Equal(other.InterfaceFlowRuleSwitchName) {
		return false
	}

	return true
}

func (v InterfaceFlowRuleInterfaceCollectionValue) Type(ctx context.Context) attr.Type {
	return InterfaceFlowRuleInterfaceCollectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InterfaceFlowRuleInterfaceCollectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface_flow_rule_interfaces": basetypes.SetType{
			ElemType: types.StringType,
		},
		"interface_flow_rule_switch_id":   basetypes.StringType{},
		"interface_flow_rule_switch_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InterfaceRulesType{}

type InterfaceRulesType struct {
	basetypes.ObjectType
}

func (t InterfaceRulesType) Equal(o attr.Type) bool {
	other, ok := o.(InterfaceRulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InterfaceRulesType) String() string {
	return "InterfaceRulesType"
}

func (t InterfaceRulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceRuleEnableFabricInterconnectAttribute, ok := attributes["interface_rule_enable_fabric_interconnect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_enable_fabric_interconnect is missing from object`)

		return nil, diags
	}

	interfaceRuleEnableFabricInterconnectVal, ok := interfaceRuleEnableFabricInterconnectAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_enable_fabric_interconnect expected to be basetypes.BoolValue, was: %T`, interfaceRuleEnableFabricInterconnectAttribute))
	}

	interfaceRuleEnableL3OutAttribute, ok := attributes["interface_rule_enable_l3_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_enable_l3_out is missing from object`)

		return nil, diags
	}

	interfaceRuleEnableL3OutVal, ok := interfaceRuleEnableL3OutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_enable_l3_out expected to be basetypes.BoolValue, was: %T`, interfaceRuleEnableL3OutAttribute))
	}

	interfaceRuleEnabledAttribute, ok := attributes["interface_rule_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_enabled is missing from object`)

		return nil, diags
	}

	interfaceRuleEnabledVal, ok := interfaceRuleEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_enabled expected to be basetypes.BoolValue, was: %T`, interfaceRuleEnabledAttribute))
	}

	interfaceRuleInterfaceCollectionAttribute, ok := attributes["interface_rule_interface_collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_collection is missing from object`)

		return nil, diags
	}

	interfaceRuleInterfaceCollectionVal, ok := interfaceRuleInterfaceCollectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_collection expected to be basetypes.ListValue, was: %T`, interfaceRuleInterfaceCollectionAttribute))
	}

	interfaceRuleNameAttribute, ok := attributes["interface_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_name is missing from object`)

		return nil, diags
	}

	interfaceRuleNameVal, ok := interfaceRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_name expected to be basetypes.StringValue, was: %T`, interfaceRuleNameAttribute))
	}

	interfaceRuleSubnetsAttribute, ok := attributes["interface_rule_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_subnets is missing from object`)

		return nil, diags
	}

	interfaceRuleSubnetsVal, ok := interfaceRuleSubnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_subnets expected to be basetypes.SetValue, was: %T`, interfaceRuleSubnetsAttribute))
	}

	interfaceRuleUuidAttribute, ok := attributes["interface_rule_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_uuid is missing from object`)

		return nil, diags
	}

	interfaceRuleUuidVal, ok := interfaceRuleUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_uuid expected to be basetypes.StringValue, was: %T`, interfaceRuleUuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InterfaceRulesValue{
		InterfaceRuleEnableFabricInterconnect: interfaceRuleEnableFabricInterconnectVal,
		InterfaceRuleEnableL3Out:              interfaceRuleEnableL3OutVal,
		InterfaceRuleEnabled:                  interfaceRuleEnabledVal,
		InterfaceRuleInterfaceCollection:      interfaceRuleInterfaceCollectionVal,
		InterfaceRuleName:                     interfaceRuleNameVal,
		InterfaceRuleSubnets:                  interfaceRuleSubnetsVal,
		InterfaceRuleUuid:                     interfaceRuleUuidVal,
		state:                                 attr.ValueStateKnown,
	}, diags
}

func NewInterfaceRulesValueNull() InterfaceRulesValue {
	return InterfaceRulesValue{
		state: attr.ValueStateNull,
	}
}

func NewInterfaceRulesValueUnknown() InterfaceRulesValue {
	return InterfaceRulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInterfaceRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InterfaceRulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InterfaceRulesValue Attribute Value",
				"While creating a InterfaceRulesValue value, a missing attribute value was detected. "+
					"A InterfaceRulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceRulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InterfaceRulesValue Attribute Type",
				"While creating a InterfaceRulesValue value, an invalid attribute value was detected. "+
					"A InterfaceRulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceRulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InterfaceRulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InterfaceRulesValue Attribute Value",
				"While creating a InterfaceRulesValue value, an extra attribute value was detected. "+
					"A InterfaceRulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InterfaceRulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInterfaceRulesValueUnknown(), diags
	}

	interfaceRuleEnableFabricInterconnectAttribute, ok := attributes["interface_rule_enable_fabric_interconnect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_enable_fabric_interconnect is missing from object`)

		return NewInterfaceRulesValueUnknown(), diags
	}

	interfaceRuleEnableFabricInterconnectVal, ok := interfaceRuleEnableFabricInterconnectAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_enable_fabric_interconnect expected to be basetypes.BoolValue, was: %T`, interfaceRuleEnableFabricInterconnectAttribute))
	}

	interfaceRuleEnableL3OutAttribute, ok := attributes["interface_rule_enable_l3_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_enable_l3_out is missing from object`)

		return NewInterfaceRulesValueUnknown(), diags
	}

	interfaceRuleEnableL3OutVal, ok := interfaceRuleEnableL3OutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_enable_l3_out expected to be basetypes.BoolValue, was: %T`, interfaceRuleEnableL3OutAttribute))
	}

	interfaceRuleEnabledAttribute, ok := attributes["interface_rule_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_enabled is missing from object`)

		return NewInterfaceRulesValueUnknown(), diags
	}

	interfaceRuleEnabledVal, ok := interfaceRuleEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_enabled expected to be basetypes.BoolValue, was: %T`, interfaceRuleEnabledAttribute))
	}

	interfaceRuleInterfaceCollectionAttribute, ok := attributes["interface_rule_interface_collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_collection is missing from object`)

		return NewInterfaceRulesValueUnknown(), diags
	}

	interfaceRuleInterfaceCollectionVal, ok := interfaceRuleInterfaceCollectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_collection expected to be basetypes.ListValue, was: %T`, interfaceRuleInterfaceCollectionAttribute))
	}

	interfaceRuleNameAttribute, ok := attributes["interface_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_name is missing from object`)

		return NewInterfaceRulesValueUnknown(), diags
	}

	interfaceRuleNameVal, ok := interfaceRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_name expected to be basetypes.StringValue, was: %T`, interfaceRuleNameAttribute))
	}

	interfaceRuleSubnetsAttribute, ok := attributes["interface_rule_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_subnets is missing from object`)

		return NewInterfaceRulesValueUnknown(), diags
	}

	interfaceRuleSubnetsVal, ok := interfaceRuleSubnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_subnets expected to be basetypes.SetValue, was: %T`, interfaceRuleSubnetsAttribute))
	}

	interfaceRuleUuidAttribute, ok := attributes["interface_rule_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_uuid is missing from object`)

		return NewInterfaceRulesValueUnknown(), diags
	}

	interfaceRuleUuidVal, ok := interfaceRuleUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_uuid expected to be basetypes.StringValue, was: %T`, interfaceRuleUuidAttribute))
	}

	if diags.HasError() {
		return NewInterfaceRulesValueUnknown(), diags
	}

	return InterfaceRulesValue{
		InterfaceRuleEnableFabricInterconnect: interfaceRuleEnableFabricInterconnectVal,
		InterfaceRuleEnableL3Out:              interfaceRuleEnableL3OutVal,
		InterfaceRuleEnabled:                  interfaceRuleEnabledVal,
		InterfaceRuleInterfaceCollection:      interfaceRuleInterfaceCollectionVal,
		InterfaceRuleName:                     interfaceRuleNameVal,
		InterfaceRuleSubnets:                  interfaceRuleSubnetsVal,
		InterfaceRuleUuid:                     interfaceRuleUuidVal,
		state:                                 attr.ValueStateKnown,
	}, diags
}

func NewInterfaceRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InterfaceRulesValue {
	object, diags := NewInterfaceRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInterfaceRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InterfaceRulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInterfaceRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInterfaceRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInterfaceRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInterfaceRulesValueMust(InterfaceRulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InterfaceRulesType) ValueType(ctx context.Context) attr.Value {
	return InterfaceRulesValue{}
}

var _ basetypes.ObjectValuable = InterfaceRulesValue{}

type InterfaceRulesValue struct {
	InterfaceRuleEnableFabricInterconnect basetypes.BoolValue   `tfsdk:"interface_rule_enable_fabric_interconnect"`
	InterfaceRuleEnableL3Out              basetypes.BoolValue   `tfsdk:"interface_rule_enable_l3_out"`
	InterfaceRuleEnabled                  basetypes.BoolValue   `tfsdk:"interface_rule_enabled"`
	InterfaceRuleInterfaceCollection      basetypes.ListValue   `tfsdk:"interface_rule_interface_collection"`
	InterfaceRuleName                     basetypes.StringValue `tfsdk:"interface_rule_name"`
	InterfaceRuleSubnets                  basetypes.SetValue    `tfsdk:"interface_rule_subnets"`
	InterfaceRuleUuid                     basetypes.StringValue `tfsdk:"interface_rule_uuid"`
	state                                 attr.ValueState
}

func (v InterfaceRulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["interface_rule_enable_fabric_interconnect"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["interface_rule_enable_l3_out"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["interface_rule_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["interface_rule_interface_collection"] = basetypes.ListType{
		ElemType: InterfaceRuleInterfaceCollectionValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["interface_rule_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_rule_subnets"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["interface_rule_uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.InterfaceRuleEnableFabricInterconnect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_enable_fabric_interconnect"] = val

		val, err = v.InterfaceRuleEnableL3Out.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_enable_l3_out"] = val

		val, err = v.InterfaceRuleEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_enabled"] = val

		val, err = v.InterfaceRuleInterfaceCollection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_interface_collection"] = val

		val, err = v.InterfaceRuleName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_name"] = val

		val, err = v.InterfaceRuleSubnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_subnets"] = val

		val, err = v.InterfaceRuleUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InterfaceRulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InterfaceRulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InterfaceRulesValue) String() string {
	return "InterfaceRulesValue"
}

func (v InterfaceRulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	interfaceRuleInterfaceCollection := types.ListValueMust(
		InterfaceRuleInterfaceCollectionType{
			basetypes.ObjectType{
				AttrTypes: InterfaceRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
			},
		},
		v.InterfaceRuleInterfaceCollection.Elements(),
	)

	if v.InterfaceRuleInterfaceCollection.IsNull() {
		interfaceRuleInterfaceCollection = types.ListNull(
			InterfaceRuleInterfaceCollectionType{
				basetypes.ObjectType{
					AttrTypes: InterfaceRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.InterfaceRuleInterfaceCollection.IsUnknown() {
		interfaceRuleInterfaceCollection = types.ListUnknown(
			InterfaceRuleInterfaceCollectionType{
				basetypes.ObjectType{
					AttrTypes: InterfaceRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var interfaceRuleSubnetsVal basetypes.SetValue
	switch {
	case v.InterfaceRuleSubnets.IsUnknown():
		interfaceRuleSubnetsVal = types.SetUnknown(types.StringType)
	case v.InterfaceRuleSubnets.IsNull():
		interfaceRuleSubnetsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		interfaceRuleSubnetsVal, d = types.SetValue(types.StringType, v.InterfaceRuleSubnets.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"interface_rule_enable_fabric_interconnect": basetypes.BoolType{},
			"interface_rule_enable_l3_out":              basetypes.BoolType{},
			"interface_rule_enabled":                    basetypes.BoolType{},
			"interface_rule_interface_collection": basetypes.ListType{
				ElemType: InterfaceRuleInterfaceCollectionValue{}.Type(ctx),
			},
			"interface_rule_name": basetypes.StringType{},
			"interface_rule_subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"interface_rule_uuid": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"interface_rule_enable_fabric_interconnect": basetypes.BoolType{},
		"interface_rule_enable_l3_out":              basetypes.BoolType{},
		"interface_rule_enabled":                    basetypes.BoolType{},
		"interface_rule_interface_collection": basetypes.ListType{
			ElemType: InterfaceRuleInterfaceCollectionValue{}.Type(ctx),
		},
		"interface_rule_name": basetypes.StringType{},
		"interface_rule_subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"interface_rule_uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface_rule_enable_fabric_interconnect": v.InterfaceRuleEnableFabricInterconnect,
			"interface_rule_enable_l3_out":              v.InterfaceRuleEnableL3Out,
			"interface_rule_enabled":                    v.InterfaceRuleEnabled,
			"interface_rule_interface_collection":       interfaceRuleInterfaceCollection,
			"interface_rule_name":                       v.InterfaceRuleName,
			"interface_rule_subnets":                    interfaceRuleSubnetsVal,
			"interface_rule_uuid":                       v.InterfaceRuleUuid,
		})

	return objVal, diags
}

func (v InterfaceRulesValue) Equal(o attr.Value) bool {
	other, ok := o.(InterfaceRulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InterfaceRuleEnableFabricInterconnect.Equal(other.InterfaceRuleEnableFabricInterconnect) {
		return false
	}

	if !v.InterfaceRuleEnableL3Out.Equal(other.InterfaceRuleEnableL3Out) {
		return false
	}

	if !v.InterfaceRuleEnabled.Equal(other.InterfaceRuleEnabled) {
		return false
	}

	if !v.InterfaceRuleInterfaceCollection.Equal(other.InterfaceRuleInterfaceCollection) {
		return false
	}

	if !v.InterfaceRuleName.Equal(other.InterfaceRuleName) {
		return false
	}

	if !v.InterfaceRuleSubnets.Equal(other.InterfaceRuleSubnets) {
		return false
	}

	if !v.InterfaceRuleUuid.Equal(other.InterfaceRuleUuid) {
		return false
	}

	return true
}

func (v InterfaceRulesValue) Type(ctx context.Context) attr.Type {
	return InterfaceRulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InterfaceRulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface_rule_enable_fabric_interconnect": basetypes.BoolType{},
		"interface_rule_enable_l3_out":              basetypes.BoolType{},
		"interface_rule_enabled":                    basetypes.BoolType{},
		"interface_rule_interface_collection": basetypes.ListType{
			ElemType: InterfaceRuleInterfaceCollectionValue{}.Type(ctx),
		},
		"interface_rule_name": basetypes.StringType{},
		"interface_rule_subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"interface_rule_uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InterfaceRuleInterfaceCollectionType{}

type InterfaceRuleInterfaceCollectionType struct {
	basetypes.ObjectType
}

func (t InterfaceRuleInterfaceCollectionType) Equal(o attr.Type) bool {
	other, ok := o.(InterfaceRuleInterfaceCollectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InterfaceRuleInterfaceCollectionType) String() string {
	return "InterfaceRuleInterfaceCollectionType"
}

func (t InterfaceRuleInterfaceCollectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceRuleInterfacesAttribute, ok := attributes["interface_rule_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interfaces is missing from object`)

		return nil, diags
	}

	interfaceRuleInterfacesVal, ok := interfaceRuleInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interfaces expected to be basetypes.ListValue, was: %T`, interfaceRuleInterfacesAttribute))
	}

	interfaceRuleL3OutAttribute, ok := attributes["interface_rule_l3_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_l3_out is missing from object`)

		return nil, diags
	}

	interfaceRuleL3OutVal, ok := interfaceRuleL3OutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_l3_out expected to be basetypes.StringValue, was: %T`, interfaceRuleL3OutAttribute))
	}

	interfaceRuleSwitchIdAttribute, ok := attributes["interface_rule_switch_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_switch_id is missing from object`)

		return nil, diags
	}

	interfaceRuleSwitchIdVal, ok := interfaceRuleSwitchIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_switch_id expected to be basetypes.StringValue, was: %T`, interfaceRuleSwitchIdAttribute))
	}

	interfaceRuleSwitchNameAttribute, ok := attributes["interface_rule_switch_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_switch_name is missing from object`)

		return nil, diags
	}

	interfaceRuleSwitchNameVal, ok := interfaceRuleSwitchNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_switch_name expected to be basetypes.StringValue, was: %T`, interfaceRuleSwitchNameAttribute))
	}

	interfaceRuleTenantAttribute, ok := attributes["interface_rule_tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_tenant is missing from object`)

		return nil, diags
	}

	interfaceRuleTenantVal, ok := interfaceRuleTenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_tenant expected to be basetypes.StringValue, was: %T`, interfaceRuleTenantAttribute))
	}

	interfaceRuleVrfNameAttribute, ok := attributes["interface_rule_vrf_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_vrf_name is missing from object`)

		return nil, diags
	}

	interfaceRuleVrfNameVal, ok := interfaceRuleVrfNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_vrf_name expected to be basetypes.StringValue, was: %T`, interfaceRuleVrfNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InterfaceRuleInterfaceCollectionValue{
		InterfaceRuleInterfaces: interfaceRuleInterfacesVal,
		InterfaceRuleL3Out:      interfaceRuleL3OutVal,
		InterfaceRuleSwitchId:   interfaceRuleSwitchIdVal,
		InterfaceRuleSwitchName: interfaceRuleSwitchNameVal,
		InterfaceRuleTenant:     interfaceRuleTenantVal,
		InterfaceRuleVrfName:    interfaceRuleVrfNameVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewInterfaceRuleInterfaceCollectionValueNull() InterfaceRuleInterfaceCollectionValue {
	return InterfaceRuleInterfaceCollectionValue{
		state: attr.ValueStateNull,
	}
}

func NewInterfaceRuleInterfaceCollectionValueUnknown() InterfaceRuleInterfaceCollectionValue {
	return InterfaceRuleInterfaceCollectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInterfaceRuleInterfaceCollectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InterfaceRuleInterfaceCollectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InterfaceRuleInterfaceCollectionValue Attribute Value",
				"While creating a InterfaceRuleInterfaceCollectionValue value, a missing attribute value was detected. "+
					"A InterfaceRuleInterfaceCollectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceRuleInterfaceCollectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InterfaceRuleInterfaceCollectionValue Attribute Type",
				"While creating a InterfaceRuleInterfaceCollectionValue value, an invalid attribute value was detected. "+
					"A InterfaceRuleInterfaceCollectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceRuleInterfaceCollectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InterfaceRuleInterfaceCollectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InterfaceRuleInterfaceCollectionValue Attribute Value",
				"While creating a InterfaceRuleInterfaceCollectionValue value, an extra attribute value was detected. "+
					"A InterfaceRuleInterfaceCollectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InterfaceRuleInterfaceCollectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInterfaceRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceRuleInterfacesAttribute, ok := attributes["interface_rule_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interfaces is missing from object`)

		return NewInterfaceRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceRuleInterfacesVal, ok := interfaceRuleInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interfaces expected to be basetypes.ListValue, was: %T`, interfaceRuleInterfacesAttribute))
	}

	interfaceRuleL3OutAttribute, ok := attributes["interface_rule_l3_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_l3_out is missing from object`)

		return NewInterfaceRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceRuleL3OutVal, ok := interfaceRuleL3OutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_l3_out expected to be basetypes.StringValue, was: %T`, interfaceRuleL3OutAttribute))
	}

	interfaceRuleSwitchIdAttribute, ok := attributes["interface_rule_switch_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_switch_id is missing from object`)

		return NewInterfaceRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceRuleSwitchIdVal, ok := interfaceRuleSwitchIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_switch_id expected to be basetypes.StringValue, was: %T`, interfaceRuleSwitchIdAttribute))
	}

	interfaceRuleSwitchNameAttribute, ok := attributes["interface_rule_switch_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_switch_name is missing from object`)

		return NewInterfaceRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceRuleSwitchNameVal, ok := interfaceRuleSwitchNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_switch_name expected to be basetypes.StringValue, was: %T`, interfaceRuleSwitchNameAttribute))
	}

	interfaceRuleTenantAttribute, ok := attributes["interface_rule_tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_tenant is missing from object`)

		return NewInterfaceRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceRuleTenantVal, ok := interfaceRuleTenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_tenant expected to be basetypes.StringValue, was: %T`, interfaceRuleTenantAttribute))
	}

	interfaceRuleVrfNameAttribute, ok := attributes["interface_rule_vrf_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_vrf_name is missing from object`)

		return NewInterfaceRuleInterfaceCollectionValueUnknown(), diags
	}

	interfaceRuleVrfNameVal, ok := interfaceRuleVrfNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_vrf_name expected to be basetypes.StringValue, was: %T`, interfaceRuleVrfNameAttribute))
	}

	if diags.HasError() {
		return NewInterfaceRuleInterfaceCollectionValueUnknown(), diags
	}

	return InterfaceRuleInterfaceCollectionValue{
		InterfaceRuleInterfaces: interfaceRuleInterfacesVal,
		InterfaceRuleL3Out:      interfaceRuleL3OutVal,
		InterfaceRuleSwitchId:   interfaceRuleSwitchIdVal,
		InterfaceRuleSwitchName: interfaceRuleSwitchNameVal,
		InterfaceRuleTenant:     interfaceRuleTenantVal,
		InterfaceRuleVrfName:    interfaceRuleVrfNameVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewInterfaceRuleInterfaceCollectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InterfaceRuleInterfaceCollectionValue {
	object, diags := NewInterfaceRuleInterfaceCollectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInterfaceRuleInterfaceCollectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InterfaceRuleInterfaceCollectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInterfaceRuleInterfaceCollectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInterfaceRuleInterfaceCollectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInterfaceRuleInterfaceCollectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInterfaceRuleInterfaceCollectionValueMust(InterfaceRuleInterfaceCollectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InterfaceRuleInterfaceCollectionType) ValueType(ctx context.Context) attr.Value {
	return InterfaceRuleInterfaceCollectionValue{}
}

var _ basetypes.ObjectValuable = InterfaceRuleInterfaceCollectionValue{}

type InterfaceRuleInterfaceCollectionValue struct {
	InterfaceRuleInterfaces basetypes.ListValue   `tfsdk:"interface_rule_interfaces"`
	InterfaceRuleL3Out      basetypes.StringValue `tfsdk:"interface_rule_l3_out"`
	InterfaceRuleSwitchId   basetypes.StringValue `tfsdk:"interface_rule_switch_id"`
	InterfaceRuleSwitchName basetypes.StringValue `tfsdk:"interface_rule_switch_name"`
	InterfaceRuleTenant     basetypes.StringValue `tfsdk:"interface_rule_tenant"`
	InterfaceRuleVrfName    basetypes.StringValue `tfsdk:"interface_rule_vrf_name"`
	state                   attr.ValueState
}

func (v InterfaceRuleInterfaceCollectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["interface_rule_interfaces"] = basetypes.ListType{
		ElemType: InterfaceRuleInterfacesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["interface_rule_l3_out"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_rule_switch_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_rule_switch_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_rule_tenant"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_rule_vrf_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.InterfaceRuleInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_interfaces"] = val

		val, err = v.InterfaceRuleL3Out.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_l3_out"] = val

		val, err = v.InterfaceRuleSwitchId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_switch_id"] = val

		val, err = v.InterfaceRuleSwitchName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_switch_name"] = val

		val, err = v.InterfaceRuleTenant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_tenant"] = val

		val, err = v.InterfaceRuleVrfName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_vrf_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InterfaceRuleInterfaceCollectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InterfaceRuleInterfaceCollectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InterfaceRuleInterfaceCollectionValue) String() string {
	return "InterfaceRuleInterfaceCollectionValue"
}

func (v InterfaceRuleInterfaceCollectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	interfaceRuleInterfaces := types.ListValueMust(
		InterfaceRuleInterfacesType{
			basetypes.ObjectType{
				AttrTypes: InterfaceRuleInterfacesValue{}.AttributeTypes(ctx),
			},
		},
		v.InterfaceRuleInterfaces.Elements(),
	)

	if v.InterfaceRuleInterfaces.IsNull() {
		interfaceRuleInterfaces = types.ListNull(
			InterfaceRuleInterfacesType{
				basetypes.ObjectType{
					AttrTypes: InterfaceRuleInterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.InterfaceRuleInterfaces.IsUnknown() {
		interfaceRuleInterfaces = types.ListUnknown(
			InterfaceRuleInterfacesType{
				basetypes.ObjectType{
					AttrTypes: InterfaceRuleInterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"interface_rule_interfaces": basetypes.ListType{
			ElemType: InterfaceRuleInterfacesValue{}.Type(ctx),
		},
		"interface_rule_l3_out":      basetypes.StringType{},
		"interface_rule_switch_id":   basetypes.StringType{},
		"interface_rule_switch_name": basetypes.StringType{},
		"interface_rule_tenant":      basetypes.StringType{},
		"interface_rule_vrf_name":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface_rule_interfaces":  interfaceRuleInterfaces,
			"interface_rule_l3_out":      v.InterfaceRuleL3Out,
			"interface_rule_switch_id":   v.InterfaceRuleSwitchId,
			"interface_rule_switch_name": v.InterfaceRuleSwitchName,
			"interface_rule_tenant":      v.InterfaceRuleTenant,
			"interface_rule_vrf_name":    v.InterfaceRuleVrfName,
		})

	return objVal, diags
}

func (v InterfaceRuleInterfaceCollectionValue) Equal(o attr.Value) bool {
	other, ok := o.(InterfaceRuleInterfaceCollectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InterfaceRuleInterfaces.Equal(other.InterfaceRuleInterfaces) {
		return false
	}

	if !v.InterfaceRuleL3Out.Equal(other.InterfaceRuleL3Out) {
		return false
	}

	if !v.InterfaceRuleSwitchId.Equal(other.InterfaceRuleSwitchId) {
		return false
	}

	if !v.InterfaceRuleSwitchName.Equal(other.InterfaceRuleSwitchName) {
		return false
	}

	if !v.InterfaceRuleTenant.Equal(other.InterfaceRuleTenant) {
		return false
	}

	if !v.InterfaceRuleVrfName.Equal(other.InterfaceRuleVrfName) {
		return false
	}

	return true
}

func (v InterfaceRuleInterfaceCollectionValue) Type(ctx context.Context) attr.Type {
	return InterfaceRuleInterfaceCollectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InterfaceRuleInterfaceCollectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface_rule_interfaces": basetypes.ListType{
			ElemType: InterfaceRuleInterfacesValue{}.Type(ctx),
		},
		"interface_rule_l3_out":      basetypes.StringType{},
		"interface_rule_switch_id":   basetypes.StringType{},
		"interface_rule_switch_name": basetypes.StringType{},
		"interface_rule_tenant":      basetypes.StringType{},
		"interface_rule_vrf_name":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InterfaceRuleInterfacesType{}

type InterfaceRuleInterfacesType struct {
	basetypes.ObjectType
}

func (t InterfaceRuleInterfacesType) Equal(o attr.Type) bool {
	other, ok := o.(InterfaceRuleInterfacesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InterfaceRuleInterfacesType) String() string {
	return "InterfaceRuleInterfacesType"
}

func (t InterfaceRuleInterfacesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceRuleInterfaceEncapAttribute, ok := attributes["interface_rule_interface_encap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_encap is missing from object`)

		return nil, diags
	}

	interfaceRuleInterfaceEncapVal, ok := interfaceRuleInterfaceEncapAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_encap expected to be basetypes.StringValue, was: %T`, interfaceRuleInterfaceEncapAttribute))
	}

	interfaceRuleInterfaceNameAttribute, ok := attributes["interface_rule_interface_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_name is missing from object`)

		return nil, diags
	}

	interfaceRuleInterfaceNameVal, ok := interfaceRuleInterfaceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_name expected to be basetypes.StringValue, was: %T`, interfaceRuleInterfaceNameAttribute))
	}

	interfaceRuleInterfaceTypeAttribute, ok := attributes["interface_rule_interface_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_type is missing from object`)

		return nil, diags
	}

	interfaceRuleInterfaceTypeVal, ok := interfaceRuleInterfaceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_type expected to be basetypes.StringValue, was: %T`, interfaceRuleInterfaceTypeAttribute))
	}

	interfaceRuleInterfaceVrfNameAttribute, ok := attributes["interface_rule_interface_vrf_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_vrf_name is missing from object`)

		return nil, diags
	}

	interfaceRuleInterfaceVrfNameVal, ok := interfaceRuleInterfaceVrfNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_vrf_name expected to be basetypes.StringValue, was: %T`, interfaceRuleInterfaceVrfNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InterfaceRuleInterfacesValue{
		InterfaceRuleInterfaceEncap:   interfaceRuleInterfaceEncapVal,
		InterfaceRuleInterfaceName:    interfaceRuleInterfaceNameVal,
		InterfaceRuleInterfaceType:    interfaceRuleInterfaceTypeVal,
		InterfaceRuleInterfaceVrfName: interfaceRuleInterfaceVrfNameVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewInterfaceRuleInterfacesValueNull() InterfaceRuleInterfacesValue {
	return InterfaceRuleInterfacesValue{
		state: attr.ValueStateNull,
	}
}

func NewInterfaceRuleInterfacesValueUnknown() InterfaceRuleInterfacesValue {
	return InterfaceRuleInterfacesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInterfaceRuleInterfacesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InterfaceRuleInterfacesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InterfaceRuleInterfacesValue Attribute Value",
				"While creating a InterfaceRuleInterfacesValue value, a missing attribute value was detected. "+
					"A InterfaceRuleInterfacesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceRuleInterfacesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InterfaceRuleInterfacesValue Attribute Type",
				"While creating a InterfaceRuleInterfacesValue value, an invalid attribute value was detected. "+
					"A InterfaceRuleInterfacesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfaceRuleInterfacesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InterfaceRuleInterfacesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InterfaceRuleInterfacesValue Attribute Value",
				"While creating a InterfaceRuleInterfacesValue value, an extra attribute value was detected. "+
					"A InterfaceRuleInterfacesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InterfaceRuleInterfacesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInterfaceRuleInterfacesValueUnknown(), diags
	}

	interfaceRuleInterfaceEncapAttribute, ok := attributes["interface_rule_interface_encap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_encap is missing from object`)

		return NewInterfaceRuleInterfacesValueUnknown(), diags
	}

	interfaceRuleInterfaceEncapVal, ok := interfaceRuleInterfaceEncapAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_encap expected to be basetypes.StringValue, was: %T`, interfaceRuleInterfaceEncapAttribute))
	}

	interfaceRuleInterfaceNameAttribute, ok := attributes["interface_rule_interface_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_name is missing from object`)

		return NewInterfaceRuleInterfacesValueUnknown(), diags
	}

	interfaceRuleInterfaceNameVal, ok := interfaceRuleInterfaceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_name expected to be basetypes.StringValue, was: %T`, interfaceRuleInterfaceNameAttribute))
	}

	interfaceRuleInterfaceTypeAttribute, ok := attributes["interface_rule_interface_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_type is missing from object`)

		return NewInterfaceRuleInterfacesValueUnknown(), diags
	}

	interfaceRuleInterfaceTypeVal, ok := interfaceRuleInterfaceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_type expected to be basetypes.StringValue, was: %T`, interfaceRuleInterfaceTypeAttribute))
	}

	interfaceRuleInterfaceVrfNameAttribute, ok := attributes["interface_rule_interface_vrf_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_rule_interface_vrf_name is missing from object`)

		return NewInterfaceRuleInterfacesValueUnknown(), diags
	}

	interfaceRuleInterfaceVrfNameVal, ok := interfaceRuleInterfaceVrfNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_rule_interface_vrf_name expected to be basetypes.StringValue, was: %T`, interfaceRuleInterfaceVrfNameAttribute))
	}

	if diags.HasError() {
		return NewInterfaceRuleInterfacesValueUnknown(), diags
	}

	return InterfaceRuleInterfacesValue{
		InterfaceRuleInterfaceEncap:   interfaceRuleInterfaceEncapVal,
		InterfaceRuleInterfaceName:    interfaceRuleInterfaceNameVal,
		InterfaceRuleInterfaceType:    interfaceRuleInterfaceTypeVal,
		InterfaceRuleInterfaceVrfName: interfaceRuleInterfaceVrfNameVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewInterfaceRuleInterfacesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InterfaceRuleInterfacesValue {
	object, diags := NewInterfaceRuleInterfacesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInterfaceRuleInterfacesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InterfaceRuleInterfacesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInterfaceRuleInterfacesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInterfaceRuleInterfacesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInterfaceRuleInterfacesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInterfaceRuleInterfacesValueMust(InterfaceRuleInterfacesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InterfaceRuleInterfacesType) ValueType(ctx context.Context) attr.Value {
	return InterfaceRuleInterfacesValue{}
}

var _ basetypes.ObjectValuable = InterfaceRuleInterfacesValue{}

type InterfaceRuleInterfacesValue struct {
	InterfaceRuleInterfaceEncap   basetypes.StringValue `tfsdk:"interface_rule_interface_encap"`
	InterfaceRuleInterfaceName    basetypes.StringValue `tfsdk:"interface_rule_interface_name"`
	InterfaceRuleInterfaceType    basetypes.StringValue `tfsdk:"interface_rule_interface_type"`
	InterfaceRuleInterfaceVrfName basetypes.StringValue `tfsdk:"interface_rule_interface_vrf_name"`
	state                         attr.ValueState
}

func (v InterfaceRuleInterfacesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["interface_rule_interface_encap"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_rule_interface_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_rule_interface_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_rule_interface_vrf_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.InterfaceRuleInterfaceEncap.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_interface_encap"] = val

		val, err = v.InterfaceRuleInterfaceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_interface_name"] = val

		val, err = v.InterfaceRuleInterfaceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_interface_type"] = val

		val, err = v.InterfaceRuleInterfaceVrfName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_rule_interface_vrf_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InterfaceRuleInterfacesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InterfaceRuleInterfacesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InterfaceRuleInterfacesValue) String() string {
	return "InterfaceRuleInterfacesValue"
}

func (v InterfaceRuleInterfacesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"interface_rule_interface_encap":    basetypes.StringType{},
		"interface_rule_interface_name":     basetypes.StringType{},
		"interface_rule_interface_type":     basetypes.StringType{},
		"interface_rule_interface_vrf_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface_rule_interface_encap":    v.InterfaceRuleInterfaceEncap,
			"interface_rule_interface_name":     v.InterfaceRuleInterfaceName,
			"interface_rule_interface_type":     v.InterfaceRuleInterfaceType,
			"interface_rule_interface_vrf_name": v.InterfaceRuleInterfaceVrfName,
		})

	return objVal, diags
}

func (v InterfaceRuleInterfacesValue) Equal(o attr.Value) bool {
	other, ok := o.(InterfaceRuleInterfacesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InterfaceRuleInterfaceEncap.Equal(other.InterfaceRuleInterfaceEncap) {
		return false
	}

	if !v.InterfaceRuleInterfaceName.Equal(other.InterfaceRuleInterfaceName) {
		return false
	}

	if !v.InterfaceRuleInterfaceType.Equal(other.InterfaceRuleInterfaceType) {
		return false
	}

	if !v.InterfaceRuleInterfaceVrfName.Equal(other.InterfaceRuleInterfaceVrfName) {
		return false
	}

	return true
}

func (v InterfaceRuleInterfacesValue) Type(ctx context.Context) attr.Type {
	return InterfaceRuleInterfacesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InterfaceRuleInterfacesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface_rule_interface_encap":    basetypes.StringType{},
		"interface_rule_interface_name":     basetypes.StringType{},
		"interface_rule_interface_type":     basetypes.StringType{},
		"interface_rule_interface_vrf_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = L3OutFlowRulesType{}

type L3OutFlowRulesType struct {
	basetypes.ObjectType
}

func (t L3OutFlowRulesType) Equal(o attr.Type) bool {
	other, ok := o.(L3OutFlowRulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t L3OutFlowRulesType) String() string {
	return "L3OutFlowRulesType"
}

func (t L3OutFlowRulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	l3OutFlowRuleInterfaceCollectionAttribute, ok := attributes["l3_out_flow_rule_interface_collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_interface_collection is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleInterfaceCollectionVal, ok := l3OutFlowRuleInterfaceCollectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_interface_collection expected to be basetypes.ListValue, was: %T`, l3OutFlowRuleInterfaceCollectionAttribute))
	}

	l3OutFlowRuleNameAttribute, ok := attributes["l3_out_flow_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_name is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleNameVal, ok := l3OutFlowRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_name expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleNameAttribute))
	}

	l3OutFlowRuleSubnetsAttribute, ok := attributes["l3_out_flow_rule_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_subnets is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleSubnetsVal, ok := l3OutFlowRuleSubnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_subnets expected to be basetypes.SetValue, was: %T`, l3OutFlowRuleSubnetsAttribute))
	}

	l3OutFlowRuleTypeAttribute, ok := attributes["l3_out_flow_rule_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_type is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleTypeVal, ok := l3OutFlowRuleTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_type expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleTypeAttribute))
	}

	l3OutFlowRuleUuidAttribute, ok := attributes["l3_out_flow_rule_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_uuid is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleUuidVal, ok := l3OutFlowRuleUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_uuid expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleUuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return L3OutFlowRulesValue{
		L3OutFlowRuleInterfaceCollection: l3OutFlowRuleInterfaceCollectionVal,
		L3OutFlowRuleName:                l3OutFlowRuleNameVal,
		L3OutFlowRuleSubnets:             l3OutFlowRuleSubnetsVal,
		L3OutFlowRuleType:                l3OutFlowRuleTypeVal,
		L3OutFlowRuleUuid:                l3OutFlowRuleUuidVal,
		state:                            attr.ValueStateKnown,
	}, diags
}

func NewL3OutFlowRulesValueNull() L3OutFlowRulesValue {
	return L3OutFlowRulesValue{
		state: attr.ValueStateNull,
	}
}

func NewL3OutFlowRulesValueUnknown() L3OutFlowRulesValue {
	return L3OutFlowRulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewL3OutFlowRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (L3OutFlowRulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing L3OutFlowRulesValue Attribute Value",
				"While creating a L3OutFlowRulesValue value, a missing attribute value was detected. "+
					"A L3OutFlowRulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L3OutFlowRulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid L3OutFlowRulesValue Attribute Type",
				"While creating a L3OutFlowRulesValue value, an invalid attribute value was detected. "+
					"A L3OutFlowRulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L3OutFlowRulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("L3OutFlowRulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra L3OutFlowRulesValue Attribute Value",
				"While creating a L3OutFlowRulesValue value, an extra attribute value was detected. "+
					"A L3OutFlowRulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra L3OutFlowRulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewL3OutFlowRulesValueUnknown(), diags
	}

	l3OutFlowRuleInterfaceCollectionAttribute, ok := attributes["l3_out_flow_rule_interface_collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_interface_collection is missing from object`)

		return NewL3OutFlowRulesValueUnknown(), diags
	}

	l3OutFlowRuleInterfaceCollectionVal, ok := l3OutFlowRuleInterfaceCollectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_interface_collection expected to be basetypes.ListValue, was: %T`, l3OutFlowRuleInterfaceCollectionAttribute))
	}

	l3OutFlowRuleNameAttribute, ok := attributes["l3_out_flow_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_name is missing from object`)

		return NewL3OutFlowRulesValueUnknown(), diags
	}

	l3OutFlowRuleNameVal, ok := l3OutFlowRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_name expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleNameAttribute))
	}

	l3OutFlowRuleSubnetsAttribute, ok := attributes["l3_out_flow_rule_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_subnets is missing from object`)

		return NewL3OutFlowRulesValueUnknown(), diags
	}

	l3OutFlowRuleSubnetsVal, ok := l3OutFlowRuleSubnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_subnets expected to be basetypes.SetValue, was: %T`, l3OutFlowRuleSubnetsAttribute))
	}

	l3OutFlowRuleTypeAttribute, ok := attributes["l3_out_flow_rule_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_type is missing from object`)

		return NewL3OutFlowRulesValueUnknown(), diags
	}

	l3OutFlowRuleTypeVal, ok := l3OutFlowRuleTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_type expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleTypeAttribute))
	}

	l3OutFlowRuleUuidAttribute, ok := attributes["l3_out_flow_rule_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_uuid is missing from object`)

		return NewL3OutFlowRulesValueUnknown(), diags
	}

	l3OutFlowRuleUuidVal, ok := l3OutFlowRuleUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_uuid expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleUuidAttribute))
	}

	if diags.HasError() {
		return NewL3OutFlowRulesValueUnknown(), diags
	}

	return L3OutFlowRulesValue{
		L3OutFlowRuleInterfaceCollection: l3OutFlowRuleInterfaceCollectionVal,
		L3OutFlowRuleName:                l3OutFlowRuleNameVal,
		L3OutFlowRuleSubnets:             l3OutFlowRuleSubnetsVal,
		L3OutFlowRuleType:                l3OutFlowRuleTypeVal,
		L3OutFlowRuleUuid:                l3OutFlowRuleUuidVal,
		state:                            attr.ValueStateKnown,
	}, diags
}

func NewL3OutFlowRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) L3OutFlowRulesValue {
	object, diags := NewL3OutFlowRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewL3OutFlowRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t L3OutFlowRulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewL3OutFlowRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewL3OutFlowRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewL3OutFlowRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewL3OutFlowRulesValueMust(L3OutFlowRulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t L3OutFlowRulesType) ValueType(ctx context.Context) attr.Value {
	return L3OutFlowRulesValue{}
}

var _ basetypes.ObjectValuable = L3OutFlowRulesValue{}

type L3OutFlowRulesValue struct {
	L3OutFlowRuleInterfaceCollection basetypes.ListValue   `tfsdk:"l3_out_flow_rule_interface_collection"`
	L3OutFlowRuleName                basetypes.StringValue `tfsdk:"l3_out_flow_rule_name"`
	L3OutFlowRuleSubnets             basetypes.SetValue    `tfsdk:"l3_out_flow_rule_subnets"`
	L3OutFlowRuleType                basetypes.StringValue `tfsdk:"l3_out_flow_rule_type"`
	L3OutFlowRuleUuid                basetypes.StringValue `tfsdk:"l3_out_flow_rule_uuid"`
	state                            attr.ValueState
}

func (v L3OutFlowRulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["l3_out_flow_rule_interface_collection"] = basetypes.ListType{
		ElemType: L3OutFlowRuleInterfaceCollectionValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_subnets"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.L3OutFlowRuleInterfaceCollection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_interface_collection"] = val

		val, err = v.L3OutFlowRuleName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_name"] = val

		val, err = v.L3OutFlowRuleSubnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_subnets"] = val

		val, err = v.L3OutFlowRuleType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_type"] = val

		val, err = v.L3OutFlowRuleUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v L3OutFlowRulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v L3OutFlowRulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v L3OutFlowRulesValue) String() string {
	return "L3OutFlowRulesValue"
}

func (v L3OutFlowRulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	l3OutFlowRuleInterfaceCollection := types.ListValueMust(
		L3OutFlowRuleInterfaceCollectionType{
			basetypes.ObjectType{
				AttrTypes: L3OutFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
			},
		},
		v.L3OutFlowRuleInterfaceCollection.Elements(),
	)

	if v.L3OutFlowRuleInterfaceCollection.IsNull() {
		l3OutFlowRuleInterfaceCollection = types.ListNull(
			L3OutFlowRuleInterfaceCollectionType{
				basetypes.ObjectType{
					AttrTypes: L3OutFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.L3OutFlowRuleInterfaceCollection.IsUnknown() {
		l3OutFlowRuleInterfaceCollection = types.ListUnknown(
			L3OutFlowRuleInterfaceCollectionType{
				basetypes.ObjectType{
					AttrTypes: L3OutFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var l3OutFlowRuleSubnetsVal basetypes.SetValue
	switch {
	case v.L3OutFlowRuleSubnets.IsUnknown():
		l3OutFlowRuleSubnetsVal = types.SetUnknown(types.StringType)
	case v.L3OutFlowRuleSubnets.IsNull():
		l3OutFlowRuleSubnetsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		l3OutFlowRuleSubnetsVal, d = types.SetValue(types.StringType, v.L3OutFlowRuleSubnets.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"l3_out_flow_rule_interface_collection": basetypes.ListType{
				ElemType: L3OutFlowRuleInterfaceCollectionValue{}.Type(ctx),
			},
			"l3_out_flow_rule_name": basetypes.StringType{},
			"l3_out_flow_rule_subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"l3_out_flow_rule_type": basetypes.StringType{},
			"l3_out_flow_rule_uuid": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"l3_out_flow_rule_interface_collection": basetypes.ListType{
			ElemType: L3OutFlowRuleInterfaceCollectionValue{}.Type(ctx),
		},
		"l3_out_flow_rule_name": basetypes.StringType{},
		"l3_out_flow_rule_subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"l3_out_flow_rule_type": basetypes.StringType{},
		"l3_out_flow_rule_uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"l3_out_flow_rule_interface_collection": l3OutFlowRuleInterfaceCollection,
			"l3_out_flow_rule_name":                 v.L3OutFlowRuleName,
			"l3_out_flow_rule_subnets":              l3OutFlowRuleSubnetsVal,
			"l3_out_flow_rule_type":                 v.L3OutFlowRuleType,
			"l3_out_flow_rule_uuid":                 v.L3OutFlowRuleUuid,
		})

	return objVal, diags
}

func (v L3OutFlowRulesValue) Equal(o attr.Value) bool {
	other, ok := o.(L3OutFlowRulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.L3OutFlowRuleInterfaceCollection.Equal(other.L3OutFlowRuleInterfaceCollection) {
		return false
	}

	if !v.L3OutFlowRuleName.Equal(other.L3OutFlowRuleName) {
		return false
	}

	if !v.L3OutFlowRuleSubnets.Equal(other.L3OutFlowRuleSubnets) {
		return false
	}

	if !v.L3OutFlowRuleType.Equal(other.L3OutFlowRuleType) {
		return false
	}

	if !v.L3OutFlowRuleUuid.Equal(other.L3OutFlowRuleUuid) {
		return false
	}

	return true
}

func (v L3OutFlowRulesValue) Type(ctx context.Context) attr.Type {
	return L3OutFlowRulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v L3OutFlowRulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"l3_out_flow_rule_interface_collection": basetypes.ListType{
			ElemType: L3OutFlowRuleInterfaceCollectionValue{}.Type(ctx),
		},
		"l3_out_flow_rule_name": basetypes.StringType{},
		"l3_out_flow_rule_subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"l3_out_flow_rule_type": basetypes.StringType{},
		"l3_out_flow_rule_uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = L3OutFlowRuleInterfaceCollectionType{}

type L3OutFlowRuleInterfaceCollectionType struct {
	basetypes.ObjectType
}

func (t L3OutFlowRuleInterfaceCollectionType) Equal(o attr.Type) bool {
	other, ok := o.(L3OutFlowRuleInterfaceCollectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t L3OutFlowRuleInterfaceCollectionType) String() string {
	return "L3OutFlowRuleInterfaceCollectionType"
}

func (t L3OutFlowRuleInterfaceCollectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	l3OutFlowRuleEncapAttribute, ok := attributes["l3_out_flow_rule_encap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_encap is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleEncapVal, ok := l3OutFlowRuleEncapAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_encap expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleEncapAttribute))
	}

	l3OutFlowRuleInterfacesAttribute, ok := attributes["l3_out_flow_rule_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_interfaces is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleInterfacesVal, ok := l3OutFlowRuleInterfacesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_interfaces expected to be basetypes.SetValue, was: %T`, l3OutFlowRuleInterfacesAttribute))
	}

	l3OutFlowRuleL3OutAttribute, ok := attributes["l3_out_flow_rule_l3_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_l3_out is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleL3OutVal, ok := l3OutFlowRuleL3OutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_l3_out expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleL3OutAttribute))
	}

	l3OutFlowRuleSwitchIdAttribute, ok := attributes["l3_out_flow_rule_switch_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_switch_id is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleSwitchIdVal, ok := l3OutFlowRuleSwitchIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_switch_id expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleSwitchIdAttribute))
	}

	l3OutFlowRuleSwitchNameAttribute, ok := attributes["l3_out_flow_rule_switch_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_switch_name is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleSwitchNameVal, ok := l3OutFlowRuleSwitchNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_switch_name expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleSwitchNameAttribute))
	}

	l3OutFlowRuleTenantAttribute, ok := attributes["l3_out_flow_rule_tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_tenant is missing from object`)

		return nil, diags
	}

	l3OutFlowRuleTenantVal, ok := l3OutFlowRuleTenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_tenant expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleTenantAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return L3OutFlowRuleInterfaceCollectionValue{
		L3OutFlowRuleEncap:      l3OutFlowRuleEncapVal,
		L3OutFlowRuleInterfaces: l3OutFlowRuleInterfacesVal,
		L3OutFlowRuleL3Out:      l3OutFlowRuleL3OutVal,
		L3OutFlowRuleSwitchId:   l3OutFlowRuleSwitchIdVal,
		L3OutFlowRuleSwitchName: l3OutFlowRuleSwitchNameVal,
		L3OutFlowRuleTenant:     l3OutFlowRuleTenantVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewL3OutFlowRuleInterfaceCollectionValueNull() L3OutFlowRuleInterfaceCollectionValue {
	return L3OutFlowRuleInterfaceCollectionValue{
		state: attr.ValueStateNull,
	}
}

func NewL3OutFlowRuleInterfaceCollectionValueUnknown() L3OutFlowRuleInterfaceCollectionValue {
	return L3OutFlowRuleInterfaceCollectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewL3OutFlowRuleInterfaceCollectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (L3OutFlowRuleInterfaceCollectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing L3OutFlowRuleInterfaceCollectionValue Attribute Value",
				"While creating a L3OutFlowRuleInterfaceCollectionValue value, a missing attribute value was detected. "+
					"A L3OutFlowRuleInterfaceCollectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L3OutFlowRuleInterfaceCollectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid L3OutFlowRuleInterfaceCollectionValue Attribute Type",
				"While creating a L3OutFlowRuleInterfaceCollectionValue value, an invalid attribute value was detected. "+
					"A L3OutFlowRuleInterfaceCollectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L3OutFlowRuleInterfaceCollectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("L3OutFlowRuleInterfaceCollectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra L3OutFlowRuleInterfaceCollectionValue Attribute Value",
				"While creating a L3OutFlowRuleInterfaceCollectionValue value, an extra attribute value was detected. "+
					"A L3OutFlowRuleInterfaceCollectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra L3OutFlowRuleInterfaceCollectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	l3OutFlowRuleEncapAttribute, ok := attributes["l3_out_flow_rule_encap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_encap is missing from object`)

		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	l3OutFlowRuleEncapVal, ok := l3OutFlowRuleEncapAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_encap expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleEncapAttribute))
	}

	l3OutFlowRuleInterfacesAttribute, ok := attributes["l3_out_flow_rule_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_interfaces is missing from object`)

		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	l3OutFlowRuleInterfacesVal, ok := l3OutFlowRuleInterfacesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_interfaces expected to be basetypes.SetValue, was: %T`, l3OutFlowRuleInterfacesAttribute))
	}

	l3OutFlowRuleL3OutAttribute, ok := attributes["l3_out_flow_rule_l3_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_l3_out is missing from object`)

		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	l3OutFlowRuleL3OutVal, ok := l3OutFlowRuleL3OutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_l3_out expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleL3OutAttribute))
	}

	l3OutFlowRuleSwitchIdAttribute, ok := attributes["l3_out_flow_rule_switch_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_switch_id is missing from object`)

		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	l3OutFlowRuleSwitchIdVal, ok := l3OutFlowRuleSwitchIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_switch_id expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleSwitchIdAttribute))
	}

	l3OutFlowRuleSwitchNameAttribute, ok := attributes["l3_out_flow_rule_switch_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_switch_name is missing from object`)

		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	l3OutFlowRuleSwitchNameVal, ok := l3OutFlowRuleSwitchNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_switch_name expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleSwitchNameAttribute))
	}

	l3OutFlowRuleTenantAttribute, ok := attributes["l3_out_flow_rule_tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_out_flow_rule_tenant is missing from object`)

		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	l3OutFlowRuleTenantVal, ok := l3OutFlowRuleTenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_out_flow_rule_tenant expected to be basetypes.StringValue, was: %T`, l3OutFlowRuleTenantAttribute))
	}

	if diags.HasError() {
		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), diags
	}

	return L3OutFlowRuleInterfaceCollectionValue{
		L3OutFlowRuleEncap:      l3OutFlowRuleEncapVal,
		L3OutFlowRuleInterfaces: l3OutFlowRuleInterfacesVal,
		L3OutFlowRuleL3Out:      l3OutFlowRuleL3OutVal,
		L3OutFlowRuleSwitchId:   l3OutFlowRuleSwitchIdVal,
		L3OutFlowRuleSwitchName: l3OutFlowRuleSwitchNameVal,
		L3OutFlowRuleTenant:     l3OutFlowRuleTenantVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewL3OutFlowRuleInterfaceCollectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) L3OutFlowRuleInterfaceCollectionValue {
	object, diags := NewL3OutFlowRuleInterfaceCollectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewL3OutFlowRuleInterfaceCollectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t L3OutFlowRuleInterfaceCollectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewL3OutFlowRuleInterfaceCollectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewL3OutFlowRuleInterfaceCollectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewL3OutFlowRuleInterfaceCollectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewL3OutFlowRuleInterfaceCollectionValueMust(L3OutFlowRuleInterfaceCollectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t L3OutFlowRuleInterfaceCollectionType) ValueType(ctx context.Context) attr.Value {
	return L3OutFlowRuleInterfaceCollectionValue{}
}

var _ basetypes.ObjectValuable = L3OutFlowRuleInterfaceCollectionValue{}

type L3OutFlowRuleInterfaceCollectionValue struct {
	L3OutFlowRuleEncap      basetypes.StringValue `tfsdk:"l3_out_flow_rule_encap"`
	L3OutFlowRuleInterfaces basetypes.SetValue    `tfsdk:"l3_out_flow_rule_interfaces"`
	L3OutFlowRuleL3Out      basetypes.StringValue `tfsdk:"l3_out_flow_rule_l3_out"`
	L3OutFlowRuleSwitchId   basetypes.StringValue `tfsdk:"l3_out_flow_rule_switch_id"`
	L3OutFlowRuleSwitchName basetypes.StringValue `tfsdk:"l3_out_flow_rule_switch_name"`
	L3OutFlowRuleTenant     basetypes.StringValue `tfsdk:"l3_out_flow_rule_tenant"`
	state                   attr.ValueState
}

func (v L3OutFlowRuleInterfaceCollectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["l3_out_flow_rule_encap"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_interfaces"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_l3_out"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_switch_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_switch_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l3_out_flow_rule_tenant"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.L3OutFlowRuleEncap.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_encap"] = val

		val, err = v.L3OutFlowRuleInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_interfaces"] = val

		val, err = v.L3OutFlowRuleL3Out.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_l3_out"] = val

		val, err = v.L3OutFlowRuleSwitchId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_switch_id"] = val

		val, err = v.L3OutFlowRuleSwitchName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_switch_name"] = val

		val, err = v.L3OutFlowRuleTenant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_out_flow_rule_tenant"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v L3OutFlowRuleInterfaceCollectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v L3OutFlowRuleInterfaceCollectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v L3OutFlowRuleInterfaceCollectionValue) String() string {
	return "L3OutFlowRuleInterfaceCollectionValue"
}

func (v L3OutFlowRuleInterfaceCollectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var l3OutFlowRuleInterfacesVal basetypes.SetValue
	switch {
	case v.L3OutFlowRuleInterfaces.IsUnknown():
		l3OutFlowRuleInterfacesVal = types.SetUnknown(types.StringType)
	case v.L3OutFlowRuleInterfaces.IsNull():
		l3OutFlowRuleInterfacesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		l3OutFlowRuleInterfacesVal, d = types.SetValue(types.StringType, v.L3OutFlowRuleInterfaces.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"l3_out_flow_rule_encap": basetypes.StringType{},
			"l3_out_flow_rule_interfaces": basetypes.SetType{
				ElemType: types.StringType,
			},
			"l3_out_flow_rule_l3_out":      basetypes.StringType{},
			"l3_out_flow_rule_switch_id":   basetypes.StringType{},
			"l3_out_flow_rule_switch_name": basetypes.StringType{},
			"l3_out_flow_rule_tenant":      basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"l3_out_flow_rule_encap": basetypes.StringType{},
		"l3_out_flow_rule_interfaces": basetypes.SetType{
			ElemType: types.StringType,
		},
		"l3_out_flow_rule_l3_out":      basetypes.StringType{},
		"l3_out_flow_rule_switch_id":   basetypes.StringType{},
		"l3_out_flow_rule_switch_name": basetypes.StringType{},
		"l3_out_flow_rule_tenant":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"l3_out_flow_rule_encap":       v.L3OutFlowRuleEncap,
			"l3_out_flow_rule_interfaces":  l3OutFlowRuleInterfacesVal,
			"l3_out_flow_rule_l3_out":      v.L3OutFlowRuleL3Out,
			"l3_out_flow_rule_switch_id":   v.L3OutFlowRuleSwitchId,
			"l3_out_flow_rule_switch_name": v.L3OutFlowRuleSwitchName,
			"l3_out_flow_rule_tenant":      v.L3OutFlowRuleTenant,
		})

	return objVal, diags
}

func (v L3OutFlowRuleInterfaceCollectionValue) Equal(o attr.Value) bool {
	other, ok := o.(L3OutFlowRuleInterfaceCollectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.L3OutFlowRuleEncap.Equal(other.L3OutFlowRuleEncap) {
		return false
	}

	if !v.L3OutFlowRuleInterfaces.Equal(other.L3OutFlowRuleInterfaces) {
		return false
	}

	if !v.L3OutFlowRuleL3Out.Equal(other.L3OutFlowRuleL3Out) {
		return false
	}

	if !v.L3OutFlowRuleSwitchId.Equal(other.L3OutFlowRuleSwitchId) {
		return false
	}

	if !v.L3OutFlowRuleSwitchName.Equal(other.L3OutFlowRuleSwitchName) {
		return false
	}

	if !v.L3OutFlowRuleTenant.Equal(other.L3OutFlowRuleTenant) {
		return false
	}

	return true
}

func (v L3OutFlowRuleInterfaceCollectionValue) Type(ctx context.Context) attr.Type {
	return L3OutFlowRuleInterfaceCollectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v L3OutFlowRuleInterfaceCollectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"l3_out_flow_rule_encap": basetypes.StringType{},
		"l3_out_flow_rule_interfaces": basetypes.SetType{
			ElemType: types.StringType,
		},
		"l3_out_flow_rule_l3_out":      basetypes.StringType{},
		"l3_out_flow_rule_switch_id":   basetypes.StringType{},
		"l3_out_flow_rule_switch_name": basetypes.StringType{},
		"l3_out_flow_rule_tenant":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LocationType{}

type LocationType struct {
	basetypes.ObjectType
}

func (t LocationType) Equal(o attr.Type) bool {
	other, ok := o.(LocationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LocationType) String() string {
	return "LocationType"
}

func (t LocationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	latitudeAttribute, ok := attributes["latitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latitude is missing from object`)

		return nil, diags
	}

	latitudeVal, ok := latitudeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latitude expected to be basetypes.Float64Value, was: %T`, latitudeAttribute))
	}

	longitudeAttribute, ok := attributes["longitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`longitude is missing from object`)

		return nil, diags
	}

	longitudeVal, ok := longitudeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`longitude expected to be basetypes.Float64Value, was: %T`, longitudeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LocationValue{
		Latitude:  latitudeVal,
		Longitude: longitudeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewLocationValueNull() LocationValue {
	return LocationValue{
		state: attr.ValueStateNull,
	}
}

func NewLocationValueUnknown() LocationValue {
	return LocationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLocationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LocationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LocationValue Attribute Value",
				"While creating a LocationValue value, a missing attribute value was detected. "+
					"A LocationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LocationValue Attribute Type",
				"While creating a LocationValue value, an invalid attribute value was detected. "+
					"A LocationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LocationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LocationValue Attribute Value",
				"While creating a LocationValue value, an extra attribute value was detected. "+
					"A LocationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LocationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLocationValueUnknown(), diags
	}

	latitudeAttribute, ok := attributes["latitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latitude is missing from object`)

		return NewLocationValueUnknown(), diags
	}

	latitudeVal, ok := latitudeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latitude expected to be basetypes.Float64Value, was: %T`, latitudeAttribute))
	}

	longitudeAttribute, ok := attributes["longitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`longitude is missing from object`)

		return NewLocationValueUnknown(), diags
	}

	longitudeVal, ok := longitudeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`longitude expected to be basetypes.Float64Value, was: %T`, longitudeAttribute))
	}

	if diags.HasError() {
		return NewLocationValueUnknown(), diags
	}

	return LocationValue{
		Latitude:  latitudeVal,
		Longitude: longitudeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewLocationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LocationValue {
	object, diags := NewLocationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLocationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LocationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLocationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLocationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLocationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLocationValueMust(LocationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LocationType) ValueType(ctx context.Context) attr.Value {
	return LocationValue{}
}

var _ basetypes.ObjectValuable = LocationValue{}

type LocationValue struct {
	Latitude  basetypes.Float64Value `tfsdk:"latitude"`
	Longitude basetypes.Float64Value `tfsdk:"longitude"`
	state     attr.ValueState
}

func (v LocationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["latitude"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["longitude"] = basetypes.Float64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Latitude.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["latitude"] = val

		val, err = v.Longitude.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["longitude"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LocationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LocationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LocationValue) String() string {
	return "LocationValue"
}

func (v LocationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"latitude":  basetypes.Float64Type{},
		"longitude": basetypes.Float64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"latitude":  v.Latitude,
			"longitude": v.Longitude,
		})

	return objVal, diags
}

func (v LocationValue) Equal(o attr.Value) bool {
	other, ok := o.(LocationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Latitude.Equal(other.Latitude) {
		return false
	}

	if !v.Longitude.Equal(other.Longitude) {
		return false
	}

	return true
}

func (v LocationValue) Type(ctx context.Context) attr.Type {
	return LocationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LocationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"latitude":  basetypes.Float64Type{},
		"longitude": basetypes.Float64Type{},
	}
}

var _ basetypes.ObjectTypable = MessageBusType{}

type MessageBusType struct {
	basetypes.ObjectType
}

func (t MessageBusType) Equal(o attr.Type) bool {
	other, ok := o.(MessageBusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MessageBusType) String() string {
	return "MessageBusType"
}

func (t MessageBusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advisoriesAttribute, ok := attributes["advisories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advisories is missing from object`)

		return nil, diags
	}

	advisoriesVal, ok := advisoriesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advisories expected to be basetypes.SetValue, was: %T`, advisoriesAttribute))
	}

	anomaliesAttribute, ok := attributes["anomalies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anomalies is missing from object`)

		return nil, diags
	}

	anomaliesVal, ok := anomaliesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anomalies expected to be basetypes.SetValue, was: %T`, anomaliesAttribute))
	}

	auditLogsAttribute, ok := attributes["audit_logs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`audit_logs is missing from object`)

		return nil, diags
	}

	auditLogsVal, ok := auditLogsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`audit_logs expected to be basetypes.SetValue, was: %T`, auditLogsAttribute))
	}

	collectionSettingsCollectionTypeAttribute, ok := attributes["collection_settings_collection_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_settings_collection_type is missing from object`)

		return nil, diags
	}

	collectionSettingsCollectionTypeVal, ok := collectionSettingsCollectionTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_settings_collection_type expected to be basetypes.StringValue, was: %T`, collectionSettingsCollectionTypeAttribute))
	}

	collectionTypeAttribute, ok := attributes["collection_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_type is missing from object`)

		return nil, diags
	}

	collectionTypeVal, ok := collectionTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_type expected to be basetypes.StringValue, was: %T`, collectionTypeAttribute))
	}

	faultsAttribute, ok := attributes["faults"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`faults is missing from object`)

		return nil, diags
	}

	faultsVal, ok := faultsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`faults expected to be basetypes.SetValue, was: %T`, faultsAttribute))
	}

	serverAttribute, ok := attributes["server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server is missing from object`)

		return nil, diags
	}

	serverVal, ok := serverAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server expected to be basetypes.StringValue, was: %T`, serverAttribute))
	}

	statisticsAttribute, ok := attributes["statistics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statistics is missing from object`)

		return nil, diags
	}

	statisticsVal, ok := statisticsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statistics expected to be basetypes.SetValue, was: %T`, statisticsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MessageBusValue{
		Advisories:                       advisoriesVal,
		Anomalies:                        anomaliesVal,
		AuditLogs:                        auditLogsVal,
		CollectionSettingsCollectionType: collectionSettingsCollectionTypeVal,
		CollectionType:                   collectionTypeVal,
		Faults:                           faultsVal,
		Server:                           serverVal,
		Statistics:                       statisticsVal,
		state:                            attr.ValueStateKnown,
	}, diags
}

func NewMessageBusValueNull() MessageBusValue {
	return MessageBusValue{
		state: attr.ValueStateNull,
	}
}

func NewMessageBusValueUnknown() MessageBusValue {
	return MessageBusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMessageBusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MessageBusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MessageBusValue Attribute Value",
				"While creating a MessageBusValue value, a missing attribute value was detected. "+
					"A MessageBusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MessageBusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MessageBusValue Attribute Type",
				"While creating a MessageBusValue value, an invalid attribute value was detected. "+
					"A MessageBusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MessageBusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MessageBusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MessageBusValue Attribute Value",
				"While creating a MessageBusValue value, an extra attribute value was detected. "+
					"A MessageBusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MessageBusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMessageBusValueUnknown(), diags
	}

	advisoriesAttribute, ok := attributes["advisories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advisories is missing from object`)

		return NewMessageBusValueUnknown(), diags
	}

	advisoriesVal, ok := advisoriesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advisories expected to be basetypes.SetValue, was: %T`, advisoriesAttribute))
	}

	anomaliesAttribute, ok := attributes["anomalies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anomalies is missing from object`)

		return NewMessageBusValueUnknown(), diags
	}

	anomaliesVal, ok := anomaliesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anomalies expected to be basetypes.SetValue, was: %T`, anomaliesAttribute))
	}

	auditLogsAttribute, ok := attributes["audit_logs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`audit_logs is missing from object`)

		return NewMessageBusValueUnknown(), diags
	}

	auditLogsVal, ok := auditLogsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`audit_logs expected to be basetypes.SetValue, was: %T`, auditLogsAttribute))
	}

	collectionSettingsCollectionTypeAttribute, ok := attributes["collection_settings_collection_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_settings_collection_type is missing from object`)

		return NewMessageBusValueUnknown(), diags
	}

	collectionSettingsCollectionTypeVal, ok := collectionSettingsCollectionTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_settings_collection_type expected to be basetypes.StringValue, was: %T`, collectionSettingsCollectionTypeAttribute))
	}

	collectionTypeAttribute, ok := attributes["collection_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_type is missing from object`)

		return NewMessageBusValueUnknown(), diags
	}

	collectionTypeVal, ok := collectionTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_type expected to be basetypes.StringValue, was: %T`, collectionTypeAttribute))
	}

	faultsAttribute, ok := attributes["faults"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`faults is missing from object`)

		return NewMessageBusValueUnknown(), diags
	}

	faultsVal, ok := faultsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`faults expected to be basetypes.SetValue, was: %T`, faultsAttribute))
	}

	serverAttribute, ok := attributes["server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server is missing from object`)

		return NewMessageBusValueUnknown(), diags
	}

	serverVal, ok := serverAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server expected to be basetypes.StringValue, was: %T`, serverAttribute))
	}

	statisticsAttribute, ok := attributes["statistics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statistics is missing from object`)

		return NewMessageBusValueUnknown(), diags
	}

	statisticsVal, ok := statisticsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statistics expected to be basetypes.SetValue, was: %T`, statisticsAttribute))
	}

	if diags.HasError() {
		return NewMessageBusValueUnknown(), diags
	}

	return MessageBusValue{
		Advisories:                       advisoriesVal,
		Anomalies:                        anomaliesVal,
		AuditLogs:                        auditLogsVal,
		CollectionSettingsCollectionType: collectionSettingsCollectionTypeVal,
		CollectionType:                   collectionTypeVal,
		Faults:                           faultsVal,
		Server:                           serverVal,
		Statistics:                       statisticsVal,
		state:                            attr.ValueStateKnown,
	}, diags
}

func NewMessageBusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MessageBusValue {
	object, diags := NewMessageBusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMessageBusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MessageBusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMessageBusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMessageBusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMessageBusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMessageBusValueMust(MessageBusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MessageBusType) ValueType(ctx context.Context) attr.Value {
	return MessageBusValue{}
}

var _ basetypes.ObjectValuable = MessageBusValue{}

type MessageBusValue struct {
	Advisories                       basetypes.SetValue    `tfsdk:"advisories"`
	Anomalies                        basetypes.SetValue    `tfsdk:"anomalies"`
	AuditLogs                        basetypes.SetValue    `tfsdk:"audit_logs"`
	CollectionSettingsCollectionType basetypes.StringValue `tfsdk:"collection_settings_collection_type"`
	CollectionType                   basetypes.StringValue `tfsdk:"collection_type"`
	Faults                           basetypes.SetValue    `tfsdk:"faults"`
	Server                           basetypes.StringValue `tfsdk:"server"`
	Statistics                       basetypes.SetValue    `tfsdk:"statistics"`
	state                            attr.ValueState
}

func (v MessageBusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["advisories"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["anomalies"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["audit_logs"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["collection_settings_collection_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["collection_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["faults"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["server"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["statistics"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Advisories.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advisories"] = val

		val, err = v.Anomalies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["anomalies"] = val

		val, err = v.AuditLogs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["audit_logs"] = val

		val, err = v.CollectionSettingsCollectionType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection_settings_collection_type"] = val

		val, err = v.CollectionType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection_type"] = val

		val, err = v.Faults.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["faults"] = val

		val, err = v.Server.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server"] = val

		val, err = v.Statistics.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["statistics"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MessageBusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MessageBusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MessageBusValue) String() string {
	return "MessageBusValue"
}

func (v MessageBusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var advisoriesVal basetypes.SetValue
	switch {
	case v.Advisories.IsUnknown():
		advisoriesVal = types.SetUnknown(types.StringType)
	case v.Advisories.IsNull():
		advisoriesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		advisoriesVal, d = types.SetValue(types.StringType, v.Advisories.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advisories": basetypes.SetType{
				ElemType: types.StringType,
			},
			"anomalies": basetypes.SetType{
				ElemType: types.StringType,
			},
			"audit_logs": basetypes.SetType{
				ElemType: types.StringType,
			},
			"collection_settings_collection_type": basetypes.StringType{},
			"collection_type":                     basetypes.StringType{},
			"faults": basetypes.SetType{
				ElemType: types.StringType,
			},
			"server": basetypes.StringType{},
			"statistics": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var anomaliesVal basetypes.SetValue
	switch {
	case v.Anomalies.IsUnknown():
		anomaliesVal = types.SetUnknown(types.StringType)
	case v.Anomalies.IsNull():
		anomaliesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		anomaliesVal, d = types.SetValue(types.StringType, v.Anomalies.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advisories": basetypes.SetType{
				ElemType: types.StringType,
			},
			"anomalies": basetypes.SetType{
				ElemType: types.StringType,
			},
			"audit_logs": basetypes.SetType{
				ElemType: types.StringType,
			},
			"collection_settings_collection_type": basetypes.StringType{},
			"collection_type":                     basetypes.StringType{},
			"faults": basetypes.SetType{
				ElemType: types.StringType,
			},
			"server": basetypes.StringType{},
			"statistics": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var auditLogsVal basetypes.SetValue
	switch {
	case v.AuditLogs.IsUnknown():
		auditLogsVal = types.SetUnknown(types.StringType)
	case v.AuditLogs.IsNull():
		auditLogsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		auditLogsVal, d = types.SetValue(types.StringType, v.AuditLogs.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advisories": basetypes.SetType{
				ElemType: types.StringType,
			},
			"anomalies": basetypes.SetType{
				ElemType: types.StringType,
			},
			"audit_logs": basetypes.SetType{
				ElemType: types.StringType,
			},
			"collection_settings_collection_type": basetypes.StringType{},
			"collection_type":                     basetypes.StringType{},
			"faults": basetypes.SetType{
				ElemType: types.StringType,
			},
			"server": basetypes.StringType{},
			"statistics": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var faultsVal basetypes.SetValue
	switch {
	case v.Faults.IsUnknown():
		faultsVal = types.SetUnknown(types.StringType)
	case v.Faults.IsNull():
		faultsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		faultsVal, d = types.SetValue(types.StringType, v.Faults.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advisories": basetypes.SetType{
				ElemType: types.StringType,
			},
			"anomalies": basetypes.SetType{
				ElemType: types.StringType,
			},
			"audit_logs": basetypes.SetType{
				ElemType: types.StringType,
			},
			"collection_settings_collection_type": basetypes.StringType{},
			"collection_type":                     basetypes.StringType{},
			"faults": basetypes.SetType{
				ElemType: types.StringType,
			},
			"server": basetypes.StringType{},
			"statistics": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var statisticsVal basetypes.SetValue
	switch {
	case v.Statistics.IsUnknown():
		statisticsVal = types.SetUnknown(types.StringType)
	case v.Statistics.IsNull():
		statisticsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		statisticsVal, d = types.SetValue(types.StringType, v.Statistics.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advisories": basetypes.SetType{
				ElemType: types.StringType,
			},
			"anomalies": basetypes.SetType{
				ElemType: types.StringType,
			},
			"audit_logs": basetypes.SetType{
				ElemType: types.StringType,
			},
			"collection_settings_collection_type": basetypes.StringType{},
			"collection_type":                     basetypes.StringType{},
			"faults": basetypes.SetType{
				ElemType: types.StringType,
			},
			"server": basetypes.StringType{},
			"statistics": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"advisories": basetypes.SetType{
			ElemType: types.StringType,
		},
		"anomalies": basetypes.SetType{
			ElemType: types.StringType,
		},
		"audit_logs": basetypes.SetType{
			ElemType: types.StringType,
		},
		"collection_settings_collection_type": basetypes.StringType{},
		"collection_type":                     basetypes.StringType{},
		"faults": basetypes.SetType{
			ElemType: types.StringType,
		},
		"server": basetypes.StringType{},
		"statistics": basetypes.SetType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advisories":                          advisoriesVal,
			"anomalies":                           anomaliesVal,
			"audit_logs":                          auditLogsVal,
			"collection_settings_collection_type": v.CollectionSettingsCollectionType,
			"collection_type":                     v.CollectionType,
			"faults":                              faultsVal,
			"server":                              v.Server,
			"statistics":                          statisticsVal,
		})

	return objVal, diags
}

func (v MessageBusValue) Equal(o attr.Value) bool {
	other, ok := o.(MessageBusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Advisories.Equal(other.Advisories) {
		return false
	}

	if !v.Anomalies.Equal(other.Anomalies) {
		return false
	}

	if !v.AuditLogs.Equal(other.AuditLogs) {
		return false
	}

	if !v.CollectionSettingsCollectionType.Equal(other.CollectionSettingsCollectionType) {
		return false
	}

	if !v.CollectionType.Equal(other.CollectionType) {
		return false
	}

	if !v.Faults.Equal(other.Faults) {
		return false
	}

	if !v.Server.Equal(other.Server) {
		return false
	}

	if !v.Statistics.Equal(other.Statistics) {
		return false
	}

	return true
}

func (v MessageBusValue) Type(ctx context.Context) attr.Type {
	return MessageBusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MessageBusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advisories": basetypes.SetType{
			ElemType: types.StringType,
		},
		"anomalies": basetypes.SetType{
			ElemType: types.StringType,
		},
		"audit_logs": basetypes.SetType{
			ElemType: types.StringType,
		},
		"collection_settings_collection_type": basetypes.StringType{},
		"collection_type":                     basetypes.StringType{},
		"faults": basetypes.SetType{
			ElemType: types.StringType,
		},
		"server": basetypes.StringType{},
		"statistics": basetypes.SetType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = NetflowExporterCollectionType{}

type NetflowExporterCollectionType struct {
	basetypes.ObjectType
}

func (t NetflowExporterCollectionType) Equal(o attr.Type) bool {
	other, ok := o.(NetflowExporterCollectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetflowExporterCollectionType) String() string {
	return "NetflowExporterCollectionType"
}

func (t NetflowExporterCollectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	exporterIpAttribute, ok := attributes["exporter_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exporter_ip is missing from object`)

		return nil, diags
	}

	exporterIpVal, ok := exporterIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exporter_ip expected to be basetypes.StringValue, was: %T`, exporterIpAttribute))
	}

	exporterNameAttribute, ok := attributes["exporter_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exporter_name is missing from object`)

		return nil, diags
	}

	exporterNameVal, ok := exporterNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exporter_name expected to be basetypes.StringValue, was: %T`, exporterNameAttribute))
	}

	sourceInterfaceNameAttribute, ok := attributes["source_interface_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_interface_name is missing from object`)

		return nil, diags
	}

	sourceInterfaceNameVal, ok := sourceInterfaceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_interface_name expected to be basetypes.StringValue, was: %T`, sourceInterfaceNameAttribute))
	}

	udpPortAttribute, ok := attributes["udp_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`udp_port is missing from object`)

		return nil, diags
	}

	udpPortVal, ok := udpPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`udp_port expected to be basetypes.Int64Value, was: %T`, udpPortAttribute))
	}

	vrfAttribute, ok := attributes["vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf is missing from object`)

		return nil, diags
	}

	vrfVal, ok := vrfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf expected to be basetypes.StringValue, was: %T`, vrfAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetflowExporterCollectionValue{
		ExporterIp:          exporterIpVal,
		ExporterName:        exporterNameVal,
		SourceInterfaceName: sourceInterfaceNameVal,
		UdpPort:             udpPortVal,
		Vrf:                 vrfVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewNetflowExporterCollectionValueNull() NetflowExporterCollectionValue {
	return NetflowExporterCollectionValue{
		state: attr.ValueStateNull,
	}
}

func NewNetflowExporterCollectionValueUnknown() NetflowExporterCollectionValue {
	return NetflowExporterCollectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetflowExporterCollectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetflowExporterCollectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetflowExporterCollectionValue Attribute Value",
				"While creating a NetflowExporterCollectionValue value, a missing attribute value was detected. "+
					"A NetflowExporterCollectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetflowExporterCollectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetflowExporterCollectionValue Attribute Type",
				"While creating a NetflowExporterCollectionValue value, an invalid attribute value was detected. "+
					"A NetflowExporterCollectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetflowExporterCollectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetflowExporterCollectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetflowExporterCollectionValue Attribute Value",
				"While creating a NetflowExporterCollectionValue value, an extra attribute value was detected. "+
					"A NetflowExporterCollectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetflowExporterCollectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetflowExporterCollectionValueUnknown(), diags
	}

	exporterIpAttribute, ok := attributes["exporter_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exporter_ip is missing from object`)

		return NewNetflowExporterCollectionValueUnknown(), diags
	}

	exporterIpVal, ok := exporterIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exporter_ip expected to be basetypes.StringValue, was: %T`, exporterIpAttribute))
	}

	exporterNameAttribute, ok := attributes["exporter_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exporter_name is missing from object`)

		return NewNetflowExporterCollectionValueUnknown(), diags
	}

	exporterNameVal, ok := exporterNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exporter_name expected to be basetypes.StringValue, was: %T`, exporterNameAttribute))
	}

	sourceInterfaceNameAttribute, ok := attributes["source_interface_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_interface_name is missing from object`)

		return NewNetflowExporterCollectionValueUnknown(), diags
	}

	sourceInterfaceNameVal, ok := sourceInterfaceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_interface_name expected to be basetypes.StringValue, was: %T`, sourceInterfaceNameAttribute))
	}

	udpPortAttribute, ok := attributes["udp_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`udp_port is missing from object`)

		return NewNetflowExporterCollectionValueUnknown(), diags
	}

	udpPortVal, ok := udpPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`udp_port expected to be basetypes.Int64Value, was: %T`, udpPortAttribute))
	}

	vrfAttribute, ok := attributes["vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf is missing from object`)

		return NewNetflowExporterCollectionValueUnknown(), diags
	}

	vrfVal, ok := vrfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf expected to be basetypes.StringValue, was: %T`, vrfAttribute))
	}

	if diags.HasError() {
		return NewNetflowExporterCollectionValueUnknown(), diags
	}

	return NetflowExporterCollectionValue{
		ExporterIp:          exporterIpVal,
		ExporterName:        exporterNameVal,
		SourceInterfaceName: sourceInterfaceNameVal,
		UdpPort:             udpPortVal,
		Vrf:                 vrfVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewNetflowExporterCollectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetflowExporterCollectionValue {
	object, diags := NewNetflowExporterCollectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetflowExporterCollectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetflowExporterCollectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetflowExporterCollectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetflowExporterCollectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetflowExporterCollectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetflowExporterCollectionValueMust(NetflowExporterCollectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetflowExporterCollectionType) ValueType(ctx context.Context) attr.Value {
	return NetflowExporterCollectionValue{}
}

var _ basetypes.ObjectValuable = NetflowExporterCollectionValue{}

type NetflowExporterCollectionValue struct {
	ExporterIp          basetypes.StringValue `tfsdk:"exporter_ip"`
	ExporterName        basetypes.StringValue `tfsdk:"exporter_name"`
	SourceInterfaceName basetypes.StringValue `tfsdk:"source_interface_name"`
	UdpPort             basetypes.Int64Value  `tfsdk:"udp_port"`
	Vrf                 basetypes.StringValue `tfsdk:"vrf"`
	state               attr.ValueState
}

func (v NetflowExporterCollectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["exporter_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["exporter_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_interface_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["udp_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vrf"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.ExporterIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exporter_ip"] = val

		val, err = v.ExporterName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exporter_name"] = val

		val, err = v.SourceInterfaceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_interface_name"] = val

		val, err = v.UdpPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["udp_port"] = val

		val, err = v.Vrf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetflowExporterCollectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetflowExporterCollectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetflowExporterCollectionValue) String() string {
	return "NetflowExporterCollectionValue"
}

func (v NetflowExporterCollectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"exporter_ip":           basetypes.StringType{},
		"exporter_name":         basetypes.StringType{},
		"source_interface_name": basetypes.StringType{},
		"udp_port":              basetypes.Int64Type{},
		"vrf":                   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"exporter_ip":           v.ExporterIp,
			"exporter_name":         v.ExporterName,
			"source_interface_name": v.SourceInterfaceName,
			"udp_port":              v.UdpPort,
			"vrf":                   v.Vrf,
		})

	return objVal, diags
}

func (v NetflowExporterCollectionValue) Equal(o attr.Value) bool {
	other, ok := o.(NetflowExporterCollectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExporterIp.Equal(other.ExporterIp) {
		return false
	}

	if !v.ExporterName.Equal(other.ExporterName) {
		return false
	}

	if !v.SourceInterfaceName.Equal(other.SourceInterfaceName) {
		return false
	}

	if !v.UdpPort.Equal(other.UdpPort) {
		return false
	}

	if !v.Vrf.Equal(other.Vrf) {
		return false
	}

	return true
}

func (v NetflowExporterCollectionValue) Type(ctx context.Context) attr.Type {
	return NetflowExporterCollectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetflowExporterCollectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"exporter_ip":           basetypes.StringType{},
		"exporter_name":         basetypes.StringType{},
		"source_interface_name": basetypes.StringType{},
		"udp_port":              basetypes.Int64Type{},
		"vrf":                   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NetflowMonitorCollectionType{}

type NetflowMonitorCollectionType struct {
	basetypes.ObjectType
}

func (t NetflowMonitorCollectionType) Equal(o attr.Type) bool {
	other, ok := o.(NetflowMonitorCollectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetflowMonitorCollectionType) String() string {
	return "NetflowMonitorCollectionType"
}

func (t NetflowMonitorCollectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	exporter1NameAttribute, ok := attributes["exporter1_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exporter1_name is missing from object`)

		return nil, diags
	}

	exporter1NameVal, ok := exporter1NameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exporter1_name expected to be basetypes.StringValue, was: %T`, exporter1NameAttribute))
	}

	exporter2NameAttribute, ok := attributes["exporter2_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exporter2_name is missing from object`)

		return nil, diags
	}

	exporter2NameVal, ok := exporter2NameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exporter2_name expected to be basetypes.StringValue, was: %T`, exporter2NameAttribute))
	}

	monitorNameAttribute, ok := attributes["monitor_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitor_name is missing from object`)

		return nil, diags
	}

	monitorNameVal, ok := monitorNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitor_name expected to be basetypes.StringValue, was: %T`, monitorNameAttribute))
	}

	monitorRecordNameAttribute, ok := attributes["monitor_record_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitor_record_name is missing from object`)

		return nil, diags
	}

	monitorRecordNameVal, ok := monitorRecordNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitor_record_name expected to be basetypes.StringValue, was: %T`, monitorRecordNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetflowMonitorCollectionValue{
		Exporter1Name:     exporter1NameVal,
		Exporter2Name:     exporter2NameVal,
		MonitorName:       monitorNameVal,
		MonitorRecordName: monitorRecordNameVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNetflowMonitorCollectionValueNull() NetflowMonitorCollectionValue {
	return NetflowMonitorCollectionValue{
		state: attr.ValueStateNull,
	}
}

func NewNetflowMonitorCollectionValueUnknown() NetflowMonitorCollectionValue {
	return NetflowMonitorCollectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetflowMonitorCollectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetflowMonitorCollectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetflowMonitorCollectionValue Attribute Value",
				"While creating a NetflowMonitorCollectionValue value, a missing attribute value was detected. "+
					"A NetflowMonitorCollectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetflowMonitorCollectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetflowMonitorCollectionValue Attribute Type",
				"While creating a NetflowMonitorCollectionValue value, an invalid attribute value was detected. "+
					"A NetflowMonitorCollectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetflowMonitorCollectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetflowMonitorCollectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetflowMonitorCollectionValue Attribute Value",
				"While creating a NetflowMonitorCollectionValue value, an extra attribute value was detected. "+
					"A NetflowMonitorCollectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetflowMonitorCollectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetflowMonitorCollectionValueUnknown(), diags
	}

	exporter1NameAttribute, ok := attributes["exporter1_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exporter1_name is missing from object`)

		return NewNetflowMonitorCollectionValueUnknown(), diags
	}

	exporter1NameVal, ok := exporter1NameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exporter1_name expected to be basetypes.StringValue, was: %T`, exporter1NameAttribute))
	}

	exporter2NameAttribute, ok := attributes["exporter2_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exporter2_name is missing from object`)

		return NewNetflowMonitorCollectionValueUnknown(), diags
	}

	exporter2NameVal, ok := exporter2NameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exporter2_name expected to be basetypes.StringValue, was: %T`, exporter2NameAttribute))
	}

	monitorNameAttribute, ok := attributes["monitor_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitor_name is missing from object`)

		return NewNetflowMonitorCollectionValueUnknown(), diags
	}

	monitorNameVal, ok := monitorNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitor_name expected to be basetypes.StringValue, was: %T`, monitorNameAttribute))
	}

	monitorRecordNameAttribute, ok := attributes["monitor_record_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitor_record_name is missing from object`)

		return NewNetflowMonitorCollectionValueUnknown(), diags
	}

	monitorRecordNameVal, ok := monitorRecordNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitor_record_name expected to be basetypes.StringValue, was: %T`, monitorRecordNameAttribute))
	}

	if diags.HasError() {
		return NewNetflowMonitorCollectionValueUnknown(), diags
	}

	return NetflowMonitorCollectionValue{
		Exporter1Name:     exporter1NameVal,
		Exporter2Name:     exporter2NameVal,
		MonitorName:       monitorNameVal,
		MonitorRecordName: monitorRecordNameVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNetflowMonitorCollectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetflowMonitorCollectionValue {
	object, diags := NewNetflowMonitorCollectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetflowMonitorCollectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetflowMonitorCollectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetflowMonitorCollectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetflowMonitorCollectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetflowMonitorCollectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetflowMonitorCollectionValueMust(NetflowMonitorCollectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetflowMonitorCollectionType) ValueType(ctx context.Context) attr.Value {
	return NetflowMonitorCollectionValue{}
}

var _ basetypes.ObjectValuable = NetflowMonitorCollectionValue{}

type NetflowMonitorCollectionValue struct {
	Exporter1Name     basetypes.StringValue `tfsdk:"exporter1_name"`
	Exporter2Name     basetypes.StringValue `tfsdk:"exporter2_name"`
	MonitorName       basetypes.StringValue `tfsdk:"monitor_name"`
	MonitorRecordName basetypes.StringValue `tfsdk:"monitor_record_name"`
	state             attr.ValueState
}

func (v NetflowMonitorCollectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["exporter1_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["exporter2_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["monitor_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["monitor_record_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Exporter1Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exporter1_name"] = val

		val, err = v.Exporter2Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exporter2_name"] = val

		val, err = v.MonitorName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monitor_name"] = val

		val, err = v.MonitorRecordName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monitor_record_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetflowMonitorCollectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetflowMonitorCollectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetflowMonitorCollectionValue) String() string {
	return "NetflowMonitorCollectionValue"
}

func (v NetflowMonitorCollectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"exporter1_name":      basetypes.StringType{},
		"exporter2_name":      basetypes.StringType{},
		"monitor_name":        basetypes.StringType{},
		"monitor_record_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"exporter1_name":      v.Exporter1Name,
			"exporter2_name":      v.Exporter2Name,
			"monitor_name":        v.MonitorName,
			"monitor_record_name": v.MonitorRecordName,
		})

	return objVal, diags
}

func (v NetflowMonitorCollectionValue) Equal(o attr.Value) bool {
	other, ok := o.(NetflowMonitorCollectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Exporter1Name.Equal(other.Exporter1Name) {
		return false
	}

	if !v.Exporter2Name.Equal(other.Exporter2Name) {
		return false
	}

	if !v.MonitorName.Equal(other.MonitorName) {
		return false
	}

	if !v.MonitorRecordName.Equal(other.MonitorRecordName) {
		return false
	}

	return true
}

func (v NetflowMonitorCollectionValue) Type(ctx context.Context) attr.Type {
	return NetflowMonitorCollectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetflowMonitorCollectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"exporter1_name":      basetypes.StringType{},
		"exporter2_name":      basetypes.StringType{},
		"monitor_name":        basetypes.StringType{},
		"monitor_record_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NetflowRecordCollectionType{}

type NetflowRecordCollectionType struct {
	basetypes.ObjectType
}

func (t NetflowRecordCollectionType) Equal(o attr.Type) bool {
	other, ok := o.(NetflowRecordCollectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetflowRecordCollectionType) String() string {
	return "NetflowRecordCollectionType"
}

func (t NetflowRecordCollectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	layer2RecordAttribute, ok := attributes["layer2_record"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`layer2_record is missing from object`)

		return nil, diags
	}

	layer2RecordVal, ok := layer2RecordAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`layer2_record expected to be basetypes.BoolValue, was: %T`, layer2RecordAttribute))
	}

	recordNameAttribute, ok := attributes["record_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_name is missing from object`)

		return nil, diags
	}

	recordNameVal, ok := recordNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_name expected to be basetypes.StringValue, was: %T`, recordNameAttribute))
	}

	recordTemplateAttribute, ok := attributes["record_template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_template is missing from object`)

		return nil, diags
	}

	recordTemplateVal, ok := recordTemplateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_template expected to be basetypes.StringValue, was: %T`, recordTemplateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetflowRecordCollectionValue{
		Layer2Record:   layer2RecordVal,
		RecordName:     recordNameVal,
		RecordTemplate: recordTemplateVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewNetflowRecordCollectionValueNull() NetflowRecordCollectionValue {
	return NetflowRecordCollectionValue{
		state: attr.ValueStateNull,
	}
}

func NewNetflowRecordCollectionValueUnknown() NetflowRecordCollectionValue {
	return NetflowRecordCollectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetflowRecordCollectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetflowRecordCollectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetflowRecordCollectionValue Attribute Value",
				"While creating a NetflowRecordCollectionValue value, a missing attribute value was detected. "+
					"A NetflowRecordCollectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetflowRecordCollectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetflowRecordCollectionValue Attribute Type",
				"While creating a NetflowRecordCollectionValue value, an invalid attribute value was detected. "+
					"A NetflowRecordCollectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetflowRecordCollectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetflowRecordCollectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetflowRecordCollectionValue Attribute Value",
				"While creating a NetflowRecordCollectionValue value, an extra attribute value was detected. "+
					"A NetflowRecordCollectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetflowRecordCollectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetflowRecordCollectionValueUnknown(), diags
	}

	layer2RecordAttribute, ok := attributes["layer2_record"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`layer2_record is missing from object`)

		return NewNetflowRecordCollectionValueUnknown(), diags
	}

	layer2RecordVal, ok := layer2RecordAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`layer2_record expected to be basetypes.BoolValue, was: %T`, layer2RecordAttribute))
	}

	recordNameAttribute, ok := attributes["record_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_name is missing from object`)

		return NewNetflowRecordCollectionValueUnknown(), diags
	}

	recordNameVal, ok := recordNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_name expected to be basetypes.StringValue, was: %T`, recordNameAttribute))
	}

	recordTemplateAttribute, ok := attributes["record_template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_template is missing from object`)

		return NewNetflowRecordCollectionValueUnknown(), diags
	}

	recordTemplateVal, ok := recordTemplateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_template expected to be basetypes.StringValue, was: %T`, recordTemplateAttribute))
	}

	if diags.HasError() {
		return NewNetflowRecordCollectionValueUnknown(), diags
	}

	return NetflowRecordCollectionValue{
		Layer2Record:   layer2RecordVal,
		RecordName:     recordNameVal,
		RecordTemplate: recordTemplateVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewNetflowRecordCollectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetflowRecordCollectionValue {
	object, diags := NewNetflowRecordCollectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetflowRecordCollectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetflowRecordCollectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetflowRecordCollectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetflowRecordCollectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetflowRecordCollectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetflowRecordCollectionValueMust(NetflowRecordCollectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetflowRecordCollectionType) ValueType(ctx context.Context) attr.Value {
	return NetflowRecordCollectionValue{}
}

var _ basetypes.ObjectValuable = NetflowRecordCollectionValue{}

type NetflowRecordCollectionValue struct {
	Layer2Record   basetypes.BoolValue   `tfsdk:"layer2_record"`
	RecordName     basetypes.StringValue `tfsdk:"record_name"`
	RecordTemplate basetypes.StringValue `tfsdk:"record_template"`
	state          attr.ValueState
}

func (v NetflowRecordCollectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["layer2_record"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["record_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["record_template"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Layer2Record.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["layer2_record"] = val

		val, err = v.RecordName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["record_name"] = val

		val, err = v.RecordTemplate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["record_template"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetflowRecordCollectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetflowRecordCollectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetflowRecordCollectionValue) String() string {
	return "NetflowRecordCollectionValue"
}

func (v NetflowRecordCollectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"layer2_record":   basetypes.BoolType{},
		"record_name":     basetypes.StringType{},
		"record_template": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"layer2_record":   v.Layer2Record,
			"record_name":     v.RecordName,
			"record_template": v.RecordTemplate,
		})

	return objVal, diags
}

func (v NetflowRecordCollectionValue) Equal(o attr.Value) bool {
	other, ok := o.(NetflowRecordCollectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Layer2Record.Equal(other.Layer2Record) {
		return false
	}

	if !v.RecordName.Equal(other.RecordName) {
		return false
	}

	if !v.RecordTemplate.Equal(other.RecordTemplate) {
		return false
	}

	return true
}

func (v NetflowRecordCollectionValue) Type(ctx context.Context) attr.Type {
	return NetflowRecordCollectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetflowRecordCollectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"layer2_record":   basetypes.BoolType{},
		"record_name":     basetypes.StringType{},
		"record_template": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NetflowSamplerCollectionType{}

type NetflowSamplerCollectionType struct {
	basetypes.ObjectType
}

func (t NetflowSamplerCollectionType) Equal(o attr.Type) bool {
	other, ok := o.(NetflowSamplerCollectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetflowSamplerCollectionType) String() string {
	return "NetflowSamplerCollectionType"
}

func (t NetflowSamplerCollectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	numSamplesAttribute, ok := attributes["num_samples"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_samples is missing from object`)

		return nil, diags
	}

	numSamplesVal, ok := numSamplesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_samples expected to be basetypes.Int64Value, was: %T`, numSamplesAttribute))
	}

	samplerNameAttribute, ok := attributes["sampler_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sampler_name is missing from object`)

		return nil, diags
	}

	samplerNameVal, ok := samplerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sampler_name expected to be basetypes.StringValue, was: %T`, samplerNameAttribute))
	}

	samplingRateAttribute, ok := attributes["sampling_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sampling_rate is missing from object`)

		return nil, diags
	}

	samplingRateVal, ok := samplingRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sampling_rate expected to be basetypes.Int64Value, was: %T`, samplingRateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetflowSamplerCollectionValue{
		NumSamples:   numSamplesVal,
		SamplerName:  samplerNameVal,
		SamplingRate: samplingRateVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewNetflowSamplerCollectionValueNull() NetflowSamplerCollectionValue {
	return NetflowSamplerCollectionValue{
		state: attr.ValueStateNull,
	}
}

func NewNetflowSamplerCollectionValueUnknown() NetflowSamplerCollectionValue {
	return NetflowSamplerCollectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetflowSamplerCollectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetflowSamplerCollectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetflowSamplerCollectionValue Attribute Value",
				"While creating a NetflowSamplerCollectionValue value, a missing attribute value was detected. "+
					"A NetflowSamplerCollectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetflowSamplerCollectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetflowSamplerCollectionValue Attribute Type",
				"While creating a NetflowSamplerCollectionValue value, an invalid attribute value was detected. "+
					"A NetflowSamplerCollectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetflowSamplerCollectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetflowSamplerCollectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetflowSamplerCollectionValue Attribute Value",
				"While creating a NetflowSamplerCollectionValue value, an extra attribute value was detected. "+
					"A NetflowSamplerCollectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetflowSamplerCollectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetflowSamplerCollectionValueUnknown(), diags
	}

	numSamplesAttribute, ok := attributes["num_samples"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_samples is missing from object`)

		return NewNetflowSamplerCollectionValueUnknown(), diags
	}

	numSamplesVal, ok := numSamplesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_samples expected to be basetypes.Int64Value, was: %T`, numSamplesAttribute))
	}

	samplerNameAttribute, ok := attributes["sampler_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sampler_name is missing from object`)

		return NewNetflowSamplerCollectionValueUnknown(), diags
	}

	samplerNameVal, ok := samplerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sampler_name expected to be basetypes.StringValue, was: %T`, samplerNameAttribute))
	}

	samplingRateAttribute, ok := attributes["sampling_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sampling_rate is missing from object`)

		return NewNetflowSamplerCollectionValueUnknown(), diags
	}

	samplingRateVal, ok := samplingRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sampling_rate expected to be basetypes.Int64Value, was: %T`, samplingRateAttribute))
	}

	if diags.HasError() {
		return NewNetflowSamplerCollectionValueUnknown(), diags
	}

	return NetflowSamplerCollectionValue{
		NumSamples:   numSamplesVal,
		SamplerName:  samplerNameVal,
		SamplingRate: samplingRateVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewNetflowSamplerCollectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetflowSamplerCollectionValue {
	object, diags := NewNetflowSamplerCollectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetflowSamplerCollectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetflowSamplerCollectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetflowSamplerCollectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetflowSamplerCollectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetflowSamplerCollectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetflowSamplerCollectionValueMust(NetflowSamplerCollectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetflowSamplerCollectionType) ValueType(ctx context.Context) attr.Value {
	return NetflowSamplerCollectionValue{}
}

var _ basetypes.ObjectValuable = NetflowSamplerCollectionValue{}

type NetflowSamplerCollectionValue struct {
	NumSamples   basetypes.Int64Value  `tfsdk:"num_samples"`
	SamplerName  basetypes.StringValue `tfsdk:"sampler_name"`
	SamplingRate basetypes.Int64Value  `tfsdk:"sampling_rate"`
	state        attr.ValueState
}

func (v NetflowSamplerCollectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["num_samples"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["sampler_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sampling_rate"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.NumSamples.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_samples"] = val

		val, err = v.SamplerName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sampler_name"] = val

		val, err = v.SamplingRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sampling_rate"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetflowSamplerCollectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetflowSamplerCollectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetflowSamplerCollectionValue) String() string {
	return "NetflowSamplerCollectionValue"
}

func (v NetflowSamplerCollectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"num_samples":   basetypes.Int64Type{},
		"sampler_name":  basetypes.StringType{},
		"sampling_rate": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"num_samples":   v.NumSamples,
			"sampler_name":  v.SamplerName,
			"sampling_rate": v.SamplingRate,
		})

	return objVal, diags
}

func (v NetflowSamplerCollectionValue) Equal(o attr.Value) bool {
	other, ok := o.(NetflowSamplerCollectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NumSamples.Equal(other.NumSamples) {
		return false
	}

	if !v.SamplerName.Equal(other.SamplerName) {
		return false
	}

	if !v.SamplingRate.Equal(other.SamplingRate) {
		return false
	}

	return true
}

func (v NetflowSamplerCollectionValue) Type(ctx context.Context) attr.Type {
	return NetflowSamplerCollectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetflowSamplerCollectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"num_samples":   basetypes.Int64Type{},
		"sampler_name":  basetypes.StringType{},
		"sampling_rate": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = VrfFlowRulesType{}

type VrfFlowRulesType struct {
	basetypes.ObjectType
}

func (t VrfFlowRulesType) Equal(o attr.Type) bool {
	other, ok := o.(VrfFlowRulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrfFlowRulesType) String() string {
	return "VrfFlowRulesType"
}

func (t VrfFlowRulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	vrfFlowRuleAttributesAttribute, ok := attributes["vrf_flow_rule_attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_attributes is missing from object`)

		return nil, diags
	}

	vrfFlowRuleAttributesVal, ok := vrfFlowRuleAttributesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_attributes expected to be basetypes.ListValue, was: %T`, vrfFlowRuleAttributesAttribute))
	}

	vrfFlowRuleNameAttribute, ok := attributes["vrf_flow_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_name is missing from object`)

		return nil, diags
	}

	vrfFlowRuleNameVal, ok := vrfFlowRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_name expected to be basetypes.StringValue, was: %T`, vrfFlowRuleNameAttribute))
	}

	vrfFlowRuleSubnetsAttribute, ok := attributes["vrf_flow_rule_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_subnets is missing from object`)

		return nil, diags
	}

	vrfFlowRuleSubnetsVal, ok := vrfFlowRuleSubnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_subnets expected to be basetypes.SetValue, was: %T`, vrfFlowRuleSubnetsAttribute))
	}

	vrfFlowRuleTenantAttribute, ok := attributes["vrf_flow_rule_tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_tenant is missing from object`)

		return nil, diags
	}

	vrfFlowRuleTenantVal, ok := vrfFlowRuleTenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_tenant expected to be basetypes.StringValue, was: %T`, vrfFlowRuleTenantAttribute))
	}

	vrfFlowRuleUuidAttribute, ok := attributes["vrf_flow_rule_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_uuid is missing from object`)

		return nil, diags
	}

	vrfFlowRuleUuidVal, ok := vrfFlowRuleUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_uuid expected to be basetypes.StringValue, was: %T`, vrfFlowRuleUuidAttribute))
	}

	vrfFlowRuleVrfAttribute, ok := attributes["vrf_flow_rule_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_vrf is missing from object`)

		return nil, diags
	}

	vrfFlowRuleVrfVal, ok := vrfFlowRuleVrfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_vrf expected to be basetypes.StringValue, was: %T`, vrfFlowRuleVrfAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrfFlowRulesValue{
		VrfFlowRuleAttributes: vrfFlowRuleAttributesVal,
		VrfFlowRuleName:       vrfFlowRuleNameVal,
		VrfFlowRuleSubnets:    vrfFlowRuleSubnetsVal,
		VrfFlowRuleTenant:     vrfFlowRuleTenantVal,
		VrfFlowRuleUuid:       vrfFlowRuleUuidVal,
		VrfFlowRuleVrf:        vrfFlowRuleVrfVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewVrfFlowRulesValueNull() VrfFlowRulesValue {
	return VrfFlowRulesValue{
		state: attr.ValueStateNull,
	}
}

func NewVrfFlowRulesValueUnknown() VrfFlowRulesValue {
	return VrfFlowRulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrfFlowRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrfFlowRulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrfFlowRulesValue Attribute Value",
				"While creating a VrfFlowRulesValue value, a missing attribute value was detected. "+
					"A VrfFlowRulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfFlowRulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrfFlowRulesValue Attribute Type",
				"While creating a VrfFlowRulesValue value, an invalid attribute value was detected. "+
					"A VrfFlowRulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfFlowRulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrfFlowRulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrfFlowRulesValue Attribute Value",
				"While creating a VrfFlowRulesValue value, an extra attribute value was detected. "+
					"A VrfFlowRulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrfFlowRulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrfFlowRulesValueUnknown(), diags
	}

	vrfFlowRuleAttributesAttribute, ok := attributes["vrf_flow_rule_attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_attributes is missing from object`)

		return NewVrfFlowRulesValueUnknown(), diags
	}

	vrfFlowRuleAttributesVal, ok := vrfFlowRuleAttributesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_attributes expected to be basetypes.ListValue, was: %T`, vrfFlowRuleAttributesAttribute))
	}

	vrfFlowRuleNameAttribute, ok := attributes["vrf_flow_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_name is missing from object`)

		return NewVrfFlowRulesValueUnknown(), diags
	}

	vrfFlowRuleNameVal, ok := vrfFlowRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_name expected to be basetypes.StringValue, was: %T`, vrfFlowRuleNameAttribute))
	}

	vrfFlowRuleSubnetsAttribute, ok := attributes["vrf_flow_rule_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_subnets is missing from object`)

		return NewVrfFlowRulesValueUnknown(), diags
	}

	vrfFlowRuleSubnetsVal, ok := vrfFlowRuleSubnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_subnets expected to be basetypes.SetValue, was: %T`, vrfFlowRuleSubnetsAttribute))
	}

	vrfFlowRuleTenantAttribute, ok := attributes["vrf_flow_rule_tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_tenant is missing from object`)

		return NewVrfFlowRulesValueUnknown(), diags
	}

	vrfFlowRuleTenantVal, ok := vrfFlowRuleTenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_tenant expected to be basetypes.StringValue, was: %T`, vrfFlowRuleTenantAttribute))
	}

	vrfFlowRuleUuidAttribute, ok := attributes["vrf_flow_rule_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_uuid is missing from object`)

		return NewVrfFlowRulesValueUnknown(), diags
	}

	vrfFlowRuleUuidVal, ok := vrfFlowRuleUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_uuid expected to be basetypes.StringValue, was: %T`, vrfFlowRuleUuidAttribute))
	}

	vrfFlowRuleVrfAttribute, ok := attributes["vrf_flow_rule_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_vrf is missing from object`)

		return NewVrfFlowRulesValueUnknown(), diags
	}

	vrfFlowRuleVrfVal, ok := vrfFlowRuleVrfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_vrf expected to be basetypes.StringValue, was: %T`, vrfFlowRuleVrfAttribute))
	}

	if diags.HasError() {
		return NewVrfFlowRulesValueUnknown(), diags
	}

	return VrfFlowRulesValue{
		VrfFlowRuleAttributes: vrfFlowRuleAttributesVal,
		VrfFlowRuleName:       vrfFlowRuleNameVal,
		VrfFlowRuleSubnets:    vrfFlowRuleSubnetsVal,
		VrfFlowRuleTenant:     vrfFlowRuleTenantVal,
		VrfFlowRuleUuid:       vrfFlowRuleUuidVal,
		VrfFlowRuleVrf:        vrfFlowRuleVrfVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewVrfFlowRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrfFlowRulesValue {
	object, diags := NewVrfFlowRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrfFlowRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrfFlowRulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrfFlowRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrfFlowRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrfFlowRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrfFlowRulesValueMust(VrfFlowRulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrfFlowRulesType) ValueType(ctx context.Context) attr.Value {
	return VrfFlowRulesValue{}
}

var _ basetypes.ObjectValuable = VrfFlowRulesValue{}

type VrfFlowRulesValue struct {
	VrfFlowRuleAttributes basetypes.ListValue   `tfsdk:"vrf_flow_rule_attributes"`
	VrfFlowRuleName       basetypes.StringValue `tfsdk:"vrf_flow_rule_name"`
	VrfFlowRuleSubnets    basetypes.SetValue    `tfsdk:"vrf_flow_rule_subnets"`
	VrfFlowRuleTenant     basetypes.StringValue `tfsdk:"vrf_flow_rule_tenant"`
	VrfFlowRuleUuid       basetypes.StringValue `tfsdk:"vrf_flow_rule_uuid"`
	VrfFlowRuleVrf        basetypes.StringValue `tfsdk:"vrf_flow_rule_vrf"`
	state                 attr.ValueState
}

func (v VrfFlowRulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["vrf_flow_rule_attributes"] = basetypes.ListType{
		ElemType: VrfFlowRuleAttributesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_subnets"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_tenant"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_vrf"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.VrfFlowRuleAttributes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_attributes"] = val

		val, err = v.VrfFlowRuleName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_name"] = val

		val, err = v.VrfFlowRuleSubnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_subnets"] = val

		val, err = v.VrfFlowRuleTenant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_tenant"] = val

		val, err = v.VrfFlowRuleUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_uuid"] = val

		val, err = v.VrfFlowRuleVrf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_vrf"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrfFlowRulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrfFlowRulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrfFlowRulesValue) String() string {
	return "VrfFlowRulesValue"
}

func (v VrfFlowRulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	vrfFlowRuleAttributes := types.ListValueMust(
		VrfFlowRuleAttributesType{
			basetypes.ObjectType{
				AttrTypes: VrfFlowRuleAttributesValue{}.AttributeTypes(ctx),
			},
		},
		v.VrfFlowRuleAttributes.Elements(),
	)

	if v.VrfFlowRuleAttributes.IsNull() {
		vrfFlowRuleAttributes = types.ListNull(
			VrfFlowRuleAttributesType{
				basetypes.ObjectType{
					AttrTypes: VrfFlowRuleAttributesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VrfFlowRuleAttributes.IsUnknown() {
		vrfFlowRuleAttributes = types.ListUnknown(
			VrfFlowRuleAttributesType{
				basetypes.ObjectType{
					AttrTypes: VrfFlowRuleAttributesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var vrfFlowRuleSubnetsVal basetypes.SetValue
	switch {
	case v.VrfFlowRuleSubnets.IsUnknown():
		vrfFlowRuleSubnetsVal = types.SetUnknown(types.StringType)
	case v.VrfFlowRuleSubnets.IsNull():
		vrfFlowRuleSubnetsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		vrfFlowRuleSubnetsVal, d = types.SetValue(types.StringType, v.VrfFlowRuleSubnets.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"vrf_flow_rule_attributes": basetypes.ListType{
				ElemType: VrfFlowRuleAttributesValue{}.Type(ctx),
			},
			"vrf_flow_rule_name": basetypes.StringType{},
			"vrf_flow_rule_subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"vrf_flow_rule_tenant": basetypes.StringType{},
			"vrf_flow_rule_uuid":   basetypes.StringType{},
			"vrf_flow_rule_vrf":    basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"vrf_flow_rule_attributes": basetypes.ListType{
			ElemType: VrfFlowRuleAttributesValue{}.Type(ctx),
		},
		"vrf_flow_rule_name": basetypes.StringType{},
		"vrf_flow_rule_subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"vrf_flow_rule_tenant": basetypes.StringType{},
		"vrf_flow_rule_uuid":   basetypes.StringType{},
		"vrf_flow_rule_vrf":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"vrf_flow_rule_attributes": vrfFlowRuleAttributes,
			"vrf_flow_rule_name":       v.VrfFlowRuleName,
			"vrf_flow_rule_subnets":    vrfFlowRuleSubnetsVal,
			"vrf_flow_rule_tenant":     v.VrfFlowRuleTenant,
			"vrf_flow_rule_uuid":       v.VrfFlowRuleUuid,
			"vrf_flow_rule_vrf":        v.VrfFlowRuleVrf,
		})

	return objVal, diags
}

func (v VrfFlowRulesValue) Equal(o attr.Value) bool {
	other, ok := o.(VrfFlowRulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.VrfFlowRuleAttributes.Equal(other.VrfFlowRuleAttributes) {
		return false
	}

	if !v.VrfFlowRuleName.Equal(other.VrfFlowRuleName) {
		return false
	}

	if !v.VrfFlowRuleSubnets.Equal(other.VrfFlowRuleSubnets) {
		return false
	}

	if !v.VrfFlowRuleTenant.Equal(other.VrfFlowRuleTenant) {
		return false
	}

	if !v.VrfFlowRuleUuid.Equal(other.VrfFlowRuleUuid) {
		return false
	}

	if !v.VrfFlowRuleVrf.Equal(other.VrfFlowRuleVrf) {
		return false
	}

	return true
}

func (v VrfFlowRulesValue) Type(ctx context.Context) attr.Type {
	return VrfFlowRulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrfFlowRulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"vrf_flow_rule_attributes": basetypes.ListType{
			ElemType: VrfFlowRuleAttributesValue{}.Type(ctx),
		},
		"vrf_flow_rule_name": basetypes.StringType{},
		"vrf_flow_rule_subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"vrf_flow_rule_tenant": basetypes.StringType{},
		"vrf_flow_rule_uuid":   basetypes.StringType{},
		"vrf_flow_rule_vrf":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VrfFlowRuleAttributesType{}

type VrfFlowRuleAttributesType struct {
	basetypes.ObjectType
}

func (t VrfFlowRuleAttributesType) Equal(o attr.Type) bool {
	other, ok := o.(VrfFlowRuleAttributesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrfFlowRuleAttributesType) String() string {
	return "VrfFlowRuleAttributesType"
}

func (t VrfFlowRuleAttributesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	vrfFlowRuleAttributeIdAttribute, ok := attributes["vrf_flow_rule_attribute_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_attribute_id is missing from object`)

		return nil, diags
	}

	vrfFlowRuleAttributeIdVal, ok := vrfFlowRuleAttributeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_attribute_id expected to be basetypes.StringValue, was: %T`, vrfFlowRuleAttributeIdAttribute))
	}

	vrfFlowRuleBidirectionalAttribute, ok := attributes["vrf_flow_rule_bidirectional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_bidirectional is missing from object`)

		return nil, diags
	}

	vrfFlowRuleBidirectionalVal, ok := vrfFlowRuleBidirectionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_bidirectional expected to be basetypes.BoolValue, was: %T`, vrfFlowRuleBidirectionalAttribute))
	}

	vrfFlowRuleDstIpAttribute, ok := attributes["vrf_flow_rule_dst_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_dst_ip is missing from object`)

		return nil, diags
	}

	vrfFlowRuleDstIpVal, ok := vrfFlowRuleDstIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_dst_ip expected to be basetypes.StringValue, was: %T`, vrfFlowRuleDstIpAttribute))
	}

	vrfFlowRuleDstPortAttribute, ok := attributes["vrf_flow_rule_dst_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_dst_port is missing from object`)

		return nil, diags
	}

	vrfFlowRuleDstPortVal, ok := vrfFlowRuleDstPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_dst_port expected to be basetypes.StringValue, was: %T`, vrfFlowRuleDstPortAttribute))
	}

	vrfFlowRuleProtocolAttribute, ok := attributes["vrf_flow_rule_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_protocol is missing from object`)

		return nil, diags
	}

	vrfFlowRuleProtocolVal, ok := vrfFlowRuleProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_protocol expected to be basetypes.StringValue, was: %T`, vrfFlowRuleProtocolAttribute))
	}

	vrfFlowRuleSrcIpAttribute, ok := attributes["vrf_flow_rule_src_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_src_ip is missing from object`)

		return nil, diags
	}

	vrfFlowRuleSrcIpVal, ok := vrfFlowRuleSrcIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_src_ip expected to be basetypes.StringValue, was: %T`, vrfFlowRuleSrcIpAttribute))
	}

	vrfFlowRuleSrcPortAttribute, ok := attributes["vrf_flow_rule_src_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_src_port is missing from object`)

		return nil, diags
	}

	vrfFlowRuleSrcPortVal, ok := vrfFlowRuleSrcPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_src_port expected to be basetypes.StringValue, was: %T`, vrfFlowRuleSrcPortAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrfFlowRuleAttributesValue{
		VrfFlowRuleAttributeId:   vrfFlowRuleAttributeIdVal,
		VrfFlowRuleBidirectional: vrfFlowRuleBidirectionalVal,
		VrfFlowRuleDstIp:         vrfFlowRuleDstIpVal,
		VrfFlowRuleDstPort:       vrfFlowRuleDstPortVal,
		VrfFlowRuleProtocol:      vrfFlowRuleProtocolVal,
		VrfFlowRuleSrcIp:         vrfFlowRuleSrcIpVal,
		VrfFlowRuleSrcPort:       vrfFlowRuleSrcPortVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewVrfFlowRuleAttributesValueNull() VrfFlowRuleAttributesValue {
	return VrfFlowRuleAttributesValue{
		state: attr.ValueStateNull,
	}
}

func NewVrfFlowRuleAttributesValueUnknown() VrfFlowRuleAttributesValue {
	return VrfFlowRuleAttributesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrfFlowRuleAttributesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrfFlowRuleAttributesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrfFlowRuleAttributesValue Attribute Value",
				"While creating a VrfFlowRuleAttributesValue value, a missing attribute value was detected. "+
					"A VrfFlowRuleAttributesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfFlowRuleAttributesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrfFlowRuleAttributesValue Attribute Type",
				"While creating a VrfFlowRuleAttributesValue value, an invalid attribute value was detected. "+
					"A VrfFlowRuleAttributesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfFlowRuleAttributesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrfFlowRuleAttributesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrfFlowRuleAttributesValue Attribute Value",
				"While creating a VrfFlowRuleAttributesValue value, an extra attribute value was detected. "+
					"A VrfFlowRuleAttributesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrfFlowRuleAttributesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	vrfFlowRuleAttributeIdAttribute, ok := attributes["vrf_flow_rule_attribute_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_attribute_id is missing from object`)

		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	vrfFlowRuleAttributeIdVal, ok := vrfFlowRuleAttributeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_attribute_id expected to be basetypes.StringValue, was: %T`, vrfFlowRuleAttributeIdAttribute))
	}

	vrfFlowRuleBidirectionalAttribute, ok := attributes["vrf_flow_rule_bidirectional"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_bidirectional is missing from object`)

		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	vrfFlowRuleBidirectionalVal, ok := vrfFlowRuleBidirectionalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_bidirectional expected to be basetypes.BoolValue, was: %T`, vrfFlowRuleBidirectionalAttribute))
	}

	vrfFlowRuleDstIpAttribute, ok := attributes["vrf_flow_rule_dst_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_dst_ip is missing from object`)

		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	vrfFlowRuleDstIpVal, ok := vrfFlowRuleDstIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_dst_ip expected to be basetypes.StringValue, was: %T`, vrfFlowRuleDstIpAttribute))
	}

	vrfFlowRuleDstPortAttribute, ok := attributes["vrf_flow_rule_dst_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_dst_port is missing from object`)

		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	vrfFlowRuleDstPortVal, ok := vrfFlowRuleDstPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_dst_port expected to be basetypes.StringValue, was: %T`, vrfFlowRuleDstPortAttribute))
	}

	vrfFlowRuleProtocolAttribute, ok := attributes["vrf_flow_rule_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_protocol is missing from object`)

		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	vrfFlowRuleProtocolVal, ok := vrfFlowRuleProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_protocol expected to be basetypes.StringValue, was: %T`, vrfFlowRuleProtocolAttribute))
	}

	vrfFlowRuleSrcIpAttribute, ok := attributes["vrf_flow_rule_src_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_src_ip is missing from object`)

		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	vrfFlowRuleSrcIpVal, ok := vrfFlowRuleSrcIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_src_ip expected to be basetypes.StringValue, was: %T`, vrfFlowRuleSrcIpAttribute))
	}

	vrfFlowRuleSrcPortAttribute, ok := attributes["vrf_flow_rule_src_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_flow_rule_src_port is missing from object`)

		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	vrfFlowRuleSrcPortVal, ok := vrfFlowRuleSrcPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_flow_rule_src_port expected to be basetypes.StringValue, was: %T`, vrfFlowRuleSrcPortAttribute))
	}

	if diags.HasError() {
		return NewVrfFlowRuleAttributesValueUnknown(), diags
	}

	return VrfFlowRuleAttributesValue{
		VrfFlowRuleAttributeId:   vrfFlowRuleAttributeIdVal,
		VrfFlowRuleBidirectional: vrfFlowRuleBidirectionalVal,
		VrfFlowRuleDstIp:         vrfFlowRuleDstIpVal,
		VrfFlowRuleDstPort:       vrfFlowRuleDstPortVal,
		VrfFlowRuleProtocol:      vrfFlowRuleProtocolVal,
		VrfFlowRuleSrcIp:         vrfFlowRuleSrcIpVal,
		VrfFlowRuleSrcPort:       vrfFlowRuleSrcPortVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewVrfFlowRuleAttributesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrfFlowRuleAttributesValue {
	object, diags := NewVrfFlowRuleAttributesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrfFlowRuleAttributesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrfFlowRuleAttributesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrfFlowRuleAttributesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrfFlowRuleAttributesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrfFlowRuleAttributesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrfFlowRuleAttributesValueMust(VrfFlowRuleAttributesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrfFlowRuleAttributesType) ValueType(ctx context.Context) attr.Value {
	return VrfFlowRuleAttributesValue{}
}

var _ basetypes.ObjectValuable = VrfFlowRuleAttributesValue{}

type VrfFlowRuleAttributesValue struct {
	VrfFlowRuleAttributeId   basetypes.StringValue `tfsdk:"vrf_flow_rule_attribute_id"`
	VrfFlowRuleBidirectional basetypes.BoolValue   `tfsdk:"vrf_flow_rule_bidirectional"`
	VrfFlowRuleDstIp         basetypes.StringValue `tfsdk:"vrf_flow_rule_dst_ip"`
	VrfFlowRuleDstPort       basetypes.StringValue `tfsdk:"vrf_flow_rule_dst_port"`
	VrfFlowRuleProtocol      basetypes.StringValue `tfsdk:"vrf_flow_rule_protocol"`
	VrfFlowRuleSrcIp         basetypes.StringValue `tfsdk:"vrf_flow_rule_src_ip"`
	VrfFlowRuleSrcPort       basetypes.StringValue `tfsdk:"vrf_flow_rule_src_port"`
	state                    attr.ValueState
}

func (v VrfFlowRuleAttributesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["vrf_flow_rule_attribute_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_bidirectional"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_dst_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_dst_port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_src_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_flow_rule_src_port"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.VrfFlowRuleAttributeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_attribute_id"] = val

		val, err = v.VrfFlowRuleBidirectional.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_bidirectional"] = val

		val, err = v.VrfFlowRuleDstIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_dst_ip"] = val

		val, err = v.VrfFlowRuleDstPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_dst_port"] = val

		val, err = v.VrfFlowRuleProtocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_protocol"] = val

		val, err = v.VrfFlowRuleSrcIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_src_ip"] = val

		val, err = v.VrfFlowRuleSrcPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_flow_rule_src_port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrfFlowRuleAttributesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrfFlowRuleAttributesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrfFlowRuleAttributesValue) String() string {
	return "VrfFlowRuleAttributesValue"
}

func (v VrfFlowRuleAttributesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"vrf_flow_rule_attribute_id":  basetypes.StringType{},
		"vrf_flow_rule_bidirectional": basetypes.BoolType{},
		"vrf_flow_rule_dst_ip":        basetypes.StringType{},
		"vrf_flow_rule_dst_port":      basetypes.StringType{},
		"vrf_flow_rule_protocol":      basetypes.StringType{},
		"vrf_flow_rule_src_ip":        basetypes.StringType{},
		"vrf_flow_rule_src_port":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"vrf_flow_rule_attribute_id":  v.VrfFlowRuleAttributeId,
			"vrf_flow_rule_bidirectional": v.VrfFlowRuleBidirectional,
			"vrf_flow_rule_dst_ip":        v.VrfFlowRuleDstIp,
			"vrf_flow_rule_dst_port":      v.VrfFlowRuleDstPort,
			"vrf_flow_rule_protocol":      v.VrfFlowRuleProtocol,
			"vrf_flow_rule_src_ip":        v.VrfFlowRuleSrcIp,
			"vrf_flow_rule_src_port":      v.VrfFlowRuleSrcPort,
		})

	return objVal, diags
}

func (v VrfFlowRuleAttributesValue) Equal(o attr.Value) bool {
	other, ok := o.(VrfFlowRuleAttributesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.VrfFlowRuleAttributeId.Equal(other.VrfFlowRuleAttributeId) {
		return false
	}

	if !v.VrfFlowRuleBidirectional.Equal(other.VrfFlowRuleBidirectional) {
		return false
	}

	if !v.VrfFlowRuleDstIp.Equal(other.VrfFlowRuleDstIp) {
		return false
	}

	if !v.VrfFlowRuleDstPort.Equal(other.VrfFlowRuleDstPort) {
		return false
	}

	if !v.VrfFlowRuleProtocol.Equal(other.VrfFlowRuleProtocol) {
		return false
	}

	if !v.VrfFlowRuleSrcIp.Equal(other.VrfFlowRuleSrcIp) {
		return false
	}

	if !v.VrfFlowRuleSrcPort.Equal(other.VrfFlowRuleSrcPort) {
		return false
	}

	return true
}

func (v VrfFlowRuleAttributesValue) Type(ctx context.Context) attr.Type {
	return VrfFlowRuleAttributesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrfFlowRuleAttributesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"vrf_flow_rule_attribute_id":  basetypes.StringType{},
		"vrf_flow_rule_bidirectional": basetypes.BoolType{},
		"vrf_flow_rule_dst_ip":        basetypes.StringType{},
		"vrf_flow_rule_dst_port":      basetypes.StringType{},
		"vrf_flow_rule_protocol":      basetypes.StringType{},
		"vrf_flow_rule_src_ip":        basetypes.StringType{},
		"vrf_flow_rule_src_port":      basetypes.StringType{},
	}
}
